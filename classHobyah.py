#! python3
#
# Copyright 2020-2024, Ewan Bennett
#
# All rights reserved.
#
# Released under the BSD 2-clause licence (SPDX identifier: BSD-2-Clause)
#
# email: ewanbennett@fastmail.com
#
# A class for manipulating data from SI binary files generated by Hobyah.
#
# The class has methods for the following:
#  * getting transient data at one point in the tunnels (GetTransientData).
#
#  * getting fixed data along a route at one time (GetFixedRouteData).
#
#  * getting fan curve data and system characteristic data (GetFanDataTransient).
#
#  * printing the contents of the variables in the binary file in a
#    way that makes sense to human eyes (PrettyClassPrint).
#
# Various other routines exist to do ancillary stuff like checking that
# the location to plot at is valid.

import sys
import os
import math
import re                 # regular expressions
import generics as gen    # general routines
import UScustomary as USc # imperial to metric conversion
import pickle
import itertools
try:
    import numpy as np
except ModuleNotFoundError:
    print("> Ugh, can't process this run because Python's\n"
          '> "numpy" library is not installed on this computer.\n'
          '> Please get your local IT guru to install it, then\n'
          '> try again.  If you are your IT guru, good luck!\n'
         )
    if __name__ == "__main__":
        # Only call sys.exit() if we are running it directly (unlikely).
        sys.exit()
try:
    import pandas as pd
except ModuleNotFoundError:
    print("> Ugh, can't process this run because Python's\n"
          '> "pandas" library is not installed on this computer.\n'
          '> Please get your local IT guru to install it, then\n'
          '> try again.  If you are your IT guru, good luck!\n'
         )
    if __name__ == "__main__":
        sys.exit()


class Hobyahdata:
    '''A class for holding the fixed and transient data from a Hobyah
       run.  All the fixed properties of the segments, subsegments,
       nodes, routes, fires, fans, jet fans, trains etc.

       It is fed the path and name of a binary file, opens it and
       returns its data.  Various errors are written to the screen
       and to a logfile, because this class is used in programs that
       have a logfile already open.'''

    # Initialize the data.
    def __init__(self, file_path, file_name, log, complain = True,
                 line_number = 1, line_text = "no line of input"):
        '''Take a folder name, a file name, an already open log file
        and a couple of arguments that can be used in error messages.
        Load the contents into dictionaries and pandas dataframes.

        Parameters:
            file_path     str       The name of a folder
            file_name     str       The name of a .hbn file
            log           handle    The handle of a log file.
            complain      bool      If False, don't complain if this is an
                                    SES .sbn file.  If True, do complain.
            line_number   int       The line number that was read that
                                    prompted this call to open the file
                                    (used in error messages).
            line_text     str       The text of the line being read that
                                    prompted this call to open the file
                                    (used in error messages).

        Returns:
            HobyahData    class     All the fixed and transient data
                                    in the .hbn file if we successfully
                                    read the file.  None if an error
                                    occurred.
        '''
        # Set the file path.  We do some cleaning up and add a trailing
        # slash if needed (I keep forgetting it when running in the
        # interpreter).
        if file_path == '':
            # Set the current directory as the file path.
            self.file_path = os.getcwd()
        else:
            self.file_path = file_path
        if len(self.file_path) > 1 and self.file_path[-1] not in  "/\\":
            # Add a trailing directory separator
            self.file_path = self.file_path + '/'
        self.file_name = file_name
        self.log = log


        # Read the fixed and transient data from the file.  The routine
        # returns a value identifying if this file was read successfully or not.
        # (None if faulty, True if OK).
        self.success = self._ReadHobyahData(complain)
        if self.success is None:
            return(None)
        else:
            # Make a dictionary of the settable options options.  The result is
            # a description that can be used in error messages.  These are
            # all settings from form 1C or form 1G, now held in
            # self.settings_dict.
            self.opt_descrip = {"version": "version (in the settings block)",
                               }

            # Make a dictionary of requirements and data for each plot type.
            # These include the version numbers of Hobyah that can plot them,
            # the options that must be set in order for the property to be
            # available in the output, and a definition of where the property
            # is plotted.
            # This also records if they are signed (i.e. they need to be
            # multiplied by -1 if the tunnels are back-to-front in routes).
            # Temperatures are not signed, air velocities and volume
            # flows are.
            self.properties = {
                "elevations":{"versions": (1,),
                             "solver": ("moc2",),
                             "place": "not used",
                             "descrip": "elevations",
                             "conversion": "dist1",
                             "signed": False,
                             "transient": False,
                             "curve_types": ("profile",),
                             "complexity": "simple",
                             "var_name": self.routes_dict,
                             "x_list": "elevgrad_chs",
                             "y_list": "elevations",
                            },
                "gradients":{"versions": (1,),
                             "solver": ("moc2",),
                             "place": "not used",
                             "descrip": "gradients",
                             "conversion": "dist1",
                             "signed": False,
                             "transient": False,
                             "curve_types": ("profile",),
                             "complexity": "double_up1",
                             "var_name": self.routes_dict,
                             "x_list": "elevgrad_chs",
                             "y_list": "gradients2",
                            },
                "speedlimits":{"versions": (1,),
                             "solver": ("moc2",),
                             "place": "not used",
                             "descrip": "speed limits",
                             "conversion": "speed1",
                             "signed": False,
                             "transient": False,
                             "curve_types": ("profile",),
                             "complexity": "double_up1",
                             "var_name": self.routes_dict,
                             "x_list": "speed_chs",
                             "y_list": "speed_plots",
                            },
                "lanes":    {"versions": (1,),
                             "solver": ("moc2",),
                             "place": "not used",
                             "descrip": "speed limits",
                             "conversion": "speed1",
                             "signed": False,
                             "transient": False,
                             "curve_types": ("profile",),
                             "complexity": "double_up1",
                             "var_name": self.routes_dict,
                             "x_list": "lane_chs",
                             "y_list": "lane_plots",
                            },
                # This is track radius, which is not used in Hobyah.
                # It is written to SES routes in form 8C and is used
                # in the SES train performance calculation (curved
                # track adds a small amount of extra resistance due to
                # the wheels grinding on the curved track).  We include
                # it as a plot to ensure that the data we pass to SES
                # is not corrupted.
                "radius":   {"versions": (1,),
                             "solver": ("moc2",),
                             "place": "not used",
                             "descrip": "track radius",
                             "conversion": "dist1",
                             "signed": False,
                             "transient": False,
                             "curve_types": ("profile",),
                             "complexity": "double_up1",
                             "var_name": self.routes_dict,
                             "x_list": "radii_chs",
                             "y_list": "radii_plots",
                            },
                # This assigns energy sectors for traction power
                # performance calculations to different sections of
                # track.  It is is not used in Hobyah, only in SES.
                # Hobyah writes this data to SES form 8C if there are
                # "SESdata" blocks in the Hobyah input file.
                "sectors":  {"versions": (1,),
                             "solver": ("moc2",),
                             "place": "not used",
                             "descrip": "track sectors",
                             "conversion": "null",
                             "signed": False,
                             "transient": False,
                             "curve_types": ("profile",),
                             "complexity": "double_up1",
                             "var_name": self.routes_dict,
                             "x_list": "sectors_chs",
                             "y_list": "sectors_plots",
                            },
                # This is a coasting allowed/coasting forbidden switch
                # used in the traction power performance calculations.
                # It is is not used in Hobyah, only in SES.
                # Hobyah writes this data to SES form 8C if there are
                # "SESdata" blocks in the Hobyah input file.
                "coasting": {"versions": (1,),
                             "solver": ("moc2",),
                             "place": "not used",
                             "descrip": "coasting rule",
                             "conversion": "null",
                             "signed": False,
                             "transient": False,
                             "curve_types": ("profile",),
                             "complexity": "double_up1",
                             "var_name": self.routes_dict,
                             "x_list": "coasting_chs",
                             "y_list": "coasting_plots",
                            },
                # This is a location-specific regenerative braking factor
                # used in the traction power performance calculations.
                # It is is not used in Hobyah, only in SVS.  Not SES;
                # just SVS.
                # Hobyah writes this data to SES form 8C if there are
                # "SESdata" blocks in the Hobyah input file and the
                # SES input file type is "SVS".
                "regenfrac":{"versions": (1,),
                             "solver": ("moc2",),
                             "place": "not used",
                             "descrip": "regen braking fraction",
                             "conversion": "null",
                             "signed": False,
                             "transient": False,
                             "curve_types": ("profile",),
                             "complexity": "double_up1",
                             "var_name": self.routes_dict,
                             "x_list": "regenfractions_chs",
                             "y_list": "regenfractions_plots",
                            },
                "area":     {"versions": (1,),
                             "solver": ("moc2",),
                             "place": 0, # The index to area in segments_consts
                             "descrip": "tunnel area",
                             "conversion": "area",
                             "signed": False,
                             "transient": False,
                             "curve_types": ("profile",),
                             "complexity": "double_up1",
                             "var_name": "in segments",
                             "open_air": 0.0 # The value to plot if outside the tunnel
                            },
                "perimeter":{"versions": (1,),
                             "solver": ("moc2",),
                             "place": 1, # The index to perimeter in segments_consts
                             "descrip": "tunnel perimeter",
                             "conversion": "dist1",
                             "signed": False,
                             "transient": False,
                             "curve_types": ("profile",),
                             "complexity": "double_up1",
                             "var_name": "in segments",
                             "open_air": 0.0
                            },
                "d_h":      {"versions": (1,),
                             "solver": ("moc2",),
                             "place": 2,
                             "descrip": "hydraulic diameter",
                             "conversion": "dist1",
                             "signed": False,
                             "transient": False,
                             "curve_types": ("profile",),
                             "complexity": "double_up1",
                             "var_name": "in segments",
                             "open_air": 0.0
                            },
                "roughness":{"versions": (1,),
                             "solver": ("moc2",),
                             "place": 3,
                             "descrip": "tunnel roughness",
                             "conversion": "dist1",
                             "signed": False,
                             "transient": False,
                             "curve_types": ("profile",),
                             "complexity": "double_up1",
                             "var_name": "in segments",
                             "open_air": 0.0
                            },
                "fanning":  {"versions": (1,),
                             "solver": ("moc2",),
                             "place": 3,
                             "descrip": "fanning friction factor",
                             "conversion": "dist1",
                             "signed": False,
                             "transient": False,
                             "curve_types": ("profile",),
                             "complexity": "double_up1",
                             "var_name": "in segments",
                             "open_air": 0.0
                            },
                "darcy":    {"versions": (1,),
                             "solver": ("moc2",),
                             "place": 3,
                             "descrip": "darcy friction factor",
                             "conversion": "dist1",
                             "signed": False,
                             "transient": False,
                             "curve_types": ("profile",),
                             "complexity": "double_up1",
                             "var_name": "in segments",
                             "open_air": 0.0
                            },
                "atkinson": {"versions": (1,),
                             "solver": ("moc2",),
                             "place": 3,
                             "descrip": "atkinson friction factor",
                             "conversion": "dist1",
                             "signed": False,
                             "transient": False,
                             "curve_types": ("profile"),
                             "complexity": "double_up1",
                             "var_name": "in segments",
                             "open_air": 0.0
                            },

                "celerity": {"versions": (1,),
                             "solver": ("moc2",),
                             "place": "segment",
                             "descrip": "speed of sound",
                             "conversion": "speed1",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.c_bin,
                             "open_air": self.settings_dict["c_atm"], # The value to plot if outside the tunnel
                            },
                "velocity": {"versions": (1,),
                             "solver": ("moc2",),
                             "place": "segment",
                             "descrip": "air velocity",
                             "conversion": "speed1",
                             "signed": True,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.v_bin,
                             "open_air": 0.0, # The value to plot if outside the tunnel
                            },
                "density":  {"versions": (1,),
                             "solver": ("moc2",),
                             "place": "segment",
                             "descrip": "air density",
                             "conversion": "dens1",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.dens_bin,
                             "open_air": self.settings_dict["rho_atm"], # The value to plot if outside the tunnel
                            },
                "pstat":    {"versions": (1,),
                             "solver": ("moc2",),
                             "place": "segment",
                             "descrip": "static pressure",
                             "conversion": "press1",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.p_stat_bin,
                             "open_air": 0.0
                            },
                "ptot":     {"versions": (1,),
                             "solver": ("moc2",),
                             "place": "segment",
                             "descrip": "total pressure",
                             "conversion": "press1",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.p_tot_bin,
                             "open_air": 0.0
                            },
                "pstatabs": {"versions": (1,),
                             "solver": ("moc2",),
                             "place": "segment",
                             "descrip": "absolute static pressure",
                             "conversion": "press1",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.p_statabs_bin,
                             "open_air": self.settings_dict["p_atm"]
                            },
                "ptotabs":  {"versions": (1,),
                             "solver": ("moc2",),
                             "place": "segment",
                             "descrip": "absolute total pressure",
                             "conversion": "press1",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.p_totabs_bin,
                             "open_air": self.settings_dict["p_atm"]
                            },
                "volflow":  {"versions": (1,),
                             "solver": ("moc2",),
                             "place": "segment",
                             "descrip": "volume flow",
                             "conversion": "volflow",
                             "signed": True,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.q_bin,
                             "open_air": 0.0,
                            },
                "massflow": {"versions": (1,),
                             "solver": ("moc2",),
                             "place": "segment",
                             "descrip": "mass flow",
                             "conversion": "massflow",
                             "signed": True,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.m_bin,
                             "open_air": 0.0,
                            },
                "system":   {"versions": (1,),
                             "solver": ("moc2",),
                             "place": ("fan1", "fan2",),
                             "descrip": "system characteristic",
                             "conversion": "press2",
                             "Xconversion": "volflow",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("fandata",),
                             "var_name": None,
                            },
                "dutypoint":{"versions": (1,),
                             "solver": ("moc2",),
                             "place": ("fan1", "fan2",),
                             "descrip": "fan duty point",
                             "conversion": "press2",
                             "Xconversion": "volflow",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("fandata",),
                             "var_name": None,
                            },
                "fanchar":  {"versions": (1,),
                             "solver": ("moc2",),
                             "place": ("fan1", "fan2",),
                             "descrip": "fan characteristic",
                             "conversion": "press2",
                             "Xconversion": "volflow",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("fandata",),
                             "var_name": None,
                            },
          "system-cursed":  {"versions": (1,),
                             "solver": ("moc2",),
                             "place": ("fan1", "fan2",),
                             "descrip": "system characteristic",
                             "conversion": "press2",
                             "Xconversion": "volflow",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("fandata",),
                             "var_name": None,
                            },
          "fanchar-cursed": {"versions": (1,),
                             "solver": ("moc2",),
                             "place": ("fan1", "fan2",),
                             "descrip": "fan characteristic", # static pressure
                             "conversion": "press2",
                             "Xconversion": "volflow",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("fandata",),
                             "var_name": None,
                            },
                "area_d":   {"versions": (1,),
                             "solver": ("moc2",),
                             "place": ("damper1",),
                             "descrip": "area",
                             "conversion": "area",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.areas_bin,
                            },
                "zeta_bf":  {"versions": (1,),
                             "solver": ("moc2",),
                             "place": ("damper1",),
                             "descrip": "k-factor (+ve flow)",
                             "conversion": "null",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.zetas_bf_bin,
                            },
                "zeta_fb":  {"versions": (1,),
                             "solver": ("moc2",),
                             "place": ("damper1",),
                             "descrip": "k-factor (-ve flow)",
                             "conversion": "null",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.zetas_fb_bin,
                            },
                "r_bf":     {"versions": (1,),
                             "solver": ("moc2",),
                             "place": ("damper1", "damper2",),
                             "descrip": "resistance (+ve flow)",
                             "conversion": "atk",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.Rs_bf_bin,
                            },
                "r_fb":     {"versions": (1,),
                             "solver": ("moc2",),
                             "place": ("damper1", "damper2", ),
                             "descrip": "resistance (-ve flow)",
                             "conversion": "atk",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.Rs_fb_bin,
                            },
                # This next is the change in static pressure across
                # fans and dampers.  The area on each side is the
                # same, so the velocities on each side are similar
                # There are negligible velocity differences across
                # dampers and low changes across tunnel ventilation
                # fans (which are usually <4 kPa fan total pressure
                # rise).  The change in velocity across fans is low
                # enough that the change in fan static pressure rise
                # can be treated as the change in fan total pressure
                # rise too.  This would no longer be the case if
                # someone used the  program to model blowers instead
                # of fans, or dampers with very high pressure drops.
                # But in systems like that, the change in temperature
                # becomes an issue and a fully non-homentropic code
                # should probably be used.
                "pdiff":     {"versions": (1,),
                             "solver": ("moc2",),
                             "place": ("damper1", "damper2", "tunnelfan"),
                             "descrip": "pressure change",
                             "conversion": "press1",
                             "signed": True,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.p_diff_dict,
                            },
                # These are skeleton properties intrinsic to trains.
                # "speed":    {"versions": (1,),
                #              "solver": ("moc2",),
                #              "place": "train",
                #              "descrip": "speed of",
                #              "conversion": "speed2", # km/h and mph
                #              "signed": False,
                #              "transient": True,
                #              "curve_types": ("transient",),
                #              "var_name": self.tr_speeds_bin,
                #             },
                # "speedms":  {"versions": (1,),
                #              "solver": ("moc2",),
                #              "place": "train",
                #              "descrip": "speed of",
                #              "conversion": "speed1", # m/s and fpm
                #              "signed": False,
                #              "transient": True,
                #              "curve_types": ("transient",),
                #              "var_name": self.tr_speeds_bin,
                #             },
                # "accel":    {"versions": (1,),
                #              "solver": ("moc2",),
                #              "place": "train",
                #              "descrip": "acceleration of",
                #              "conversion": "accel",
                #              "signed": False,
                #              "transient": True,
                #              "curve_types": ("transient",),
                #              "var_name": self.tr_accels_bin,
                #             },
                # "down_ch":  {"versions": (1,),
                #              "solver": ("moc2",),
                #              "place": "train",
                #              "descrip": "location of the down end of",
                #              "conversion": "dist1",
                #              "signed": False,
                #              "transient": True,
                #              "curve_types": ("transient",),
                #              "var_name": self.tr_down_bin,
                #             },
                # "up_ch":    {"versions": (1,),
                #              "solver": ("moc2",),
                #              "place": "train",
                #              "descrip": "location of the up end of",
                #              "conversion": "dist1",
                #              "signed": False,
                #              "transient": True,
                #              "curve_types": ("transient",),
                #              "var_name": self.tr_up_bin,
                #             },
                # These skeleton properties for traffic in segments.
                # If a file has a "traffictypes" block with traffic
                # names in it, "_flow" or "dens" are appended to each
                # name and the dictionary below is copied as a new
                # entry with that name as the key.  If your file has
                # a vehicle type named "HGV" the keys become
                # "HGV_flow" and "HGV_dens".
                # We put a "#" in these keys so that they can't be
                # directly accessed in Hobyah plots.
                "#flow":    {"versions": (1,),
                             "solver": ("moc2",),
                             "place": "route",
                             "descrip": " flowrate (veh/hr)",
                             "conversion": "null",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile",),
                             "var_name": "#fixed vehicle stuff",
                            },
                "#dens":    {"versions": (1,),
                             "solver": ("moc2",),
                             "place": "route",
                             "descrip": " density (veh/km)",
                             "conversion": "trafdens",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile",),
                             "var_name": "#fixed vehicle stuff",
                            },
                "tot_flow": {"versions": (1,),
                             "solver": ("moc2",),
                             "place": "route",
                             "descrip": "total flowrate (veh/hr)",
                             "conversion": "null",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile",),
                             "var_name": "#fixed vehicle stuff",
                            },
                "tot_dens": {"versions": (1,),
                             "solver": ("moc2",),
                             "place": "route",
                             "descrip": "total density (veh/km)",
                             "conversion": "trafdens",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile",),
                             "var_name": "#fixed vehicle stuff",
                            },
                # Add a fake property that triggers error 7042.
                "_t7042":   {"versions": (1,),
                             "solver": ("moc4",),
                             "place": ("segment", ),
                             "descrip": "fake property to cause an error",
                             "conversion": "null",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile", ),
                             "var_name": self.Rs_fb_bin,
                            },
                              }
            # Now make a list of things that we may want  negative versions
            # of: the flows, velocities and gauge pressures (no point doing
            # it for absolute pressures).
            # These are all multiplied by -1 when the values are generated.
            rev_props = ["-massflow", "-pdiff", "-pstat", "-ptot",
                         "-velocity", "-volflow",]

            # Now add entries for the reversed properties.
            for new_key in rev_props:
                # Prepend a negative sign to the description and set
                # an entry for the negated property.
                vector_prop = self.properties[new_key[1:]].copy()
                descrip = vector_prop["descrip"]
                vector_prop.__setitem__("descrip", "-" + descrip)
                self.properties.__setitem__(new_key, vector_prop)

            # Create traffic properties for each type of vehicle in
            # the file and store the names in a list of keywords that
            # access traffic properties.  Also create a list of the
            # names of the traffic.
            self.traffic_prop = ["tot_flow", "tot_dens"]
            self.veh_types = []
            flow_dict = self.properties["#flow"]
            dens_dict = self.properties["#dens"]
            for key in self.vehcalc_dict.keys():
                self.veh_types.append(key)
                flow_dict.__setitem__("descrip", key + " flowrate (veh/hr)")
                dens_dict.__setitem__("descrip", key + " density (veh/km)")
                name = key + "_flow"
                self.properties.__setitem__(name, flow_dict.copy())
                self.traffic_prop.append(name)
                name = key + "_dens"
                self.properties.__setitem__(name, dens_dict.copy())
                self.traffic_prop.append(name)

            # Build two lists of the keys to properties.  The first is
            # just a list of them.  The second is a list with the test
            # entry (or entries) removed (test entries start with an
            # underscore) and the Atkinson resistance plot properties
            # changed from e.g., "r_bf" to "R_bf" (it just seems weird
            # to be using a lowercase 'r' in a property that most people
            # using this will be entirely unfamiliar with and, when they
            # look it up in mine ventilation papers, will see 'R'.  The
            # list is used in error messages.
            self.availables = list(self.properties.keys())
            self.availables.sort()
            # Remove hidden properties like "_t7042" and "#dens" and
            # ignore the reversed properties (we want them at the end).
            interim = [entry for entry in self.availables if
                                               entry[0] not in ('_', '#', '-')]
            # Capitalise the Atkinson resistance terms.
            # self.plottables = [entry.capitalize() if entry[:2] == 'r_'
            #                                       else entry
            #                                       for entry in interim]
            self.plottables = interim
            # Add the names of the reversed properties at the end.
            self.availables.extend(rev_props)
            self.plottables.extend(rev_props)

            # Make a list of transient properties that apply at dampers.
            self.damper_props = []
            # Make a list of the properties that apply at fans.
            self.fan_props = []
            # Make a list of the properties that apply at trains and are
            # intrinsic to trains.
            self.train1_props = []
            for plot_type in self.plottables:
                # Filter out the properties in which "place" is an index
                # in segments_source.
                place = self.properties[plot_type.lower()]["place"]
                if type(place) is tuple or type(place) is str:
                    if "damper1" in place:
                            self.damper_props.append(plot_type)
                    if "tunnelfan" in place:
                            self.fan_props.append(plot_type)
                    if "train" in place:
                            self.train1_props.append(plot_type)
            # Make a list of properties that apply at dampers, fans
            # and trains.
            self.damfantrain_props = (self.damper_props + self.fan_props
                                      + self.train1_props)


    def _ReadHobyahData(self, complain):
        '''Read the fixed and transient data in the pickle file and return
           the data in it.  Generate lists, dictionaries and pandas
            dataframes of the runtime data.  There are too many to list
            and constantly changing, so see the code below.

        Parameters:
            self          class     Everything in the class.
            complain      bool      If False, don't complain if this is an
                                    SES .sbn file.  If True, do complain.

        Returns:
            None if an error occurred, True if all was well.

        Errors:
            Aborts with 7001 if the filename is empty (can only happen
            called directly in an IDE).
            Aborts with 7002 if the first pickled item we read was not
            a string (it should be a version string along the lines of
            "Hobyah.py binary version 3" or "Hobyah.py binary version 42").
            Aborts with 7003 if the first pickled item we read was a
            string but started with "SESconv.py binary version ".
            Aborts with 7004 if the first pickled item we read was a
            string but didn't start with "Hobyah.py binary version " and
            end with an integer.
            Aborts with 7005 if the binary file's version was too low for
            this version of the class to process.
            Aborts with 7006 if the binary file's version was too high.
            Aborts with 7007 if the binary file doesn't exist.
            Aborts with 7008 if we don't have permission to read the
            binary file.
        '''

        # Set the binary file version number that this version of the
        # class can process.  We increase the number at the end each
        # time we add something to the file that breaks the backwards
        # compatibility with earlier binary files.

        if self.file_name == "":
            # The name of the binary file is empty.  Complain and return.
            err = ("> The name of the binary file is blank.  The path is\n"
                   '> "' + self.file_path + '".'
                  )
            gen.WriteError(7001, err, self.log)
            return(None)
        try:
            with open(self.file_path + self.file_name,'rb') as pkl:
                # Read the binary file version string and check it is
                # not too high and not too low.
                result = self._UnPickleData("the binary file version", 0, pkl)
                if result is None:
                    # We fouled up somehow.
                    return(None)
                else:
                    self.binversion_string = result

                # Now check the binary file version string.  We want it to
                # be a string like "Hobyah.py binary version 3".  First
                # we complain if it is not a string, then check its contents
                # then we check for lower versions (no good) and higher
                # versions (also no good).
                if type(self.binversion_string) is not str:
                    # First get a suitable slice of whatever we have here,
                    # it might be helpful in tracing the error.  We turn
                    # it into a string and take the first 60 characters.
                    text = str(self.binversion_string).lstrip().rstrip()
                    if len(text) > 60:
                        text = text[:57] + "..."
                        class_text = str(type(self.binversion_string))[1:-1] \
                                     + " and started\n> with:"
                    else:
                        class_text = str(type(self.binversion_string))[1:-1] \
                                     + " and contained:"
                    err = ('> A binary file has a version string (the\n'
                           '> first thing in the binary file) that was\n'
                           '> not a string.  The .hbn file was probably\n'
                           '> not created by Hobyah.py.\n'
                           '> The version string should have been some-\n'
                           '> thing like "Hobyah.py binary version 12",\n'
                           '> but it was of ' + class_text + '\n'
                           '>    "' + text + '"\n'
                           '> The faulty file is "' + self.file_name + '".'
                          )
                    gen.WriteError(7002, err, self.log)
                    return(None)

                # If we get to here we have a string.  Check it.  We want
                # it to be something like "Hobyah.py binary version 3".  First
                # set a Boolean and split the string.
                dud = False
                parts = result.split()
                if result[:26] == "SESconv.py binary version ":
                    # This is not a suitable file to be loaded into
                    # classHobyah, as it has all the fingerprints of a
                    # file intended for classSES.  Someone probably
                    # renamed a file so it ends with ".hbn" instead
                    # of ".sbn".
                    err = ('> A binary file has a version string (the\n'
                           '> first thing in the binary file) that\n'
                           '> looks like a Hobyah.py version string,\n'
                           '> not an SESconv.py version string.\n'
                           '> The version string should have been some-\n'
                           '> thing like "Hobyah.py binary version 5",\n'
                           '> but it was\n'
                           '>    "' + result + '"\n'
                           '> Someone probably renamed an SESconv.py\n'
                           '> ".sbn" file to end with ".hbn" instead.\n'
                           '> The faulty file is "' + self.file_name + '".'
                          )
                    gen.WriteError(7003, err, self.log)
                    return(None)
                elif result[:25] != "Hobyah.py binary version ":
                    # The first three words were incorrect.
                    dud = True
                elif len(parts) != 4:
                    # It had too many words in it.
                    dud = True
                elif not (parts[3].isdecimal()):
                    # The fourth word is not all digits.
                    dud = True

                if dud:
                    # Get a shortish slice of the string for the error
                    # message, as it could be enormous.  We take the
                    # first 60 characters or the first 57 and add an
                    # ellipsis.
                    if len(result) <= 60:
                        text = result
                    else:
                        text = result[:57] + "..."
                    err = ('> A binary file has a version string that\n'
                           "> didn't"' match the required form (the words\n'
                           '> "Hobyah.py binary version XX" where XX is\n'
                           '> an integer.  Instead it was\n'
                           '>   "' + text + '"\n'
                           '> The faulty file is "' + self.file_name + '".\n'
                           '> It was not created by Hobyah.py, it just\n'
                           '> happens to be a pickle file that started\n'
                           '> with a string.'
                          )
                    gen.WriteError(7004, err, self.log)
                    return(None)
                else:
                    # This does look like a Hobyah binary file.  Get the
                    # version as a number.  We don't have to try...catch
                    # this as we already checked that the fourth word is
                    # all digits.
                    self.binversion = int(parts[3])

                # Now check the version number.  The entry below is the version
                # number that this version of the class can handle.
                self.required = 7
                if self.binversion < self.required:
                    err = ('> A binary file has a version number that is\n'
                           '> too old for this program to process correctly.\n'
                           '> The file is of binary version ' + str(self.binversion)
                             + ' and this\n'
                           '> program can only handle files of version '
                             + str(self.required) + '.\n'
                           '> Please rerun the file with a version of\n'
                           '> Hobyah.py that generates binary files of\n'
                           '> version ' + str(self.required) + '.\n'
                           '> The faulty file is "' + self.file_name + '".'
                          )
                    gen.WriteError(7005, err, self.log)
                    return(None)
                elif self.binversion > self.required:
                    err = ('> A binary file has a version number that is\n'
                           '> too new for this program to process correctly.\n'
                           '> The file is of binary version ' + str(self.binversion)
                             + ' and this\n'
                           '> program can only handle files of version '
                             + str(self.required) + '.\n'
                           '> Please update your version of this program\n'
                           '> and its dependent modules.\n'
                           '> The faulty file is "' + self.file_name + '".'
                          )
                    gen.WriteError(7006, err, self.log)
                    return(None)

                # Read the fixed data, giving the expected count of entries.
                # When this changes, we need to update the counter of fixed
                # entries, the list in the 'else' clause below and the list
                # in the procedure PrettyClassPrint.

                fcount = 27
                self.fixed_data = self._UnPickleData("the fixed data", fcount, pkl)
                if self.fixed_data is None:
                    return(None)
                else:
                    # Unpack 'fcount' entries to their correct variables.
                    (self.prog_type,
                     self.when_who,
                     self.runfile_name, # Name of the .txt file that created it.
                     self.script_name, # Name of the script that created this
                     self.script_date, # Date this script was last edited
                     self.settings_dict,
                     self.sectypes_dict,
                     self.tunnels_dict,
                     self.routes_dict,
                     self.fanchars_dict,
                     self.tunnelfans_dict,
                     self.JFblock_dict,
                     self.JFcalc_dict,
                     self.timedlosses_dict,
                     self.plotcontrol_dict,
                     self.aero_times,
                     self.segment_source,
                     self.tuns2segs,
                     self.segments_consts,
                     self.joins_dict,
                     self.dists,
                     self.locators,
                     self.route2segs_dict, # See the note below for details
                     self.vehicles_dict,
                     self.vehcalc_dict,
                     self.r_traffic_dict,
                     self.t_traffic_dict,
                    ) = self.fixed_data

                # A quick note about file names for future reference:
                # "self.file_name" is the name of the .hbn file and
                # "self.runfile_name" is the name of the .txt file that
                # created the .hbn file.  We keep them separate in case
                # a .hbn file is renamed and we need to distinguish
                # between the name of the Hobyah input file to rerun and
                # the name of the binary file we just read.

                # Another note for future reference:
                # and tuns2segs have keys that are the route names or
                # tunnel names and return a dictionary with two keys
                # in it that each return a tuple, as follows:
                #
                #  * Key "segs": the seg_IDs in the route/tunnel starting
                #    from up/back end and ending at the down/fwd end.
                #  * Key "seg_chs": the chainages of the ends of the
                #    segments in the route (or distances in the tunnels).
                #    This list is one entry longer than the previous one
                #    because it has the chainages of the up portal and
                #    the down portal.
                # route2segs_dict has two additional entries:
                #  * Key "offsets": the value to add to the route chainage
                #    to turn the chainage into the distance at the up
                #    end of the segment (this could be the back end or
                #    the forward end of the segment, depending on the
                #    segment orientation).
                #  * Key "mults": +1 if the corresponding seg_ID has its
                #    back end at the up end in the route and -1 if the
                #    seg_ID has its forward end at the up end instead.

                # Read the transient data from the Hobyah .hbn file.
                # When this changes, we need to update the counter, the list
                # in the 'else' clause below and the list in the procedure
                # PrettyClassPrint.
                vcount = 7
                self.transient_data = self._UnPickleData("the transient data", vcount, pkl)
                if self.transient_data is None:
                    return(None)
                else:
                    # Load the lists of celerity and velocity in each timestep
                    # and timed damper properties.
                    # Each sub-list is a list of numpy arrays, each numpy array
                    # contains all the values of c or v at the gridpoints in
                    # one segment.
                    (self.c_bin,
                     self.v_bin,
                     self.areas_bin,    # Variation of damper properties with time
                     self.zetas_bf_bin,
                     self.zetas_fb_bin,
                     self.Rs_bf_bin,
                     self.Rs_fb_bin,
                    ) = self.transient_data

                # Get arrays holding the air densities, pressures, volume
                # flows and mass flows.  We do this here to reduce the size
                # of the .hbn file.  If it turns out to be a performance
                # bottleneck we can do it in Hobyah.py instead.
                self.BuildCellProperties()

                # Get the traffic data into a dictionary that is
                # indexed by route name instead of tr_index.
                self.traffic1_dict = {}
                for tr_index in self.r_traffic_dict:
                    name = self.r_traffic_dict[tr_index]["block_index"][0]
                    self.traffic1_dict.__setitem__(name,
                                            self.r_traffic_dict[tr_index])

        except FileNotFoundError:
            if complain:
                # The binary file doesn't exist.  The routine that
                # called may have not wanted to complain.
                err = ("> A binary file does not exist.  The missing\n"
                       '> file is "' + self.file_name + '" in folder\n'
                       '> "' + self.file_path + '".'
                      )
                gen.WriteError(7007, err, self.log)
            # Even if we didn't issue an error message, we return None.
            return(None)
        except PermissionError:
            # The binary file exists but we don't have permission to
            # read it.  Complain and return.
            err = ("> A binary file has its permissions set\n"
                   "> so that you can't read the file.  The\n"
                   '> locked file is "' + self.file_name + '".'
                  )
            gen.WriteError(7008, err, self.log)
            return(None)
        return(True)


    def BuildCellProperties(self):
        '''
        Take the content of the binary file (values of celerity, velocity
        and area), the reference conditions of air (c_atm and rho_atm)
        and a couple of constants in the isentropic flow calculation.
        Calculate the air density, static air pressure, total air pressure
        and volume flow at each gridpoint.  We get both the gauge pressures
        and the absolute pressures.

        Parameters:
            self          class     Everything in the class.

        Returns:
            Lists of pandas 2D arrays holding density, four types of
            pressure and volume flow.
                self.dens_bin
                self.p_stat_bin
                self.p_tot_bin
                self.p_statabs_bin
                self.p_totabs_bin
                self.q_bin
                self.p_diff_dict
        '''
        # Get some values we will need to calculate density and
        # pressure from the celerities and velocities.
        c_atm = self.settings_dict["c_atm"]
        rho_atm = self.settings_dict["rho_atm"]
        psi = self.settings_dict["psi"]
        gamma = self.settings_dict["gamma"]
        p_atm = self.settings_dict["p_atm"]

        # Make some lists for pressures, densities, volume flows and
        # mass flows, which we calculate from the celerities and velocities.
        self.dens_bin = []
        self.p_stat_bin = []
        self.p_tot_bin = []
        self.p_statabs_bin = []
        self.p_totabs_bin = []
        self.q_bin = []
        self.m_bin = []

        # Loop over the lists of segment data
        for (c_oneseg, v_oneseg, seg_consts) in zip(self.c_bin,
                                                    self.v_bin,
                                                    self.segments_consts):
            # c_oneseg and v_oneseg are pandas 2D arrays giving celerity
            # and velocity in one segment.  The index is plot time (float),
            # the columns are the gridpoint distances (also float).
            #
            # segments_consts is a list of the properties of each
            # segment (including area, which we need to calculate
            # volume flow from velocity).

            # Get the density, static pressure, dynamic pressure
            # and total pressure from the celerity and velocity.
            # These are also pandas 2D arrays, so we don't need
            # loops to do the multiplication.
            dens_seg = rho_atm * (c_oneseg/c_atm)**psi
            p_statabs_seg = dens_seg / gamma * c_oneseg**2
            # p_dyn_seg = 0.5 * dens_seg * v_oneseg**2
            p_totabs_seg = p_statabs_seg + 0.5 * dens_seg * v_oneseg**2
            p_stat_seg = p_statabs_seg - p_atm
            p_tot_seg = p_totabs_seg - p_atm

            # Add the density and pressure in this segment to
            # the lists.
            self.dens_bin.append(dens_seg)
            self.p_statabs_bin.append(p_statabs_seg)
            self.p_totabs_bin.append(p_totabs_seg)
            self.p_stat_bin.append(p_stat_seg)
            self.p_tot_bin.append(p_tot_seg)

            # Build a list of volume flows from the velocity, then a list
            # of mass flows from the volume flow and density.
            #
            # seg_consts[0] is segment area.
            q_seg = v_oneseg * seg_consts[0]
            self.q_bin.append(q_seg)
            self.m_bin.append(q_seg * dens_seg)

        # Create a dictionary to hold the total pressure difference across
        # dampers and fans.  The keys are the name of the fan or damper,
        # the result is a 1D pandas array.
        #
        self.p_diff_dict = {}
        for damper_name in self.timedlosses_dict:
            # Build a list of the total pressure change across dampers
            # at each timestep.
            d_props = self.timedlosses_dict[damper_name]
            back, fwd = d_props[1:3]
            dp = self.p_tot_bin[fwd].iloc[:, 0] -      \
                 self.p_tot_bin[back].iloc[:, -1]

            self.p_diff_dict.__setitem__(damper_name, dp)
        for fan_name in self.tunnelfans_dict:
            # Build a list of the total pressure change across fans
            # at each timestep.
            f_props = self.tunnelfans_dict[fan_name]
            back, fwd = f_props[9:11]
            dp = self.p_tot_bin[fwd].iloc[:, 0] -      \
                 self.p_tot_bin[back].iloc[:, -1]
            self.p_diff_dict.__setitem__(fan_name, dp)

        # Create a list that points segments to the correct place
        # in pandas dataframes, so we don't have to keep subtracting
        # one from the seg_IDs.
        self.tuns2frames = {}
        for key, result in self.tuns2segs.items():
            try:
                # Temporary code for
                segs = result["segs"]
            except TypeError:
                segs = result
            self.tuns2frames.__setitem__(key, [seg - 1 for seg in segs])

        # Create a dictionary to hold the pressure differences across
        # named plot locations.

        return()


    def _UnPickleData(self, descrip, count, pkl):
        '''Read some data from a pickle file and check it is the correct
        length.  If it is, return it.  If it isn't, raise an error about
        too many or too few entries.  Catches the cases where the contents
        of the file aren't pickled and where the file ends unexpectedly.

        Parameters:
            file_path     str       The name of a folder
            self          class     Everything in the class.
            descrip       str       A description to use in any
                                    error messages.
            count         int       How many entries we expect the
                                    value being read to split into.
                                    If it is zero don't check the
                                    length.
            pkl           handle    The handle of the file to read from.


        Returns:
            The contents of the class from the file, None if not.

        Errors:
            Aborts with 7021 if the content was not a pickle object.
            Aborts with 7022 if the file ended unexpectedly.
            Aborts with 7023 if some other error occurred (the pickle
            module has many failure options).
            Aborts with 7024 if the length of the value was not what
            we expected it to be.
        '''
        try:
            value = pickle.load(pkl)
        except pickle.UnpicklingError:
            # This part of the binary file wasn't made by pickling.
            err = ('> The binary file "' + self.file_name + '"\n'
                   '> is not a Python pickle file.  Please check\n'
                   '> whether it was generated from Hobyah.py.\n'
                   '> The pickle.load() function failed while\n'
                   '> reading ' + descrip + '.'
                   )
            gen.WriteError(7021, err, self.log)
            return(None)
        except EOFError:
            # The binary file ended unexpectedly.
            err = ('> The binary file "' + self.file_name + '"\n'
                   '> ended unexpectedly.  Please check whether\n'
                   '> it was generated from Hobyah.py.\n'
                   '> The pickle.load() function failed while\n'
                   '> reading ' + descrip + '.'
                   )
            gen.WriteError(7022, err, self.log)
            return(None)
        except Exception as my_trace:
            # Every other kind of exception, with a traceback message.
            # I've triggered this when trying to read pickle files in
            # a new version of pandas that were written by an older
            # version of pandas.  The traceback read:
            #   Can't get attribute 'new_block' on <module 'pandas.core.internals.blocks'
            # Rerunning the Hobyah files fixed it.
            err = ('> The binary file "' + self.file_name + '"\n'
                   '> failed during a pickle.read() action.\n'
                   '> The most common cause of this error is a\n'
                   '> new version of numpy or pandas being fed\n'
                   '> array data written by an earlier version\n'
                   '> of numpy or pandas, in which case the\n'
                   '> way to solve the problem is to run the\n'
                   '> calculation again.\n'
                   '> It failed while reading ' + descrip + '\n'
                   '> with the following traceback message:'
                   )
            gen.WriteError(7023, err, self.log)
            print('>  ', my_trace)
            return(None)

        # If we get to here we read a block of data. Figure out how
        # long it is (most entries will be tuples rather than strings
        # of variable length).  If the expected count is zero we skip
        # this test, because we may have variable length blocks.
        if count != 0 and len(value) != count:
            # We'll be triggering this one a lot, each time the
            # format of the binary file changes.
            err = ('> The binary file "' + self.file_name + '"\n'
                   '> has a block of data of unexpected length\n'
                   '> for ' + descrip + '.\n'
                   '> Expected ' + str(count)
                       + ' item' + gen.Plural(count) + ' but read '
                       + str(len(value)) + ' instead.\n'
                   )
            gen.WriteError(7024, err, self.log)
            return(None)
        return(value)


    def PrettyClassPrint(self, name = ""):
        '''A function to print the contents of a Hobyah .bin file in a
        human-readable way.  This is mostly so that people who may
        want to use the contents of Hobyah.py binary files to do other
        things have a way of easily seeing what the contents are.
        There is an optional argument 'name':

         * If 'name' is the name of a variable in the .hbn file it prints the
           contents of that variable only.

         * If 'name' is blank the entire contents are printed (this can take
           up a lot of space in the terminal window).

         * If 'name' is not the name of a valid variable it gives a list of
           the valid names.  This is useful if you forget what the name of
           a variable is: use PrettyClassPrint("blah") and it returns a list
           of all the names.

        Parameters:
            self            class           Everything in the class.
            name            str             A string that can be empty, the name
                                            of a variable in the class, or a
                                            random string.

        Returns:
            None
        '''
        # Make a list of the properties whose names we want to hide from
        # programmers using the PrettyClassPrint function.  These are
        # mostly internal variables of no use if you are only interested
        # in finding the run data.
        ignore = ['fixed_data', 'transient_data', 'log', 'opt_descrip',
                  'properties', 'success',
                 ]
        # Make a list of the properties we know we have at the moment.
        # Last updated to version 4 binary files.

        fixed_known = ['binversion_string', # "Hobyah.py binary version 4".
                       'binversion',
                       'file_name',
                       'file_path',
                       'prog_type',         # Input file version ("Hobyah 1").
                       'when_who',
                       'runfile_name',
                       'script_name',
                       'script_date',
                       'settings_dict',
                       'sectypes_dict',
                       'tunnels_dict',
                       'routes_dict',
                       'fanchars_dict',
                       'tunnelfans_dict',
                       'timedlosses_dict',
                       'plotcontrol_dict',
                       'aero_times',
                       'segment_source',
                       'tuns2frames',
                       'segments_consts',
                       'dists',
                       'locators',
                       'route2segs_dict',
                       'vehicles_dict',
                       'vehcalc_dict',
                       'plottables',
                       'damper_props',
                       'fan_props',
                      ]
        trans_known = ['c_bin',
                       'v_bin',
                       'dens_bin',
                       'p_stat_bin',    # gauge pressure (e.g. 0 Pa).  This
                                          # subtracts both the outside atmospheric
                                          # pressure and rho * g * H at the
                                          # elevation of every gridpoint.
                       'p_statabs_bin', # absolute pressure (e.g. 101325 Pa).
                                          # This is the true calculated value
                                          # at every gridpoint, accounting for
                                          # local elevation.
                       'p_tot_bin',
                       'p_totabs_bin',
                       'q_bin',         # Volume flow in m^3/s
                       'm_bin,',        # Mass flow in kg/s
                       'areas_bin,',    # These next five are conditions at
                       'zetas_bf_bin',  # dampers: area, k-factors for +ve
                       'zetas_fb_bin',  # and -ve flow, Atkinson resistances
                       'Rs_bf_bin',     # for +ve and -ve flow.
                       'Rs_fb_bin',
                      ]
        # Make a list of any properties that we haven't handled yet.  We
        # get a list of all of them (dir.self()).  Then we ignore the ones
        # that:
        #  * start with a capital letter (functions inside the class),
        #  * ones that start with an underscore (internal values/functions)
        #  * the ones already in 'ignore',
        #  * the ones already in 'fixed_known',
        #  * the ones already in 'trans_known'.
        # Ideally this would be empty.  But as we add more content to the
        # binary file it may not be, so this is where we pick up on that.
        missed = [entry for entry in dir(self) if entry[0].islower() and
                                                  not (entry in ignore or
                                                       entry in fixed_known or
                                                       entry in trans_known)
                 ]
        if name == "":
            # The user wanted everything.
            print('='*78 + '\n'
                  'Start of the pretty-printout of the contents of the binary\n'
                  'file "' + self.file_name + '".  A few ground rules:\n'
                  '  * everything saved in the binary file is in SI units.\n'
                  '  * the binary file has a fixed section (containing the\n'
                  '  * processed contents of the input file) and a transient\n'
                  '  * section containing the runtime output.\n'
                 )
            print("Known fixed entries in the binary file:")
            for entry in fixed_known:
                self._DebugPrint(entry)
                print('')
            print("Known transient entries in the binary file:")
            for entry in trans_known:
                self._DebugPrint(entry)
                print('')

            if missed == []:
                print("There were no unexpected entries in the binary file.")
            else:
                print("Unexpected entries in the binary file:")
                for entry in missed:
                    self._DebugPrint(entry)
                print("There were unexpected entries in the binary file:", missed)
            print('End of the pretty-printout of the contents of the binary file.\n'
                  + '='*78 + '\n')
        else:
            # The user wanted to print one variable.  Check if it exists.
            # If it doesn't print the name of all the available variables.
            if name in fixed_known + trans_known + missed:
                print('Printing the contents of "' + name + '" in "' + self.file_name + '".')
                self._DebugPrint(name)
                print('Printed the contents of "' + name + '" only.\n')
            else:
                print('> Tried to print the contents of "' + name + '" in\n'
                      '> "' + self.file_name + '"' + " but it doesn't exist.\n"
                      '> Here are the valid names:\n'
                      + gen.FormatOnLines(fixed_known + trans_known + missed))
        return()


    def _DebugPrint(self, name):
        '''Take the name of an item (list, string, dictionary).  Print the
        contents in a human-readable way.

        Parameters:
            self            class           Everything in the class.
            name            str             The name by which this is
                                            known (this is an ugly hack
                                            to get something that makes
                                            sense to the reader).

        Returns:
            None
        '''
        # Get the contents of the named thing.  I don't like using
        # "eval" and will change if a better option presents itself.
        item = eval("self." + name)

        if type(item) is bool:
            print('  Boolean "self.' + name + '":', item)
        elif type(item) is int:
            print('  int "self.' + name + '":', item)
        elif type(item) is float:
            print('  float "self.' + name + '":', gen.FloatText(item))
        elif type(item) is str:
            print('  str "self.' + name + '": ' + "'" + item + "'")
        elif type(item) in (tuple, list):
            print('  list "self.' + name + '":', item)
            # for entry in item:
            #     print("  ", entry)
        elif type(item) is dict:
            print('  dict "self.' + name + '":')
            for subitem in item:
                if type(subitem) is float:
                    # It's a number, remove spurious trailing digits and
                    # print it.
                    print("    ", item,":", gen.FloatText(item[item]))
                try:
                    this_item = item[subitem]
                except KeyError:
                    # It's not a sub-dictionary
                    print("    ", subitem,":", item[subitem])
                else:
                    # It is a subdictionary.  Print its entries on individual
                    # indented lines.
                    if type(this_item) is dict:
                        print('    subdict "' + str(subitem) + '":')
                        for sub_key in this_item:
                            print('      "' + str(sub_key) + '":', this_item[sub_key])
                    else:
                        # It's something subscriptable but not a dictionary.
                        print("    ", subitem,":", item[subitem])
        elif type(item) is pd.DataFrame:
            # Printing of pandas dataframes is well formatted, a neat
            # touch about the library that I appreciate.
            print('  pandas dataframe "self.' + name + '":\n', item, '\n')
        else:
            print('  unknown type: "self.', name + '":\n', item)
        return()


    def CheckProperty(self, prop, curve_type, file_name, line_number, line_text):
        '''Take the name of the property to plot (velocity, volume flow,
        temperature etc.).  Check if this property can be plotted from this
        run.  If it can, return True if it is a transient plot (such as
        volume flow) and False if it is a fixed plot (such as elevation).
        If it can't be plotted, write a detailed error message telling the
        user either that it can't be plotted at all or telling the user
        what options need to be set to allow it to be plotted.

        Parameters:
            self            class       Everything in the class.
            prop            str         A string naming the property to plot.
            curve_type      str         A string describing what kind of
                                        curve this is, e.g. transient, profile
                                        etc.  Used in error messages.
            file_name       str         The name of the file being processed
                                        when this routine was called.  Used in
                                        error messages.  Not the name of the
                                        .hbn file being plotted from.
            line_number     int         The line number being processed.  Used
                                        in error messages.
            line_text       str         The text of the line being processed.
                                        Used in error messages.

        Returns:
            transient       Bool        True if the property is transient,
                                        False if it is not, None if it
                                        is not valid.

        Errors:
            Aborts with 7041 if the name of the property is not a valid one.
            Aborts with 7042 if the property cannot be plotted from this
            type of output file (can't be triggered yet, maybe one day).
            Aborts with 7043 if the property is not suitable for the curve
            type.  For example, it wouldn't make sense to try to plot the
            fan characteristic curve on a waterfall diagram.
        '''



        if prop.lower() not in self.availables:
            err = ('> Came across an invalid plot type in "' + file_name + '".\n'
                   '> The plot type was "' + prop + '", to be plotted\n'
                   '> from a Hobyah output file.  Unfortunately that\n'
                   '> property is not valid for Hobyah, you can\n'
                   '> only plot the following:\n'
                   + gen.FormatOnLines(self.plottables) +
                   '\n> Please edit the file to correct it.'
                   )
            gen.WriteError(7041, err, self.log)
            gen.ErrorOnLine(line_number, line_text, self.log, False)
            return(None)
        else:
            # It is a valid Hobyah property.
            curve_props = self.properties[prop.lower()]

        # Now check if the property is available in this version of Hobyah.
        # We don't have any instances of this yet, but may in future if
        # we have more than one type of solver active.  For example, we
        # can't plot temperature when using the 2-variable method of
        # characteristics but we might be able to if someone writes a
        # 3-variable (non-homentropic) solver.
        solver = self.settings_dict["solver"]
        if solver not in curve_props["solver"]:
            err = ('> Came across an invalid plot type in "' + file_name + '".\n'
                   '> The plot type was "' + prop + '", to be plotted from\n'
                   '> file "' + self.runfile_name + '".\n'
                   '> Unfortunately the solver used to generate that\n'
                   '> binary file was "' + solver + '", which cannot produce\n'
                   '> this plot type.  The following solver(s) can\n'
                   '> produce it:\n'
                   + gen.FormatOnLines(curve_props["solver"]) +
                   '\n> Please edit the file to remove the curve or\n'
                   '> rerun the file with a different solver.'
                   )
            gen.WriteError(7042, err, self.log)
            gen.ErrorOnLine(line_number, line_text, self.log, False)
            return(None)
        if curve_type not in curve_props["curve_types"]:
            # Build a list of properties that are suitable for this
            # curve type for the error message.
            usable = []
            for key in self.plottables:
                if curve_type in self.properties[key.lower()]["curve_types"]:
                    usable.append(key)

            err = ('> Came across an invalid plot type in "' + file_name + '".\n'
                   '> The plot type was "' + prop + '", to be plotted\n'
                   '> on a ' + curve_type + ' plot.\n'
                   '> Unfortunately that plot type can only be\n'
                   '> plotted on the following curve types:\n'
                     + gen.FormatOnLines(curve_props["curve_types"]) + '\n'
                   '> The only plot types that can be plotted on\n'

                   '> '+ curve_type + ' plots are:\n'
                     + gen.FormatOnLines(usable) + '\n'
                   '> Please edit the file to adjust or remove\n'
                   '> the entry.'
                   )
            gen.WriteError(7043, err, self.log)
            gen.ErrorOnLine(line_number, line_text, self.log, False)
            return(None)
        # If we get to here then data for this curve type is in this file.
        return(curve_props["transient"])


    def _CheckAt(self, where, numbered, file_name, line_number, line_text):
        '''Take a property to plot that contains an '@' symbol, such as
        "westbound@1200".  In a profile plot these would be 'plot a profile
        curve in the route named "westbound" (or a tunnel named "westbound")
        at time 1200 seconds'.  In a transient plot these would be 'plot a
        transient trace in the route named "westbound" at distance 1200 m.'
        Check if it is syntactically valid and return an error message if
        it is not.

        Parameters:
            self            class           Everything in the class.
            where           str             A string defining where to plot
            numbered        []              A list of acceptable entries at
                                            the start of 'where', such as "train"
                                            and "fan" that require numbers.
            file_name       str             The name of the file being processed
                                            when this routine was called.  Used in
                                            error messages.  Not the name of the
                                            .bin file being plotted from.
            line_number     int             The line number being processed.  Used
                                            in error messages.
            line_text       str             The text of the line being processed.
                                            Used in error messages.

        Returns:
            first_word      str             The name of a route, name of
                                            a tunnel, name of a fan or a
                                            word like "train".
            thing_number    int or str      A train number or a string for
                                            un-numbered items like fans.
            dist_or_time    float           A distance along a route, distance
                                            relative to the down end of a
                                            train or a time.

        Errors:
            Aborts with 7061 if the location starts with an "@".
            Aborts with 7062 if the location ends with an "@".
            Aborts with 7063 if the location contained more than one "@".
            Aborts with 7064 if distance/time after the @ was not a number.
            Aborts with 7065 if the first part of the entity was not in
            the list of allowable words.
            Aborts with 7066 if the first part of the entity did not have
            anything after it, i.e. it was just "route" or "train".
            Aborts with 7067 if the entity was a train and the train was
            train number zero (this is allowed in SES but not allowed in
            Hobyah).
            Aborts with 7068 if the first part of the entity did not have
            a number after it when it should have.
        Most of these errors don't have test files because they are trapped
        by Hobyah.py before we can trigger them here.  They only exist so
        that people calling these routines directly get a decent error
        message.

        '''

        if where[0] == "@":
            err = ('> Tried to plot a curve in "' + file_name + '",\n'
                   '> but found that the location identifier "' + where + '"\n'
                   '> started with the symbol "@", meaning that the entity\n'
                   '> to plot at (tunnel, route, train etc.) was not given.\n'
                   '> Please edit the file to correct it.'
                   )
            gen.WriteError(7061, err, self.log)
            gen.ErrorOnLine(line_number, line_text, self.log, False)
            return(None)
        elif where[-1] == "@":
            err = ('> Tried to plot a curve in "' + file_name + '",\n'
                   '> but found that the location identifier "' + where + '"\n'
                   '> ended with the symbol "@", meaning that the second\n'
                   '> part of the identifier (distance along an entity or\n'
                   '> time to plot at) was not given.\n'
                   '> Please edit the file to correct it.'
                   )
            gen.WriteError(7062, err, self.log)
            gen.ErrorOnLine(line_number, line_text, self.log, False)
            return(None)

        parts = where.split(sep = "@")
        parts_low = where.lower().split(sep = "@")
        if len(parts) >= 3:
            # There was more than one instance of "@" in the word.
            err = ('> Tried to plot a curve in "' + file_name + '",\n'
                   '> but found that the location identifier "' + where + '"\n'
                   '> contained more than one "@" symbol.\n'
                   '> Please edit the file to correct it.'
                   )
            gen.WriteError(7063, err, self.log)
            gen.ErrorOnLine(line_number, line_text, self.log, False)
            return(None)
        else:
            (thing, dist_text) = parts_low

        # If we get to here, we look for a real number after the @ to set a
        # distance along a route or tunnel, a time, or a distance offset
        # from the down end of a train.
        try:
            dist_or_time = float(dist_text)
        except ValueError:
            # The text after the @ was not a number.
            err = ('> Tried to plot a curve in "' + file_name + '",\n'
                   '> but found that second part of the location\n'
                   '> identifier "' + where + '" was not a number,\n'
                   '> it was "' + parts[1] + '" instead.\n'
                   '> Please edit the file to correct it.'
                   )
            gen.WriteError(7064, err, self.log)
            gen.ErrorOnLine(line_number, line_text, self.log, False)
            return(None)

        # If we get to here everything is OK, we have two parts and the
        # second part is a number.

        # Now check if the character at start of the first part of the
        # location are a word in the list of allowed words.
        first_word = parts_low[0]


        # Build a list of all the things that have names.
        named_things = list(self.routes_dict.keys())             \
                       + list(self.tunnels_dict.keys())          \
                       + list(self.tunnelfans_dict.keys())       \
                       + list(self.Rs_bf_bin.columns)

        # Now check if the character at start of the first part of the
        # location are a word that needs a number after it (e.g. "train12").
        # We check each entry in the list of allowed words.  We make a default
        # entry for use in the next check if no allowed word is found.
        if first_word in named_things:
            # The entity has a unique name and does not need a number
            # (things like trains do need numbers).
            first_rest = 'not needed'
            thing_number = "no number for an un-numbered entity"

        for candidate in numbered:
            if first_word[:len(candidate)] == candidate:
                # We have a match.  Set the first word so that we pass
                # the next test.
                first_word = candidate
                first_rest = parts_low[0][len(first_word):]
                break

        try:
            # Check if we found a match in the numbered entries, the
            # routes or the tunnels and fault if we did not.
            first_rest
        except NameError:
            names = numbered + named_things
            names.sort()
            err = ('> Tried to plot a curve in "' + file_name + '",\n'
                   '> but found that first part of the location\n'
                   '> identifier "' + where + '" was not an allowed\n'
                   '> word, it was "' + first_word
                      + '".  The only words allowed\n'
                   '> are:\n'
                     + gen.FormatOnLines(names) + "\n"
                   '> Please edit the file to correct it.  N.B. If\n'
                   '> you have change the name of something, you\n'
                   '> may need to rerun the calculation.'
                   )
            gen.WriteError(7065, err, self.log)
            gen.ErrorOnLine(line_number, line_text, self.log, False)
            return(None)

        if first_word in numbered:
            # Check for a valid number after the first word and before
            # the '@'.
            if first_rest == '':
                # There was nothing before the "@" except an acceptable
                # word. There was not a number after the acceptable word,
                # i.e. it was something like "train@1200" instead of
                # "train12@1200".
                err = ('> Tried to plot a curve in "' + file_name + '",\n'
                       '> but found that first part of the location\n'
                       '> identifier "' + where + '" only contained the\n'
                       '> word "' + thing + '" without a '
                         + thing.lower() + ' number before\n'
                       '> the "@".  Please edit the file to add a\n'
                       '> ' + thing.lower() + ' number.'
                       )
                gen.WriteError(7066, err, self.log)
                gen.ErrorOnLine(line_number, line_text, self.log, False)
                return(None)
            elif first_rest.isdecimal():
                # Everything between the first word and the "@" was a decimal.
                # Turn it into an integer.
                thing_number = int(first_rest)
                # Check if this is train zero and complain if it is.
                if first_word == "train" and thing_number == 0:
                    # Someone tried to plot at train zero.  Train zero can
                    # occur in SES so it isn't trapped in Hobyah.py (train
                    # zero is actually train 100 - long story).  We trap
                    # train zero in Hobyah here.
                    err = ('> Tried to plot a curve in "' + file_name + '",\n'
                           '> at train 0.  Hobyah runs (unlike SES runs) do\n'
                           '> not have a train zero.  Please edit the file\n'
                           '> and change the entry to be a train number of\n'
                           '> one or above.'
                           )
                    gen.WriteError(7067, err, self.log)
                    gen.ErrorOnLine(line_number, line_text, self.log, False)
                    return(None)
            else:
                # There was something after the word but it was not an integer.
                err = ('> Tried to plot a curve in "' + file_name + '",\n'
                       '> but found that first part of the location\n'
                       '> identifier "' + where + '" did not have a\n'
                       '> ' + first_word.lower()
                          + ' number after it, it had "'
                          + parts[0][len(first_word):] + '"\n'
                       '> instead.  Please edit the file and change\n'
                       '> it to an integer ' + first_word + ' number.'
                       )
                gen.WriteError(7068, err, self.log)
                gen.ErrorOnLine(line_number, line_text, self.log, False)
                return(None)
        return(first_word, thing_number, dist_or_time)


    def TransientAt(self, where, prop, curve_type, units, file_name,
                    line_number, line_text):
        '''Take the location of a property to plot against time, something
        like "westbound@1200".  This means "plot something 1200 m (or feet)
        along the route called 'westbound'".
        Check if the location is syntactically valid and return an error
        message if it is not.  If it is valid, check if this location exists
        in the run and return error messages if it does not.
        If everything is OK otherwise, figure out the correct key to use
        to get the transient data out of the relevant pandas dataframe in
        the binary file and return the key.
        This routine assumes that the property has already been checked
        by a call to self.CheckProperty.  If a dud property is provided
        it will cause an exception.

        Parameters:
            self            class           Everything in the class.
            where           str             A string defining where to plot
            prop            str             A string naming the property to plot.
            curve_type      str             A string describing what kind of
                                            curve this is, e.g. transient, profile
                                            etc.  Used in error messages.
            units           str             The system of units the input is in.
                                            This could be "si" or "us".
            file_name       str             The name of the file being processed
                                            when this routine was called.  Used in
                                            error messages.  Not the name of the
                                            .hbn file being plotted from.
            line_number     int             The line number being processed.  Used
                                            in error messages.
            line_text       str             The text of the line being processed.
                                            Used in error messages.

        Returns:
            array_index     int             The segment index
            db_key          str             The name of a pandas dataframe

        Errors:
            Aborts with 7081 if the user tried to plot "pdiff" in a
            tunnel or a route.
            Aborts with 7082 if the user tried to plot a fan or damper
            property in a tunnel or a route.
            Aborts with 7083 if the name of a tunnel was given for the
            location and the distance was not in the tunnel.
            Aborts with 7084 if the user tried to plot the wrong type
            of property at a damper (type 2 dampers can't plot area or
            pressure loss factor).
            Aborts with 7085 if the user tried to plot the wrong type
            of property at a fan.
            Aborts with 7086 if the code was not set to handle a new
            type of entity.  This can only happen when the programmer
            fouls up.
            Aborts with 7087 if the user tried to plot the wrong type
            of property at a train, e.g. fan total pressure.
        '''
        # There are several types of location, as follows:
        #  * a string with "@" in it for chainage in a named route ("westbound@150").
        #    This is turned into the index of a segment that contains the
        #    location and the pandas database column of the gridpoint in that
        #    segment that is nearest the desired location, e.g. 35@132.3333333333.
        #  * a string with "@" in it for distance along a tunnel ("mainline1@125").
        #    This is also turned into the index of a segment and a pandas
        #    database column of the gridpoint nearest it.


        # Figure out what key to use from the plot types properties and
        # put it into "keytype".
        prop_low = prop.lower()
        these_props = self.properties[prop_low]
        keytype = these_props["place"]

        if "@" in where:
            # Check the general structure of the location.  This returns
            # the name of the entity in lower case ("route", "train") and
            # the entity number as an integer.  Alternatively there is the
            # name of the route or tunnel without an entity number.  Also
            # returns distance as a float.
            #
            numbered = ["train", ]
            result = self._CheckAt(where, numbered, file_name,
                                        line_number, line_text)
            if result is None:
                return(None)
            else:
                # Get the entity, the entity number (if any) and the
                # distance along it.
                (entity, entity_no, chainage) = result

            # Check for plotting properties in tunnels or routes that
            # can only be plotted at fans or dampers.  We do the
            # property "pdiff" first because we have a detailed error
            # message for it (7081) then do the others (7082) before
            # checking for plots in tunnels and routes.
            if prop_low in ("pdiff", "-pdiff"):
                # This ought to be a pressure drop across a fan or a damper.
                # Check if it is not.
                if entity not in self.p_diff_dict:
                    err = ('> Tried to plot a curve in "' + file_name + '",\n'
                           '> at a point in the tunnel but the property\n'
                           '> being plotted (pdiff) can only be plotted\n'
                           '> at fans and dampers'
                          )
                    if self.p_diff_dict == {}:
                        err = (err + ' but there were no fans\n'
                               '> or dampers in the calculation.'
                              )
                    elif self.timedlosses_dict == {}:
                        plotlocs = tuple(self.tunnelfans_dict.keys())
                        err = err + '.  There were no dampers\n'   \
                           '> in the calculation but "pdiff" may be plotted\n' \
                           '> at the following fan(s):\n'  \
                            + gen.FormatOnLines(plotlocs)
                    elif self.tunnelfans_dict == {}:
                        plotlocs = tuple(self.timedlosses_dict.keys())
                        err = err + '.  There were no fans in\n'   \
                           '> the calculation but "pdiff" may be plotted\n' \
                           '> at the following damper(s):\n'  \
                            + gen.FormatOnLines(plotlocs)
                    else:
                        plotlocs = list(self.timedlosses_dict.keys()) +  \
                                   list(self.tunnelfans_dict.keys())
                        err = err + '.  "Pdiff" may be plotted\n' \
                           '> at the following fans/dampers:\n'  \
                            + gen.FormatOnLines(plotlocs)
                    gen.WriteError(7081, err, self.log)
                    gen.ErrorOnLine(line_number, line_text, self.log, False)
                    return(None)
                elif entity in self.tunnelfans_dict:
                    result = (entity, "fan")
                else:
                    result = (entity, "damper")
            elif (entity in self.routes_dict or entity in self.tunnels_dict) \
                  and prop_low in self.damfantrain_props:
                # We have a mismatch, complain.
                if entity in self.tunnels_dict:
                    text1 = 'tunnel ' + gen.OptQuotes(entity)
                else:
                    text1 = 'route ' + gen.OptQuotes(entity)
                if prop_low in self.damper_props and prop_low in self.fan_props:
                    # This is currently not active, as the only property
                    # that can be plotted at both fans and dampers is
                    # "pdiff", which is dealt with in error 7081 above.
                    text2 = 'fans & dampers.'
                elif prop_low in self.damper_props:
                    text2 = 'dampers.'
                elif prop_low in self.train1_props:
                    text2 = 'trains.'
                else:
                    # It must be a fan property.  I don't think we can
                    # get here (error 7043 gets raised first), but that
                    # may change in future.
                    text2 = 'fans.'
                err = ('> Tried to plot a curve in "' + file_name + '",\n'
                       '> at a point in ' + text1 + ' but the property\n'
                       '> being plotted (' + prop + ') can only be plotted\n'
                       '> at ' + text2 + '  Please edit the file to\n'
                       '> correct the location or remove the curve\n'
                       '> definition.'
                      )
                gen.WriteError(7082, err, self.log)
                gen.ErrorOnLine(line_number, line_text, self.log, False)
                return(None)
            elif entity in self.routes_dict:
                # Make a note that this entity is a route.
                entity_type = "route"
                # Get the details of the route.
                route_defn = self.routes_dict[entity]
                tunnel_chs = route_defn["tunnel_chs"]
                up_ch = tunnel_chs[0]
                down_ch = tunnel_chs[-1]

                if chainage < up_ch or chainage > down_ch:
                    # It is in the open air.  We don't need to have
                    # a check of the extents of the route, we just use
                    # the figure for the open air.
                    result = "open_air"
                else:
                    # The location we want is underground in the route.
                    # Note that if a chainage lies exactly at a point
                    # at which we have more than one gridpoint (a node,
                    # join, fan, damper or change of sectype) a fault
                    # will be raised stating that the program can't
                    # figure out which gridpoint to use and suggest
                    # that the user moves the plot point slightly to
                    # one side.

                    # Figure out which tunnel it is and what distance
                    # in the tunnel is equivalent to the chainage.
                    tunnel_chs = route_defn["tunnel_chs"]
                    for t_index, tun_down_ch in enumerate(tunnel_chs[1:]):
                        tun_up_ch = tunnel_chs[t_index]
                        if (tun_up_ch <= chainage <= tun_down_ch or
                            tun_down_ch <= chainage <= tun_up_ch):
                            # We have found the index of the tunnel
                            # that this chainage is in.  We break,
                            # leaving the values of t_index, tun_up_ch
                            # and tun_down_ch as they are.  Note that
                            # if the chainage is exactly at a boundary,
                            # the value farther up in the route is used,
                            # unless there are two or more gridpoints
                            # at that chainage (area change, fan etc)
                            tunnel_name = route_defn["signed_names"][t_index]
                            break
                        # Get the location of where we want as a distance
                        # along the tunnel instead of a chainage in the route.
                        # We need to account for tunnels that are in the route
                        # backwards.

                    if tunnel_name[0] == "-":
                        # The tunnel was backwards in the route.
                        start_dist = self.tunnels_dict[tunnel_name[1:]]["fwd"][0]
                        end_dist = self.tunnels_dict[tunnel_name[1:]]["back"][0]
                        mod_name = tunnel_name[1:]
                    else:
                        start_dist = self.tunnels_dict[tunnel_name]["back"][0]
                        end_dist = self.tunnels_dict[tunnel_name]["fwd"][0]
                        mod_name = tunnel_name
                    if start_dist > end_dist:
                        # The user set a higher distance at the back
                        # end of the tunnel.  This is unusual but is not
                        # forbidden.
                        tunnel_dist = start_dist - chainage + tun_up_ch
                    else:
                        tunnel_dist = start_dist + chainage - tun_up_ch
                    # Figure out which segment it is in, complain if
                    # the chainage is ambiguous, and return the distance
                    # along the segment that most closely matches the
                    # desired chainage.  We pass a False value so that
                    # FindSegment will complain if the plot is at a
                    # segment end that is a boundary.
                    result = self.FindSegment(mod_name, tunnel_dist, False,
                                              entity, units, file_name,
                                              line_number, line_text)
                    if result is None:
                        # It looks like the user specified a chainage
                        # that exactly matched the location of something
                        # problematic, like an area change or a junction.
                        # The problem is that the program can't figure
                        # out which segment to take the data from.  An
                        # error message has already been issued.
                        return(None)
                    # All is well, and the result of this call is
                    # a tuple of a segment index and the distance
                    # along the segment to use as the key.  We don't
                    # need to break these out, we just pass on the
                    # result to the calling array
                    # (array_index, db_key) = result
            elif entity in self.tunnels_dict:
                # Make a note that this entity is a tunnel.
                entity_type = "tunnel"
                # Get the details of the tunnel.
                tunnel_defn = self.tunnels_dict[entity]
                back_dist = tunnel_defn["back"][0]
                fwd_dist = tunnel_defn["fwd"][0]
                # There is nothing to stop a user having a higher distance
                # at the back end than at the forward end.  It's a bit
                # weird but it's not forbidden anywhere.
                low_end = min(back_dist, fwd_dist)
                high_end = max(back_dist, fwd_dist)
                # Note that the 'chainage' in the test below is actually
                # a distance along the tunnel.
                if low_end <= chainage <= high_end:
                    # The location we want lies in this tunnel.  We
                    # send a True value so that if the location
                    # lies at the end of the tunnel it is accepted.
                    result = self.FindSegment(entity, chainage, True,
                                              "discard", units, file_name,
                                              line_number, line_text)
                    if result is None:
                        # It looks like the user specified a chainage
                        # that exactly matched the location of something
                        # problematic, like an area change or a junction.
                        # The problem is that the program can't figure
                        # out which segment to take the data from.  An
                        # error message has already been issued.
                        return(None)
                    # All is well, and the result of this call is
                    # a tuple of a segment index and the distance
                    # along the segment to use as the key.  We don't
                    # need to break these out, we just pass on the
                    # result to the calling array.
                    # (array_index, db_key) = result
                else:
                    route_text = 'tunnel "' + entity + '"'
                    if units == "si":
                        back_text = str(round(back_dist,3))
                        fwd_text = str(round(fwd_dist, 3))
                        dist_text = str(round(chainage, 3))
                    else:
                        back_text = str(round(back_dist/0.3048, 3))
                        fwd_text = str(round(fwd_dist/0.3048, 3))
                        dist_text = str(round(chainage/0.3048, 3))
                    err = ('> Tried to plot a curve in "' + file_name + '",\n'
                           '> at distance ' + dist_text
                             + ' along the tunnel named\n'
                           '> "' + entity + '".\n'
                           '> That tunnel starts at ' + back_text
                             + ' and ends\n'
                           '> at ' + fwd_text + '.  Please edit the file to\n'
                           '> correct the location or remove the curve\n'
                           '> definition.'
                           )
                    gen.WriteError(7083, err, self.log)
                    gen.ErrorOnLine(line_number, line_text, self.log, False)
                    return(None)
            elif entity in self.timedlosses_dict.keys():
                # This is a damper, either type 1 or type 2.  Check if the
                # property can be plotted at this type of damper and complain
                # if it cannot.
                # Get the type of this damper ("damper1" or "damper2").
                d_props =  self.timedlosses_dict[entity]
                d_type = d_props[0]
                if d_type not in keytype:
                    # Get a list of the properties that can be plotted at
                    # this type of damper.
                    valid_props = []
                    for plot_type in self.plottables:
                        if d_type in self.properties[plot_type.lower()]["place"]:
                                valid_props.append(plot_type)
                    err = ('> Tried to plot a curve in "' + file_name + '",\n'
                           '> at a "' + d_type
                             + '" type damper, but the property\n'
                           '> being plotted (' + prop
                             + ') cannot be plotted at that\n'
                           '> type of damper.  The only properties that can\n'
                           '> be plotted at that type of damper are:\n'
                             + gen.FormatOnLines(valid_props) + '\n'
                           '> If you want to plot a property at one of the\n'
                           "> damper's two gridpoints, plot in the tunnel\n"
                           "> the damper is in; it's in tunnel "
                             + gen.OptQuotes(d_props[4]) + ' and\n'
                           '> the line defining the damper is:\n'
                           '>  ' + d_props[6]
                          )
                    gen.WriteError(7084, err, self.log)
                    gen.ErrorOnLine(line_number, line_text, self.log, False)
                    return(None)
                elif entity in self.areas_bin.columns:
                    # Get the transient data for the required property, we
                    # have all the data we need.
                    entity_type = "damper"
                    db_key = entity
                    array_index = "damper1"
                elif entity in self.Rs_bf_bin.columns:
                    # Get the transient data for the required property, we
                    # have all the data we need.
                    entity_type = "damper"
                    db_key = entity
                    array_index = "damper2"
                result = (db_key, array_index)
            elif entity in self.tunnelfans_dict.keys():
                # Make a note that this entity is a fan.
                entity_type = "fan"
                # Figure out if it type "fan1" or "fan2".  At the moment
                fan_props = self.tunnelfans_dict[entity]
                d_type = fan_props[7]
                if d_type not in keytype:
                    # Get a list of the properties that can be plotted at
                    # this type of fan.
                    valid_props = []
                    for plot_type in self.plottables:
                        type_places = self.properties[plot_type.lower()]["place"]
                        if type(type_places) in (str, tuple)   \
                           and d_type in type_places:
                                valid_props.append(plot_type)
                    err = ('> Tried to plot a curve in "' + file_name + '",\n'
                           '> at a "' + d_type
                             + '" type fan, but the property being\n'
                           '> plotted (' + prop
                             + ') cannot be plotted at that\n'
                           '> type of fan.  The only properties that can be\n'
                           '> be plotted are:\n'
                             + gen.FormatOnLines(valid_props) + '\n'
                           '> If you want to plot a property at one of the\n'
                           "> fan's two gridpoints, plot in the tunnel the\n"
                           "> fan is in; it's in tunnel "
                             + gen.OptQuotes(fan_props[12]) + ' and\n'
                           '> the line defining the fan is:\n'
                           '>  ' + fan_props[14]
                          )

                    gen.WriteError(7085, err, self.log)
                    gen.ErrorOnLine(line_number, line_text, self.log, False)
                    return(None)
                elif entity in self.areas_bin.columns:
                    # Get the transient data for the required property, we
                    # have all the data we need.
                    entity_type = "fan"
                    db_key = entity
                    array_index = "fan1"
                elif entity in self.Rs_bf_bin.columns:
                    # Get the transient data for the required property, we
                    # have all the data we need.
                    entity_type = "fan"
                    db_key = entity
                    array_index = "fan2"
                result = (db_key, array_index)
            elif entity == "train":
                # This is something plotted at a train.  We have a train
                # number.
                if keytype != "train":
                    # Get a list of the properties that can be plotted at
                    # trains.
                    valid_props = []
                    for plot_type in self.plottables:
                        type_places = self.properties[plot_type.lower()]["place"]
                        if type(type_places) in (str, tuple)   \
                           and "train" in type_places:
                                valid_props.append(plot_type)
                    err = ('> Tried to plot a curve in "' + file_name + '",\n'
                           '> at a train, but the property (' + prop + ') cannot\n'
                           '> be plotted at trains.\n'
                           '> The only properties that can be plotted at\n'
                           '> trains are:\n'
                          ) + gen.FormatOnLines(valid_props)
                    gen.WriteError(7087, err, self.log)
                    gen.ErrorOnLine(line_number, line_text, self.log, False)
                    return(None)
                elif prop in self.train1_props:
                    # It's a property intrinsic to a train, such as speed.
                    # Not a property in the tunnels as seen by a passing
                    # train.  There is no array index to worry about
                    # because there is only one 2D pandas array for each
                    # intrinsic train property.
                    db_key = entity_no
                    place = "train property"
                else:
                    # It's a property in a tunnel as seen by a passing
                    # train.  This is going to be fun to program in,
                    # I can tell.
                    print("Can't process properties seen by a passing "
                          "train yet.")
                    gen.OopsIDidItAgain(self.log, file_name)
                    return(None)
                result = (place, db_key)
            else:
                # We added a new location type to "numbered" without adding
                # an elif branch to handle it here.
                # Get a list of the names of new entity for the error
                # message.  We pop the ones we've already created elif
                # branches for.
                # numbered.remove("train")
                # numbered.remove("fan")

                err = ('> Tell the programmer that an extra elif clause\n'
                       '> needs to be added in Hobyahclass.TransientAt\n'
                       '> to handle plot locations of type "' + numbered[0] + '".'
                      )
                gen.WriteError(7086, err, self.log)
                gen.ErrorOnLine(line_number, line_text, self.log, False)
                gen.OopsIDidItAgain(self.log, file_name)
                return(None)

        return(result)


    def FindSegment(self, tunnel_name, distance, in_tunnel, route_name,
                    units, file_name, line_number, line_text):
        '''Take a tunnel name and a distance along the tunnel or a
        name and a chainage in the route.  Figure out what gridpoint
        is closest to the distance.  Return the index of the segment
        that contains the distance and the column chainage in that
        segment.
        If the distance is at an internal boundary (such as a change of
        area, a junction etc.) then raise an error message and tell the
        user to move the chainage half a metre up or down so that the
        program can figure out which side of the boundary is meant.
        If the chainage happens to coincide with a train end, return
        the conditions in the annulus.  Coinciding with a train end
        will happen only once in a blue moon but we need to state what
        the routine will do when it happens.

        Parameters:
            self            class           Everything in the class.
            tunnel_name     str             Name of a tunnel.
            distance        float           Distance along the tunnel to take
            in_tunnel       bool            True if the curve calling this
                                            routine was plotting in a tunnel,
                                            False if the curve was plotting
                                            in a route.
            route_name      str             Name of the route, if there was one.
                                            Used in error messages.
            units           str             The system of units the input is in.
                                            This could be "si" or "us".
            file_name       str             The name of the file being processed
                                            when this routine was called.  Used in
                                            error messages.  Not the name of the
                                            .hbn file being plotted from.
            line_number     int             The line number being processed.  Used
                                            in error messages.
            line_text       str             The text of the line being processed.
                                            Used in error messages.

        Returns:
            seg_index       int             The segment index.
            dist_to_use     float           The chainage of a gridpoint in the
                                            segment.

        Errors:
            Aborts with 7121 if location given was exactly the chainage of
            a gridpoint at which there could be two states (e.g. an area
            change, axial fan, damper, node or join).
        '''
        # Get a list of the indices of all the segments that are
        # in this tunnel.
        seg_indices = self.tuns2frames[tunnel_name]
        # Go through each segment and check the chainages.
        for index, seg_index in enumerate(seg_indices):
            # First turn the c
            # Check if the distance we want is in this segment.
            seg_dists = self.dists[seg_index]
            back_dist = seg_dists[0]
            fwd_dist =  seg_dists[-1]
            # The 'if' statement below has four parts for two reasons.
            # First, tunnels can be made with the forward end at a lower
            # chainage than the back end.  Second, floating point
            # arithmetic might push a plot location or a portal location
            # a fraction to the wrong side, so we need to have two
            # math.isclose() tests with absolute values of tolerance
            # to catch the case where our plot point should be exactly
            # at one end and floating point shenanigans causes the "<="
            # to be failed.
            if ((back_dist <= distance <= fwd_dist) or
                (fwd_dist <= distance <= back_dist) or
                math.isclose(back_dist, distance, abs_tol = 1e-9) or
                math.isclose(fwd_dist, distance, abs_tol = 1e-9)):
                # The plot location is in this segment.  Now check if it
                # is at the start or at the end of the segment.
                if math.isclose(distance, fwd_dist):
                    if in_tunnel and index == len(seg_indices) - 1:
                        # The plot is at the forward end of a tunnel.
                        # The user has asked to plot in a particular
                        # tunnel, not in a particular route.  We accept
                        # the distance at the tunnel end.
                        dud = False
                    else:
                        # The user has asked to plot in a route.  Check
                        # if the forward end of this segment is a
                        # boundary with more than one gridpoint at it.
                        #
                        fwd_conn = self.segments_consts[seg_index][12]
                        dud, descrip = self._BuildErrText(fwd_conn)
                elif math.isclose(distance, back_dist):
                    # Check if there could be two values at this location,
                    # one in this segment and one in an adjacent segment.
                    if in_tunnel and index == 0:
                        # The user has asked to plot in a particular
                        # tunnel, not in a particular route.  We accept
                        # the distance at the back end of the tunnel.
                        dud = False
                    else:
                        # The user has asked to plot in a route.  Check
                        # if this location could have two values at it,
                        # one on either side of a node or area change.
                        back_conn = self.segments_consts[seg_index][10]
                        dud, descrip = self._BuildErrText(back_conn)
                else:
                    # The plot location is in the middle of this segment so
                    # it must be valid.
                    dud = False

                if dud:
                    # Raise an error message telling the user that their
                    # plot point is in an ambiguous location and they need
                    # to move it.
                    if units == "si":
                        dist_text = "(say 0.1 m) to\n"
                    else:
                        dist_text = "(say 0.1 ft) to\n"
                    # Figure out if we are plotting in a tunnel or a route
                    # and adjust the error message to match.
                    if in_tunnel:
                        text1 = ('> at distance ' + gen.FloatText(distance)
                                   + ' in tunnel "' + tunnel_name + '".\n')
                    else:
                        # Get the chainage in the route from the distance.
                        route_dict = self.routes_dict[route_name]
                        index = route_dict["tunnel_names"].index(tunnel_name)
                        mult, offset = route_dict["route2tun"][index]
                        ch = (distance - offset) / mult
                        text1 = ('> at chainage ' + gen.FloatText(ch)
                                   + ' in route "' + route_name + '".\n')
                    err = ('> Tried to plot a curve in "' + file_name
                             + '",\n'
                             + text1 +
                           '> Unfortunately that location is at'
                             + descrip + '\n'
                           '> Please edit the file to move the plot\n'
                           '> point a short distance ' + dist_text +
                           '> make it clearer which side you want.'
                           )
                    gen.WriteError(7121, err, self.log)
                    gen.ErrorOnLine(line_number, line_text, self.log, False)
                    return(None)
                else:
                    # Get the distance that is closest to the one we want.
                    differences = [abs(value - distance) for value in seg_dists]
                    low_index = np.array(differences).argmin()
                    dist_to_use = seg_dists[low_index]
                    # We've found the correct location, break out of the loop.
                    break
        return(seg_index, dist_to_use)


    def _BuildErrText(self, connection):
        '''Take a letter that represents what happens at the end of a
        segment and decide if it is a boundary (has one or more gridpoints
        at it).  If it is a boundary return a True Boolean and a
        description that can be used in an error message.  If it is
        not a boundary, return False and a dummy string.
        Boundaries may be at nodes, joins, tunnel fans, dampers and
        changes of sectype.


        Parameters:
            self            class           Everything in the class.
            connection      str             A one-character string taken
                                            from self.segments_sources.
                                            It identifies what is at the
                                            end of a segment.
        Returns:
            dud             bool            True if the connection is a
                                            boundary, false otherwise.
            descrip         str             Text describing the boundary
                                            suitable for including in
                                            error messages.
        '''
        if connection == "n":
            dud = True
            descrip = (" a node\n"
                      "> (or a join in a tunnel) where two or more\n"
                      "> segments meet.  It is unclear which side\n"
                      "> of the node you want to plot at.")
        elif connection == "f":
            dud = True
            descrip = (" a fan\n"
                      "> in the tunnel.  It is unclear which side\n"
                      "> of the fan you want to plot at.")
        elif connection == "c":
            dud = True
            descrip = (" a change\n"
                      "> of sectype in the tunnel.  It is unclear\n"
                      "> which side of the change you want to plot\n"
                      "> at.")
        elif connection == "d":
            dud = True
            descrip = (" a damper\n"
                      "> in the tunnel.  It is unclear which side\n"
                      "> of the damper you want to plot at.")
        elif connection == "p":
            dud = False
            descrip = "Unused description(I hope)"
        elif connection == "v":
            dud = False
            descrip = "Unused description(I hope)"
        else:
            # The connection at the forward end does not have two
            # values at it.  At the moment this only happens at
            # portals ("p" for a pressure portal, "v" for fixed
            # velocity and fixed volume flow portals).  We make
            # an error message
            #
            print("connection", connection)
            descrip = 'Need to add more entries in _BuildErrText\n' \
                      'to handle "' + connection + '" connections.'
            dud = False
        return(dud, descrip)


    def FanAt(self, where, prop, curve_type, units, file_name,
              line_number, line_text):
        '''Take the specification of a fan property to plot on a Q-P_tot
        diagram like "CTA-S@105".  This means 'plot a property of the fan
        called "CTA-S" at 105 seconds'.
        Check if a fan of that name exists in the run and return an error
        message if it does not.
        If everything is OK otherwise, return the data of the fan - the
        details of its source fancurve and which segments in the file hold
        its properties.

        Parameters:
            self            class           Everything in the class.
            where           str             A string defining where to plot
            prop            str             A string naming the property to plot.
            curve_type      str             A string describing what kind of
                                            curve this is, e.g. transient, profile
                                            etc.  Used in error messages.
            units           str             The system of units the input is in.
                                            This could be "si" or "us".
            file_name       str             The name of the file being processed
                                            when this routine was called.  Used in
                                            error messages.  Not the name of the
                                            .hbn file being plotted from.
            line_number     int             The line number being processed.  Used
                                            in error messages.
            line_text       str             The text of the line being processed.
                                            Used in error messages.

        Returns:
            fan_name        str             A key to tunnelfans_dict that returns
                                            the fan's properties and the segments
                                            it is in.
            transient       Bool            True if this fan property is
                                            transient, False if it is not.
            time            float           The time the user wanted to plot at.
            result_time     float           The time to actually plot at.

        Errors:
            Aborts with 7141 if the name of the fan is not in this run.
            Aborts with 7142 if the user wants to plot fan static pressure
            or system static pressure but hasn't set a fan diameter.
        '''
        # Figure out what key to use from the plot types properties and
        # put it into "keytype".
        these_props = self.properties[prop.lower()]

        # Check the fan name and time.
        #
        numbered = []
        result = self._CheckAt(where, numbered, file_name,
                                    line_number, line_text)
        if result is None:
            return(None)
        else:
            # Get the entity, the entity number (not used here) and the
            # time the user wants to plot at.
            (fan_name, discard, time) = result

        if fan_name not in self.tunnelfans_dict:
            # "fan_name" is not the name of a fan, it is the name of
            # something else, like a damper.
            if file_name == self.runfile_name:
                # We are looking for a fan in the file we are plotting.
                err = ('> Tried to plot a curve in "' + file_name + '",\n'
                       '> with data of a fan named "' + fan_name
                         + '" in this file.\n')
            else:
                # We are looking for a fan in a different run.
                err = ('> Tried to plot a curve in "' + file_name + '",\n'
                       '> with data of a fan named "' + fan_name
                         + '" in Hobyah\n'
                       '> run "' + self.runfile_name + '".\n')

            if self.tunnelfans_dict == {}:
                err = err + '> Unfortunately there are no fans in the file.\n'
            else:
                fan_names = list(self.tunnelfans_dict.keys())
                err = (err + '> Unfortunately there is no fan with that name\n'
                             '> in the file.  For what it is worth these are\n'
                             '> the valid fan names:\n'
                              + gen.FormatOnLines(fan_names))
            gen.WriteError(7141, err, self.log)
            gen.ErrorOnLine(line_number, line_text, self.log, False)
            return(None)
        else:
            # The fan exists.  Get the data we need.
            transient = these_props["transient"]
            if transient:
                result_time = self._GetPlotTime(time)
            else:
                # This is a fixed property plot, like the input data for
                # the fan characteristic rather than the fan characteristic
                # when running at a given speed at a specific time.  The
                # routine calling this ought not to use "result_time", so
                # return something that will cause a crash.
                result_time = None
        # Now check if the property is a static pressure characteristic
        # or static pressure system resistance) and fault if the fan
        # diameter was not given.
        if "cursed" in prop:
            fan_char_name, fan_char_dict = self._GetFanChar(fan_name)
            if "diameter" not in fan_char_dict.keys():
                block_start = fan_char_dict["block_index"]
                err = ('> Tried to plot a curve in "' + file_name + '",\n'
                       '> giving the static pressure properties of fan\n'
                       '> "' + fan_name
                         + '", but the fan characteristic definition\n'
                       "> didn't include the fan diameter.\n"
                       "> Please add a diameter keyword so that the fan's\n"
                       '> dynamic pressure can be calculated, then\n'
                       '> subtracted from the fan total pressure.\n'
                       "> The fan's"' characteristic is "'
                         + fan_char_name + '" and is\n'
                       '> defined on the ' + gen.Enth(block_start[0])
                         + ' line of the Hobyah input\n'
                       '> file named "' + self.runfile_name + '".\n'
                       '> Are you sure you want to plot fan static\n'
                       '> pressure and not fan total pressure?  Fan\n'
                       '> static pressure sucks.'
                       )
                gen.WriteError(7142, err, self.log)
                gen.ErrorOnLine(line_number, line_text, self.log, False,
                                True, "Problematic")
                return(None)

        return(transient, fan_name, time, result_time)


    def _GetFanChar(self, fan_name):
        '''Take the name of a fan and return the details of the fan's
        characteristic: the name of the characteristic and the
        dictionary holding its data.
        '''
        fan_char_name = self.tunnelfans_dict[fan_name][8]
        fan_char_dict = self.fanchars_dict[fan_char_name]
        return(fan_char_name, fan_char_dict)


    def GetFanDataTransient(self, fan_name, prop, orig_where, where,
                            units, line_text, result_time, time):
        '''Take the definition of a transient fan curve and return the
        data needed to plot it and suitable QA data for the curve file.

        Parameters:
            self            class           Everything in the class.
            fan_name        str             A string that is a valid fan name.
                                            It should have already been checked
                                            by a call to FanAt, so if it is not
                                            a valid name it will raise an
                                            exception.
            prop            str             A string naming the property to plot.
            orig_where      str             A string defining where to plot in
                                            the form that was given in the input
                                            file, e.g. CTA-S@105.2.
            where           str             A string defining where to plot in
                                            a form that has a valid time for this
                                            file, e.g. CTA-S@104.0.
            units           str             The system of units the input is in.
                                            This could be "si" or "us".
            line_text       str             The text of the line being processed.
                                            Used in error messages.
            time            float           The time the user wanted to plot at.
            result_time     float           The time to actually plot at.

        Returns:
            QAlist          []              A list of lines tracing the data.
            fan_flows       []              A list of X-values (volume flows).
            x_USconv        str             "seconds", signifying that time in
                                            US units is the same as in SI units.
            fan_Ps          []              A list of Y-values (gauge total
                                            pressure or static pressure).
            y_USconv        float           The key to use in UScustomary.py to
                                            convert the Y values from SI to US
                                            units.
            autolabel       str             A line of text that can be used as
                                            a graph key entry.
            col_headers     str             A string of text with suitable
                                            headers to appear above each column
                                            if someone loads a curve data file
                                            into a spreadsheet.
        '''
        fan_details = self.tunnelfans_dict[fan_name]
        (times, speeds, fan_name,
         fan_type, char_name, seg1, seg2) = fan_details[4:11]
        these_props = self.properties[prop.lower()]

        speed = np.interp(result_time, times, speeds)
        if prop in ("system", "dutypoint", "system-cursed", "duty-cursed"):
            # We want the pressure rise across the fan expressed
            # as a system characteristic on the flow-total pressure
            # plane or as one point.  If the property does not end
            # with "cursed" it's wanted on the flow-total pressure
            # plane.  If it does end with "cursed" it is on the
            # flow-static pressure plane.

            # Get the fan total pressure.
            P_tot = self.p_diff_dict[fan_name].loc[result_time]
            # We want the volume flow at inlet side of the fan (not
            # upwind of the fan).  This is so that we get the same
            # location even if the fan is being pushed into the reverse
            # flow region of its characteristic by a train or other fan.
            # If the fan is not rotating we will use the volume flow
            # in the first segment.
            if prop == "system":
                descrip_text = "System curve for"
            elif prop == "dutypoint":
                descrip_text = "Duty point of"
            elif prop == "system-cursed":
                descrip_text = "P_s system curve for"
            else:
                # This is the cursed system resistance (static pressure)
                descrip_text = "P_s duty point of"
            if math.isclose(speed, 0.0):
                # The fan is off, so has no system characteristic.  Other
                # prime movers may be moving air through this segment but
                # they have nothing to do with this fan.  We put in two
                # points so that gnuplot doesn't complain about not
                # having anything to plot.
                fan_flows = [0.0, 0.01]
                fan_P_tots = [0.0, 0.0]
                direct_text = "(off)"
            else:
                if speed > 0.0:
                    # We want the volume flow at the right-hand end of
                    # the first segment (at the fan inlet).
                    fan_flow = self.q_bin[seg1].loc[result_time].iloc[-1]
                    direct_text = "(forwards)"
                else:
                    # We want the volume flow at the left-hand end of
                    # the second segment (also at the fan inlet).
                    fan_flow = -self.q_bin[seg2].loc[result_time].iloc[0]
                    # The fan is running in reverse so we switch the sign
                    # of the pressure (don't want to see upside-down
                    # fan characteristics).
                    P_tot = -P_tot
                    direct_text = "(reverse)"

                if "cursed" in prop:
                    # We need to figure out the dynamic pressure so we
                    # can subtract it from the total pressure.  We use
                    # the dynamic pressure at the fan outlet, to be
                    # consistent with ISO 8501's nomenclature.
                    if speed > 0.0:
                        # Outlet side is the first gridpoint in the second
                        # segment
                        alt_flow = -self.q_bin[seg2].loc[result_time].iloc[0]
                        dens = self.dens_bin[seg2].loc[result_time].iloc[0]
                    else:
                        # Outlet side is the last gridpoint in the first
                        # segment
                        alt_flow = -self.q_bin[seg1].loc[result_time].iloc[-1]
                        dens = self.dens_bin[seg1].loc[result_time].iloc[-1]
                    # Get the dynamic pressure of the flow and subtract it
                    # from the total pressure to give us static pressure.
                    #
                    discard, fan_char_dict = self._GetFanChar(fan_name)
                    area = fan_char_dict["area"]
                    vel = alt_flow / area
                    P_s = P_tot - 0.5 * dens * vel**2
                    # Let's be lazy.
                    P_tot = P_s

                if prop in ("system", "system-cursed"):
                    # Get the multiplier of our Y = X**2 curve on the
                    # flow-total pressure plane.
                    if math.isclose(fan_flow, 0.0):
                        # We have zero flow, just draw a vertical line for
                        # the system characteristic.  This avoids a divide
                        # by zero error in the else clause below.
                        fan_flows = (0.0, 0.0)
                        fan_P_tots = (0.0, P_tot)
                    else:
                        # Build lists that plot the system curve.
                        gauls = P_tot / fan_flow**2
                        interval = fan_flow / 10.0
                        # Get the system characteristic that just extends
                        # beyond across the fan characteristic.  There
                        # must be a better way of doing it than this,
                        # though.
                        fan_flows = list(np.arange(interval,
                                          fan_flow * 1.01, interval))  \
                                    + [fan_flow * 1.01]
                        fan_P_tots = [gauls * flow**2 for flow in fan_flows]
                else:
                    # Build a list of one point that will be plotted with
                    # a point instead of with lines.
                    fan_flows = [fan_flow]
                    fan_P_tots = [P_tot]
        elif prop in ("fanchar", "fanchar-cursed"):
            char_data = self.fanchars_dict[char_name]
            # We want the fan characteristic at an instant in time, given
            # as volume flow and total pressure rise or as volume flow
            # and static pressure rise.
            if math.isclose(speed, 0.0):
                # The fan is off, so has no fan characteristic.  Other
                # prime movers may be moving air through this segment but
                # they have nothing to do with this fan.  We put in two
                # points so that gnuplot can plot a line.
                fan_flows = [0.0, 0.01]
                fan_P_tots = [0.0, 0.0]
                # Set a fan flow that ensures that we do not extend
                # the characteristic in either direction (see below).
                fan_flow = 0.005
                direct_text = "(off)"
            elif speed > 0.0:
                # We want the fan characteristic used for forwards
                # airflow.
                direct_text = "(forwards)"
                char_flows, char_P_tots = char_data["forwards"]
                fan_flows = [flow * speed for flow in char_flows]
                fan_flow = self.q_bin[seg1].loc[result_time].iloc[-1]

                # Figure out the air density at the fan inlet and turn
                # the fan_P_tots (which are dimensionless) into fan total
                # pressures at that air density and at the correct fan
                # speed.
                dens = self.dens_bin[seg1].loc[result_time].iloc[-1]
                P_adj = dens * self.settings_dict["psi"] * speed**2   \
                          / self.settings_dict["gamma"]**2
                fan_P_tots = [press * P_adj for press in char_P_tots]
            else:
                # We want the fan characteristic for used for reverse airflow.
                direct_text = "(reverse)"
                char_flows, char_P_tots = char_data["reverse"]
                fan_flows = [-flow * speed for flow in char_flows]
                fan_flow = -self.q_bin[seg2].loc[result_time].iloc[0]
                dens = self.dens_bin[seg2].loc[result_time].iloc[0]
                P_adj = dens * self.settings_dict["psi"] *   \
                          (speed / self.settings_dict["gamma"])**2
                fan_P_tots = [press * P_adj for press in char_P_tots]
            if prop == "fanchar-cursed":
                # Subtract one velocity pressure from each fan total
                # pressure, using the corresponding volume flow and
                # the upwind air density.  First get the fan area
                # from the fan characteristic dictionary.  We know
                # it's in there because an error would already have
                # been raised if the diameter entry was absent in
                # the fan characteristic definition.
                fan_char_name, fan_char_dict = self._GetFanChar(fan_name)
                area = fan_char_dict["area"]
                factor = dens / (2 * area**2)
                fan_P_dyn = [factor * flow**2 for flow in fan_flows]
                fan_P_s = [P_t - P_d for P_t, P_d in zip(fan_P_tots, fan_P_dyn)]
                # Some verification printouts, change False to True
                # in the 'if' statement to see them.
                if False:
                    print("  Flow,       P_t,        P_s,      P_d")
                    for index, P_t in enumerate(fan_P_tots):
                        print(str(round(fan_flows[index],3)).center(10),
                              str(round(P_t,3)).center(10),
                              str(round(fan_P_s[index],3)).center(10),
                              str(round(fan_P_dyn[index],3)).center(10))
                # Replace P_tot with P_stat.  This is lazy.
                fan_P_tots = fan_P_s
                descrip_text = "P_s characteristic of"
            else:
                descrip_text = "P_t characteristic of"
            # Now check if the duty point is off the end of the fan
            # characteristic.  The fan could be forced off the end
            # (in reverse flow or freewheeling) due to the action of
            # another fan or a train.
            # If it is, extend the characteristic using linear
            # extrapolation from the closest pair of points on the curve
            # to the duty point. We put a break in the curve to emphasize
            # to the user that it is extrapolation.
            # Note that if you don't want extrapolation to be used,
            # there is nothing to stop you defining the freewheeling
            # and reverse flow parts of the characteristic yourself.
            if fan_flow < fan_flows[0]:
                Q1, Q2 = fan_flows[:2]
                P1, P2 = fan_P_tots[:2]
                Qrange = fan_flows[-1] - Q1
                # Check if the new duty point is more than 5% of the fan's
                # volume flow range to the left of Q3 and extend the
                # characteristic if it is.  Put in a break in the line
                # that lasts for 5% of the fan's flow range, that ought
                # to be visible on most graphs.
                Q3 = Q1 - 0.05 * Qrange
                if fan_flow < Q3:
                    P3 = gen.Interpolate(Q1, Q2, P1, P2, Q3, True, self.log)
                    P4 = gen.Interpolate(Q1, Q2, P1, P2, fan_flow, True, self.log)
                    fan_flows = [fan_flow, Q3, "     "] + fan_flows
                    fan_P_tots = [ P4,     P3, "     "] + fan_P_tots
            elif fan_flow > fan_flows[-1]:
                Q1, Q2 = fan_flows[-2:]
                P1, P2 = fan_P_tots[-2:]
                Qrange = Q2 - fan_flows[0]
                Q3 = Q2 + 0.02 * Qrange
                if fan_flow > Q3:
                    P3 = gen.Interpolate(Q1, Q2, P1, P2, Q3, True, self.log)
                    P4 = gen.Interpolate(Q1, Q2, P1, P2, fan_flow, True, self.log)
                    fan_flows.extend(["     ", Q3, fan_flow])
                    fan_P_tots.extend(["     ", P3, P4])


        # Define the conversion keys for the calling routine.
        x_USconv = these_props["Xconversion"]
        y_USconv = these_props["conversion"]

        # Now build some QA data that lets people trace where this data
        # came from.
        #
        QAlist = ["# Hobyah system/fan performance QA"] + self._QAlines() + [\
                  '# Property plotted, ' + prop,
                  '# Property description, ' + these_props["descrip"],
                  '# Original locator, ' + orig_where,
                  '# Modified locator, ' + where,
                  '#',  # Not used (plot time wanted)
                  '#',  # Not used (plot time used)
                  '#',
                  '# X conversion key, "' + x_USconv + '", '
                    + USc.ConversionDetails(x_USconv),
                  '# Y conversion key, "' + y_USconv + '", '
                    + USc.ConversionDetails(y_USconv)[:-1],
                 ]

        # Get the column headers for a transient plot.
        col_headers = self._ColHeaders("Volume flow", prop, units)

        # autolabel = 'fan property "' + prop + '" with no autolabel'

        # Build the autolabel.  It's easier to do it here than in
        # PROC _BuildAutoLabel.
        time_text = gen.RoundText(result_time, 4)
        autolabel = (descrip_text + ' fan ' + gen.OptQuotes(fan_name)
                     + ' at ' + time_text + " sec " + direct_text)

        return(QAlist, fan_flows, x_USconv, fan_P_tots, y_USconv, autolabel,
               col_headers)


    def _BuildAutoLabel(self, curve_type, prop, units, orig_where, where,
                        result_time = -1):
        '''Take a curve type, a property name, a set of locations, and
        (optionally) a time.  Turn them into an autolabel for the curve.
        This routine assumes that the property and locations have already
        been checked in earlier routines.

        Parameters:
            self            class           Everything in the class.
            curve_type      str             "transient", "profile", "waterfall"
                                            etc.
            prop            str             A string naming the property to plot
                                            that has been checked.
            units           str             "si" or "us".  Not used to convert
                                            the data, just to put the correct
                                            units in the autolabel.
            orig_where      str             A string defining where to plot in
                                            the form that was given in the input
                                            file, e.g. "Mainline@101521.5" or
                                            "FID@124.2".
            where           str             A tuple defining where to plot in
                                            a form that matches a pandas database
                                            in the binary file.  When plotting
                                            in segments it is the segment index
                                            and a chainage that is the column
                                            index, e.g. (52, 101521.5).  When
                                            plotting in dampers it is a tuple of
                                            the type of damper and the name of
                                            the damper, e.g. ("damper2", "FID").
                                            When tunnel properties are being
                                            seen by a train that is in the open
                                            air, it will be "outside".
            result_time     float           The time that a profile was really
                                            plotted at, which may be equal to or
                                            less than the time asked for.

        Returns:
            autolabel         str           A line of text that can be used as
                                            a graph key entry.
        '''
        these_props = self.properties[prop.lower()]

        tun_names = self.tunnels_dict.keys()
        rte_names = self.routes_dict.keys()
        damp_names = self.Rs_bf_bin.columns


        # Get the first part of the autolabel, the description. Capitalize
        # it if the first letter is lower case.
        first = these_props["descrip"] + " "
        if first[0] == "-":
            # It is a reversed property, so check the second letter.
            # This is fragile, because if an idiot creates a description
            # in self.properties that is one lower-case character, this
            # will crash.
            if first[1].islower():
                first = "-" + first[1:].capitalize()
        else:
            # It is not a reversed property, capitalise it.
            first = first.capitalize()

        # Figure out what the distance units text should be, in case we
        # need it.
        if units == "us":
            dist_unit = " ft "
        else:
            dist_unit = " m "


        parts = orig_where.lower().split(sep = '@')
        # Get the second part, which depends on a few factors.
        if curve_type == "transient":
            if where == "outside":
                second = 'in route ' + gen.OptQuotes(parts[0]) + \
                          ' in the open air'
            elif where[0] in self.timedlosses_dict:
                d_type = self.timedlosses_dict[where[0]][0]
                if d_type in ("damper1", "damper2"):
                    # This is at a damper, so it's fairly simple.
                    second = 'at damper ' + gen.OptQuotes(where[0])
                else:
                    print("Need to add code to handle a new type of timed "
                          'loss, "' + d_type + '"')
                    gen.OopsIDidItAgain(self.log)
            elif where[0] in self.tunnelfans_dict:
                d_type = self.tunnelfans_dict[where[0]][7]
                if d_type in ("fan1", "fan2"):
                    # This is at a fan, so it's fairly simple.
                    if prop in ("pdiff", "-pdiff"):
                        second = 'across fan ' + gen.OptQuotes(where[0])
                    else:
                        second = 'at fan ' + gen.OptQuotes(where[0])
                else:
                    print("Need to add code to handle a new type of fan "
                          ', "' + d_type + '"')
                    gen.OopsIDidItAgain(self.log)
            else:
                # Figure out if the user gave a distance along a route,
                # distance along a tunnel or distance from the down end
                # of a train.
                # It was something like "train12@-50" or "Mainline@2000".
                if parts[0].lower() in rte_names:
                    # The user referenced a route.  Note that a route and
                    # a tunnel cannot have the same name.

                    # Convert the distance from the gridpoint location
                    # (distance along a tunnel) to the route chainage.
                    transform_data = self.route2segs_dict[parts[0]]
                    segs = transform_data["segs"]
                    seg_index = segs.index(where[0])
                    mult = transform_data["mults"][seg_index]
                    offset = transform_data["offsets"][seg_index]
                    dist = (where[1] - offset) / mult
                    if units == "si":
                        dist_text = gen.RoundText(dist, 2)
                    else:
                        dist_text = gen.RoundText(dist / 0.3048, 3)

                    # Merge the text of the distance with " m" or " ft".
                    distance = dist_text + dist_unit[:-1]

                    second = 'in route ' + gen.OptQuotes(parts[0]) + ' at ' \
                              + distance
                elif parts[0].lower() in tun_names:
                    if units == "si":
                        dist_text = gen.RoundText(where[1], 2)
                    else:
                        dist_text = gen.RoundText(where[1] / 0.3048, 3)
                    # Merge the text of the distance with " m" or " ft".
                    distance = dist_text + dist_unit[:-1]
                    # The user referenced a tunnel.
                    second = 'in tunnel ' + gen.OptQuotes(parts[0]) + ' at ' \
                              + distance

                # Check if the property was intrinsic to the train or
                # a property seen by a passing train.
                elif these_props["place"] == "train":
                    entity_text = "".join(filter(str.isdigit, parts[0]))
                    second = "train " + entity_text
                else:
                    # It in a route or seen by a passing train.  Include the
                    # distance in the label and whether it was in the annulus
                    # or not.
                    dist_text = parts[1]
                    # Knock off any trailing ".0" in the distance text.
                    if dist_text[-2:] == ".0":
                        dist_text = dist_text[:-2]
                    # They gave a distance along a route or offset from a train
                    # end.
                    if parts[0][:5] == "route":
                        second = ("at " + dist_text + dist_unit
                                  + "on route " + gen.OptQuotes(entity_text)
                                 )
                    else:
                        if dist_text[0] != "-":
                            # It's going down the route.  Check for a leading plus
                            # sign and remove it if it is there.
                            if dist_text[0] == "+":
                                dist_text = dist_text[1:]
                            second = (dist_text + dist_unit + "down from the "
                                      + "down end of train " + entity_text
                                      + " (in front of it)")
                        else:
                            # The distance is going up the route.
                            # Figure out if the point we are plotting at is alongside
                            # the train or so far back that it is behind the tail
                            # and set the autolabel accordingly.
                            # We can't do this check at the moment because we have
                            # no data on the types of each train number (it's not
                            # in the .hbn file yet) so we just assume it is in
                            # the train's annulus.
                            if True:
                                second = (dist_text[1:] + dist_unit + "up from the "
                                          + "down end of train " + entity_text
                                          + " (in the annulus)")
                            else:
                                second = (dist_text[1:] + dist_unit + "up from the "
                                          + "down end of train " + entity_text
                                          + " (behind the tail)")
        elif curve_type == "profile":
            # It is a profile, so it must have an "@" in it.
            # It was something like "mainline1@-50" or "train25@120".  We
            # split 'where' instead of orig_where because 'where' has
            # the time that was actually used. 'orig_where' has the time
            # that was asked for.
            parts = where.lower().split(sep = '@')
            time_text = gen.RoundText(result_time, 5)
            if parts[0].lower() in rte_names:
                # The user referenced a route.  Note that a route and
                # a tunnel cannot have the same name.  We check for route.
                second = 'along route ' + gen.OptQuotes(parts[0])
            elif parts[0].lower() in tun_names:
                # The user referenced a tunnel.
                second = 'along tunnel ' + gen.OptQuotes(parts[0])
            else:
                # Get the number of the train as a string.
                entity_text = "".join(filter(str.isdigit, parts[0]))
                second = "as seen by train " + entity_text

            if these_props["transient"] == False:
                # It is not a transient profile but a fixed one (such as
                # a vertical profile along a route.  We don't add a time.
                pass
            else:
                second = second + ' at ' + time_text + " sec"
        return(first + second)



    def GetTransientData(self, prop, orig_where, where, line_text, units = "si"):
        '''Take the contents of a Hobyah file, a location and a property
        to plot against time.  We assume that the location and property
        have either already been checked or have been generated internally
        and are correct.  Make two lists: print times on the X axis
        and the SI values of the property on the Y axis.  Also return the
        keys needed to convert the values to US units and some QA data
        suitable for putting at the top of the curve data file.

        Parameters:
            self            class           Everything in the class.
            prop            str             A string naming the property to plot
                                            that has been checked.
            orig_where      str             A string defining where to plot in
                                            the form that was given in the input
                                            file, e.g. "westbound@320.5" (for QA
                                            purposes).
            where           str             A string defining where to plot in a
                                            form that matches a list holding
                                            a series of pandas databases in the
                                            binary file, e.g. "120@320.0" meaning
                                            "the 120th entry in the list and
                                            pandas column index 320.0".
            line_text       str             The text of the line being
                                            processed.  Part of the QA.
            units           str             "si" or "us".  Not used to convert
                                            the data, just to put the correct
                                            units in the autolabel.

        Returns:
            QAlist          []              A list of lines tracing the data.
            x_data          []              A list of X-values (time in seconds).
            x_USconv        str             "seconds", signifying that time in
                                            US units is the same as in SI units.
            y_data          []              A list of X-values (time in seconds).
            y_USconv        float           The key to use in UScustomary.py to
                                            convert the Y values from SI to US
                                            units.
            autolabel       str             A line of text that can be used as
                                            a graph key entry.
            col_headers     str             A string of text with suitable
                                            headers to appear above each column
                                            if someone loads a curve data file
                                            into a spreadsheet.
        '''
        these_props = self.properties[prop.lower()]
        x_USconv = "seconds" # The X-axis is time.
        y_USconv = these_props["conversion"]

        x_data = self.aero_times
        if where == "open_air":
            # The location is outside the tunnel.  Get the value outside
            # into a list that is the same length as the x_data.
            y_data = [these_props["open_air"]] * len(x_data)
            autolabel = self._BuildAutoLabel("transient", prop, units,
                                              orig_where, "outside")
        elif type(where) is tuple:
            if (where[0] in self.timedlosses_dict or
                where[0] in self.tunnelfans_dict):
                # It is a named entity such as a damper or a fan.
                y_data = these_props["var_name"][where[0]]
            elif where[0] == "train property":
                y_data = these_props["var_name"][where[1]]
            else:
                # It is inside the tunnel.  If it is in the
                # tunnel then 'where' will be a tuple of the segment index
                # and the pandas array index.
                seg_index, db_key = where
                y_data = these_props["var_name"][seg_index][db_key]
            # Check whether the values should be multiplied by -1.  This
            # occurs with properties like "-volflow" which is just
            # "volflow" multiplied by -1.
            if prop[0] == "-":
                y_data = -y_data
            autolabel = self._BuildAutoLabel("transient", prop, units,
                                             orig_where, where)

        # Now build some QA data that lets people trace where this data
        # came from.
        #
        QAlist = ["# Hobyah transient QA"] + self._QAlines() + [\
                  '# Property plotted, ' + prop,
                  '# Property description, ' + these_props["descrip"],
                  '# Original locator, ' + orig_where,
                  '# Modified locator, ' + str(where),
                  '#',  # Not used (plot time wanted)
                  '#',  # Not used (plot time used)
                  '#',
                  '# X conversion key, null, 1.0',
                  '# Y conversion key, "'
                    + these_props["conversion"] + '", '
                    + USc.ConversionDetails(these_props["conversion"])[:-1],
                 ]

        # Get the column headers for a transient plot.
        col_headers = self._ColHeaders("Time", prop, units)
        # Set a flag that this plot can only be plotted against time.
        TX_axes = False

        return(QAlist, x_data, x_USconv, y_data, y_USconv, autolabel,
               col_headers, TX_axes)


    def _QAlines(self):
        '''Return a set of lines of QA data with data about the
        provenance of the binary file.
        '''
        return(['# Name of binary, "' + self.file_name + '"',
                '# Source name, "' + self.runfile_name + '"',
                '# Project no., "' + self.settings_dict["qa1"] + '"',
                '# Project name, "' + self.settings_dict["qa2"] + '"',
                '# Description, "' + self.settings_dict["qa3"] + '"',
                '# Date created, "' + self.when_who + '"'])


    def _GetPlotTime(self, time):
        # Now get the print time equal to or just below the desired time.
        # If a user puts in a negative time we don't fault, we just print
        # at zero seconds.
        last_time = self.aero_times[-1]
        if time >= last_time:
            # The time is so high that it is not in the list.  Use the
            # last time.
            result_time = last_time
        else:
            for index, p_time in enumerate(self.aero_times):
                # We check math.isclose first, in case there are slight floating
                # point mismatches.  Python's 'math.isclose' function treats a
                # value that is within 10-9 of (in this context, within one
                # nanosecond) the desired time as being close enough to match.
                # After we check that, we check if the current time is higher
                # than the desired time.  If it is we print at the time before
                # the current time.
                if math.isclose(time, p_time):
                    result_time = p_time
                    break
                elif p_time > time:
                    # The current entry in the print times is too high.  Get
                    # the one below and break.
                    result_time = self.aero_times[index - 1]
                    break
        return(result_time)



    def RouteAt(self, where, prop, curve_type, units,
                    file_name, optionals_dict, line_number, line_text):
        '''Take the location of a property to plot against distance, something
        like "Mainline@1200".  This means "plot something along the tunnel
        or route named "mainline" at time 1200 seconds, or the closest lower
        time if 1200 is not in the output.

        This routine assumes that the property has already been checked
        by a call to self.CheckProperty.  If a dud property is provided
        it will cause an exception.

        Parameters:
            self            class           Everything in the class.
            where           str             A string defining where to plot
            prop            str             A string naming the property to
                                            plot.
            curve_type      str             A string describing what kind of
                                            curve this is, e.g. "transient",
                                            "profile" etc.  Used in error
                                            messages.
            units           str             The system of units the input is in.
                                            This could be "si" or "us".
            file_name       str             The name of the file being processed
                                            when this routine was called.  Used
                                            in error messages.  Not the name of
                                            the .hbn file being plotted from.
            optionals_dict  {}              Dictionary of the optional entries
                                            on the line.
            line_number     int             The line number being processed.
                                            Used in error messages.
            line_text       str             The text of the line being
                                            processed. Used in error messages.

        Returns:
            transient       bool            True if it is transient, False if
                                            it is not.
            distances       tuple of (dist_keys, plot_dists)
                dist_keys                   A list of strings that are keys
                                            to the pandas databases.
                plot_dists                  A list of distances that are the
                                            locations of gridpoints in segments.
            time            float           Time at which we want to plot.
            result_time     float           Time at which we can plot that is
                                            at or below the time we want to
                                            plot at.
        '''
        # Figure out what key to use from the plot type's properties and
        # whether we can allow it not to have a time entry.
        these_props = self.properties[prop.lower()]
        keytype = these_props["place"]
        transient = these_props["transient"]
        signed = these_props["signed"]

        # Check the general structure of the location.  This returns
        # the name of the entity in lower case, a discarded value
        # the time to plot at as a float.
        numbered = []
        result = self._CheckAt(where, numbered, file_name,
                                    line_number, line_text)
        if result is None:
            return(None)
        else:
            (entity, discard, time) = result

        # We know that the entity must be the name of route or a tunnel.

        if transient:
            result_time = self._GetPlotTime(time)


            if entity in self.tunnels_dict:
                source = "tunnel"
                # We know we have a transient values in one tunnel.
                # Figure out the segments that make up this tunnel.
                seg_indices, tun_keys = self.GetTunnelStuff(entity)
                # Turn the segment numbers into strings.  We use strings
                # because when we have routes we may have tunnels reversed,
                # we represent reversed segments by negative numbers, so
                # we want to be able to reverse segment "-0".
                segments = [str(segment) for segment in seg_indices]
                dist_keys = tun_keys
                # Get the plot chainages as a list of tunnel distances.
                # The itertools.chain() function flattens lists of lists
                # into lists.
                plot_dists = list(itertools.chain(*dist_keys))
                # Set the multipliers on the plotted values.  These are
                # all +1 for profiles in tunnels.
                multipliers = []
            elif entity in self.routes_dict:
                source = "route"
                # We know we have a transient values in one tunnel.
                # Figure out the segments that make up this tunnel.
                tunnel_names = self.routes_dict[entity]["signed_names"]
                tunnel_chs = self.routes_dict[entity]["tunnel_chs"]
                start_ch = self.routes_dict[entity]["portal"][0]
                segments = []
                dist_keys = []
                plot_dists = []

                for index, name in enumerate(tunnel_names):
                    # Get the chainage of the up end of this tunnel
                    # in the route.  This may be the back end or
                    # the forward end, if the tunnel is reversed in
                    # the route.
                    if name[0] == '-':
                        # This tunnel is reversed in the route.  Chop
                        # off the minus sign before we call.
                        tun_segs, loc_keys = self.GetTunnelStuff(name[1:])

                        # Reverse the order of the segments.
                        tun_segs.reverse()
                        # Add minus signs to the strings representing the
                        # segment numbers.  We use strings because in Python
                        # 0 and -0 are the same but "0" and "-0" are not.
                        tun_segs = ["-" + seg_num for seg_num in tun_segs]

                        # Reverse the list of "lists of chainage keys" and
                        # also reverse the chainage keys in each sub-list.
                        loc_keys = [list(reversed(sub_list))
                                        for sub_list in reversed(loc_keys)]
                    else:
                        # This tunnel is not reversed in the route.  Calculate
                        # the chainages in the route (we don't have to remove
                        # a minus sign from the name).
                        tun_segs, loc_keys = self.GetTunnelStuff(name)

                    # Get the chainages in the route that we want to plot the
                    # values in this tunnel at.
                    for chs_list in loc_keys:
                        # Figure out if the distance at the up end of this
                        # segment is above or below the distance at the down
                        # end.
                        start = chs_list[0]
                        end = chs_list[-1]
                        # The gridpoints in segments are equally spaced so we
                        # can use the absolute
                        loc_dists = [start_ch + abs(ch - start)
                                            for ch in chs_list]
                        plot_dists.extend(loc_dists)
                        # Reset the start chainage for the next segment.
                        start_ch = plot_dists[-1]
                    segments.extend(tun_segs)
                    dist_keys.extend(loc_keys)

            # Make a tuple of the two expressions of distance.  The first
            # is the column keys needed in the pandas database.  The second
            # is the chainages we need to use for the X values in the plot.
            distances = (dist_keys, plot_dists)
        else:
            # This is a fixed property in a route (like elevation) or
            # in a tunnel (like hydraulic diameter).  These are not
            # accessed from pandas databases so we spoof all returns
            # except the first.
            distances = ["not relevant"]
            segments = ["not relevant"]
            time = "not relevant"
            result_time = "not relevant"
        return(transient, distances, segments, time, result_time)


    def GetTunnelStuff(self, entity):
        ''' Take the name of a tunnel that cannot be navigated by trains.
        Return a list of the indices to all the segments in the cell and
        lists of lists of distances in the tunnel that can be used as keys.

        Parameters:


            self            class           Everything in the class.
            entity          str             The name of a tunnel.

        Returns:
            segments        [str]           A list of all the indices of the
                                            segments that are in this tunnel,
                                            as strings
            dist_keys       [int]           A list of lists of column indices
                                            in each segment.
        '''
        seg_indices = self.tuns2frames[entity]
        dist_keys = []
        for index in seg_indices:
            dist_keys.append(self.dists[index])
        # Turn the segment indices into strings in case we have to reverse
        # them.
        segments = [str(seg_num) for seg_num in seg_indices]
        return(segments, dist_keys)


    def GetProfileTransient(self, distances, prop, orig_where, where, units,
                            keys, line_text, optionals_dict, result_time, time):
        '''Take two lists of chainages along a route, the name of the property
        to plot, the system of units to use, a set of keys to a pandas database
        database, the time to plot at and the time the user wanted to plot at.
        Get the profile data out of the database at the required time.  Return a
        list of the X values, a list of the Y values, a list of where in the
        geometry each value came from and a list of QA text to go at the top of
        the text file of curve data.
        The routines assumes that the property has been checked and that the
        list of keys and the result time all exist in the relevant pandas
        database.

        Parameters:
            self            class           Everything in the class.
            distances       tuple of (dist_keys, plot_dists)
                dist_keys                   A list of strings that are keys
                                            to the pandas databases.
                plot_dists                  A list of distances that are the
                                            locations of gridpoints in segments.
            prop            str             A string naming the property to plot.
            orig_where      str             A string defining where to plot in a
                                            a form that the user understands.
            where           str             A string defining where to plot in a
                                            form that this routine understands.
            units           str             The system of units the results are
                                            wanted in.  This could be "si" or "us".
            keys            []              A list of keys to the pandas database
                                            for that property.
            line_text       str             Text of the line this came from.  It
                                            is put into the lines of QA data.
            optionals_dict  {}              Dictionary of the optional entries
                                            on the line.  Used in classSES.py,
                                            so we also have it here even if it
                                            is never used.
            result_time     float           The time in the pandas database to
                                            take the results from.  This will be
                                            equal to or lower than the time the
                                            user requested.
            time            float           The time the user requested the plot
                                            be at.

        Returns:
            QAlist          []              A list giving some lines of QA data.
            distances       []              A list of distances in SI units
            x_USconv        str             The name of the conversion key to
                                            use to convert distances from metres
                                            to feet ("dist1")
            values_SI       []              A list of Y-values in SI units.
            y_USconv        str             The name of the conversion key to
                                            use to convert the Y values from SI
                                            units to US units.
            autolabel       str             A line of text that can be used as
                                            a graph key entry.
            col_headers     str             A string of text with suitable
                                            headers to appear above each column
                                            if someone loads a curve data file
                                            into a spreadsheet.
            QAdetails       []              A list detailing where each location
                                            on the X axis was in each tunnel.
                                            (e.g. chainage 1600 on route 1 could
                                            be "124-2b", the back end of the 2nd
                                            subsegment of segment 124.
        '''

        # Get the properties of this type of curve and the database to use.
        these_props = self.properties[prop.lower()]
        db_to_use = these_props["var_name"]
        place =  these_props["place"]

        QAlist = ["# Hobyah profile (transient data) QA"] + self._QAlines() + [\
                  '# Property plotted, ' + prop,
                  '# Property description, ' + these_props["descrip"],
                  '# Original locator, ' + orig_where,
                  '# Modified locator, ' + str(where),
                  '# Plot time wanted, ' + str(time),
                  '# Plot time used, ' + str(result_time),
                  '#',
                  '# X conversion key, "dist1", '
                    + USc.ConversionDetails("dist1")[:-1],
                  '# Y conversion key, "'
                    + these_props["conversion"] + '", '
                    + USc.ConversionDetails(these_props["conversion"])[:-1],
                  ]

        # Some values are vectors.  If a point is in the route backwards
        # and the property is a vector we want to multiply the value there
        # by -1.  We know which points are in the route backwards because
        # the key will start with a minus sign before the segment number.
        # We run through each key in the list of keys and pull out the
        # multiplier and the key to use.
        signed = these_props["signed"]
        values_SI = []
        QAdetails = []
        for key in keys:
            key_val = abs(int(key))
            pd_dbase = db_to_use[key_val]
            try:
                # Get the values in this segment at this result time.
                values = pd_dbase.loc[result_time]
                # Get the keys
            except TypeError:
                print("Fouled up with the keys of a profile:")
                for name in ("place", "descrip", "conversion",
                             "signed", "transient", "curve_types"):
                    print(name, ":", these_props[name])

            if key[0] == "-" and signed:
                # It is a vector property (e.g. velocity) and the
                # segment is backwards.  Reverse the sign.
                values_to_add = list(-values)
            else:
                # It is a scalar property (e.g. temperature) don't
                # reverse the sign.
                values_to_add = list(values)

            if key[0] == "-":
                # We need to reverse the order of the entries in
                # this segment.
                values_to_add.reverse()
            values_SI.extend(values_to_add)

            # Add the section distance to the list of QA data.
            #
            tunnel_name = self.segment_source[key_val]
            new_QA = ["# " + tunnel_name + '@' + gen.FloatText(dist)
                                        for dist in pd_dbase.columns]
            QAdetails.extend(new_QA)

        # Define the conversion keys for the calling routine.
        x_USconv = "dist1"
        y_USconv = these_props["conversion"]

        # Get the column headers for a route plot.
        col_headers = self._ColHeaders("Distance", prop, units)

        # Get the autolabel.
        autolabel = self._BuildAutoLabel("profile", prop, units,
                                         orig_where, where, result_time)

        # Set a flag that this plot can only be plotted against distance,
        # not against time
        TX_axes = False

        values_SI = np.array(values_SI)
        # Check whether the values should be multiplied by -1.
        if prop[0] == "-":
            values_SI = -values_SI
        return(QAlist, distances[1], x_USconv, values_SI, y_USconv,
               autolabel, col_headers, QAdetails, TX_axes)


    def GetProfileFixed(self, prop, orig_where, where, optionals_dict,
                        units, line_text):
        '''Take the name of the property to plot, where to plot, the
        optionals dictionary and the system of units to use and get
        a profile of fixed data along a route or tunnel (like tunnel
        area or perimeter).

        Return a list of the X values, a list of the Y values, a list of
        where in the geometry each value came from and a list of QA text to
        go at the top of the text file of curve data.
        The routines assumes that the property has been checked and that the
        list of keys is valid for the property.

        Parameters:
            self            class       Literally everything in the class.
            prop            str         The name of the property to plot.
            orig_where      str         A string defining where to plot in a
                                        a form that the user understands.
            where           str         A string defining where to plot in a
                                        form that this routine understands.
            optionals_dict  {}          A dictionary of optional entries
                                        that can alter the numbers being
                                        returned.
            units           str         The system of units the results are
                                        to be in: "si" or "us".
            line_text       str         Text of the line this came from.  It is
                                        put into the lines of QA data.


        Returns:
            QAlist          []          A list giving some lines of QA data.
            distances       []          A list of distances in SI units
            x_USconv        str         The name of the conversion key to
                                        use to convert distances from metres
                                        to feet ("dist1")
            values_SI       []          A list of Y-values in SI units.
            y_USconv        str         The name of the conversion key to
                                        use to convert the Y values from SI
                                        units to US units.
            autolabel       str         A line of text that can be used as
                                        a graph key entry.
            col_headers [[str],[str]]   A list of two lists of strings
                                        used as headers.  They appear
                                        above each column if someone
                                        loads a curve data file into
                                        a spreadsheet.
            QAdetails       []          A list detailing where each location
                                        on the X axis was in the SES file
                                        (e.g. chainage 1600 on route 1 could
                                        be "124-2b", the back end of the 2nd
                                        subsegment of segment 124.
        '''

        # Get the properties of this type of curve and the database to use.
        these_props = self.properties[prop.lower()]
        place =  these_props["place"]
        source = these_props["var_name"]
        complexity = these_props["complexity"]

        # "Where" is the name of a route or tunnel along with a number,
        # e.g. "mainline1@999".  We ignore the number.
        name = where.split(sep = "@")[0].lower()
        if name in self.routes_dict:
            route_dict = self.routes_dict[name]
            if "y_list" in these_props:
                # This is a property intrinsic to the route, not a plot
                # of tunnel properties along a route.  We don't need
                # to define anything here.
                pass
            else:
                # This is a property in the segments plotted along the
                # routes.  We build a list of segments in the route,
                # correctly oriented.
                segs = []
                chs = []
                mults = []
                for index, tun_name in enumerate(route_dict["signed_names"]):
                    if tun_name[0] == '-':
                        newsegs = self.tuns2segs[tun_name[1:]]["segs"].copy()
                        dists = self.tuns2segs[tun_name[1:]]["dists"].copy()
                        newsegs.reverse()
                        dists.reverse()
                    else:
                        newsegs = self.tuns2segs[tun_name]["segs"]
                        dists = self.tuns2segs[tun_name]["dists"]
                    # Convert the seg_IDs to segment indices and add them.
                    for seg in newsegs:
                        segs.append(seg - 1)
                    # Get the distances at each end of each segment
                    # and turn them into chainages in the route.
                    mult, offset = route_dict['route2tun'][index]
                    for dist in dists:
                        ch = (dist - offset) / mult
                        chs.append(ch)
                        mults.append(mult)
                    # Now remove all duplicates
                    chs = list(set(chs))
                    chs.sort()
                # Now spoof this plot of tunnel properties in a route.
                # We treat it as if the route is one tunnel.
                source = "in segments"
            profilesource = "route"
        else:
            segs = self.tuns2segs[name]["segs"]
            # We get the tunnel distances but we use the term 'chs' for
            # consistency.
            chs = self.tuns2segs[name]["dists"]
            # Spoof the multipliers as +1 values in tunnels, there is
            # no need to do any flipping when plotting along tunnels.
            mults = (1,) * len(segs)
            profilesource = "tunnel"

        QAlist = ["# Hobyah profile (fixed data) QA"] + self._QAlines() + [\
                  '# Property plotted, ' + prop,
                  '# Property description, ' + these_props["descrip"],
                  '# Original locator, ' + orig_where,
                  '# Modified locator (' + profilesource + '), ' + where,
                  '#',  # Not used (plot time wanted)
                  '#',  # Not used (plot time used)
                  '#',
                  '# X conversion key, "dist1", '
                    + USc.ConversionDetails("dist1"),
                  '# Y conversion key, "' + these_props["conversion"] + '", '
                    + USc.ConversionDetails(these_props["conversion"]),
                      ]

        if source == "in segments":
            # This is a property of the segments, not a property of
            # the route.  These are area, perimeter, roughness,
            # Fanning, Darcy and Atkinson friction factor, zeta_bf
            # and zeta_fb.

            # Just a list of Y values to match the X values.
            values_SI = []
            for seg_ID in segs:
                seg_idx = seg_ID - 1
                seg_props = self.segments_consts[seg_idx - 1]
                value = seg_props[place]
                # We may need to do some work on the roughness heights and
                # Fanning friction factors, as either can be set.  The rules
                # are as follows:
                #  * If a segment has a fixed friction factor and we're plotting
                #    roughness height, we back-calculate the roughness assuming
                #    that the friction factor is for fully turbulent flow using
                #    the fully turbulent term in the Colebrook-White function.
                #  * If a segment has a roughness height and we're plotting
                #    friction factor, we calculate the friction factor using
                #    the fully turbulent term in the Colebrook-White function.
                # Clear as mud, eh?
                if prop.lower() in ("fanning", "darcy", "atkinson"):
                    if value >= 0.:
                        # It is a roughness height in metres.  Get the
                        # Fanning friction factor.
                        d_h37 = 3.7 * seg_props[2]
                        value = 0.0625 / math.log(value / (d_h37), 10)**2
                    else:
                        # It must be a negative Fanning friction factor.
                        # Make it positive.
                        value = -value
                    if prop.lower() == "darcy":
                        value = 4 * value
                    elif prop.lower() == "atkinson":
                        value = 0.6 * value
                elif prop.lower() == "roughness":
                    if value < 0.:
                        # It is a fixed Fanning friction factor.  Get
                        # the roughness assuming it is fully turbulent.
                        d_h37 = 3.7 * seg_props[2]
                        value = d_h37 * math.pow(10, -0.25 / math.sqrt(-value))
                values_SI.append(value)
            # Now add the value at the down distance/chainage in the
            # tunnel.  It is the same as at the start except for values
            # of zeta.
            values_SI.append(values_SI[-1])
            if min(mults) < 0:
                # We have some segments reversed in this route.  Rearrange
                # values for them.  This doesn't matter for fixed properties
                # like area or perimeter, but does matter for k-factors which
                # are tied to one particular end.
                for index, mult in enumerate(mults):
                    if math.isclose(mult, -1.):
                        store = values_SI.pop(index)
                        values_SI.insert(index + 1, store)
            # Get the values from the segments_consts list of lists
            # and choose the appropriate type of curve to plot
            if complexity == "double_up1":
                # We want a step change at each point.  This is for
                # properties like area and perimeter.
                distances = np.repeat(chs, 2)[1:-1]
                values_SI = np.repeat(values_SI, 2)
            elif complexity == "double_up3":
                # These are values specific to the back end and forward
                # end.  We plot an 0.5 m wide top hat at the end.
                chs2 = np.repeat(chs, 2)[1:-1]
                values2 = np.repeat(values_SI, 2)
                distances = []
                values_SI = []
                for index, (ch, value) in enumerate(zip(chs2, values2)):
                    if divmod(index,2)[1] == 0:
                        # This is the up end or back end, we add a
                        # point 0.5 m after the chainage.
                        distances.append(ch)
                        distances.append(ch + 0.5)
                    else:
                        # We want 0.5 m before the chainage.
                        distances.append(ch - 0.5)
                        distances.append(ch)
                    values_SI.append(value)
                    values_SI.append(value)
        # This is a test for a weird one - an elevation with a modification
        # for local segment area.  Elevation has a complexity of "simple"
        # but when we want to modify it by area it becomes complex and we
        # combine elevations with areas.  We also limit the plot to
        # show the elevation inside the tunnel, not in the open air.
        # This means we can plot the route elevations and then show
        # the route elevations a second time slightly farther up in the
        # graph frame to show the roof of the tunnel.  The "areamult"
        # optional argument lets the roof of the tunnel vary slightly
        # with the tunnel area, indicating regions of low and high
        # tunnel area that change where we go from cut and cover to
        # bored or from bored to a station box.
        elif (prop.lower() == "elevations" and "areamult" in optionals_dict):
            dict_to_use = these_props["var_name"][name]
            chs1 = dict_to_use[these_props["x_list"]]
            elevs1 = dict_to_use[these_props["y_list"]]
            # Make a list of the chainages of changes of gradient and
            # the chainages of the segments along the route.
            chs2 = dict_to_use["tunnel_chs"]
            # Get a copy of the elevations at the changes of gradient.
            elevs2 = []
            # Now add the elevations at the chainages of the segments.
            for ch in chs1:
                # Check for overlaps.
                if ch not in chs2:
                    # We have a new segment that does not coincide
                    # with a change in gradient.  Add it.
                    elev = np.interp(ch, chs1, elevs1)
                    elevs2.append(elev)
            chs3 = chs1 + chs2
            elevs3 = elevs1 + elevs2
            intermediate = list(zip(chs3, elevs3))
            intermediate.sort(key=operator.itemgetter(0))
            distances, elevs4 = list(zip(*intermediate))

            # Now add the value at the down distance/chainage in the
            # tunnel.  Need to complete this.
            # discard, areas_SI = self._SpoofPairs(1, route_num)
            # factor = float(optionals_dict["areamult"])
            # minarea = min(areas_SI) * factor
            # myzip = zip(elevs_SI, areas_SI)
        elif complexity == "simple":
            # We can get the X and Y values directly by accessing a dictionary
            # with a couple of named variables without having to do any post-
            # processing.
            dict_to_use = these_props["var_name"][name]
            distances = dict_to_use[these_props["x_list"]]
            values_SI = dict_to_use[these_props["y_list"]]
        elif complexity == "double_up1":
            # This is a route property that we want to plot against
            # route chainage or tunnel distance as a top-hat profile.
            # We stored the values in a list of single entries in the
            # route definition that we we need to expand out.
            #
            dict_to_use = these_props["var_name"][name]
            single_chs = dict_to_use[these_props["x_list"]]
            single_values = dict_to_use[these_props["y_list"]]
            distances = np.repeat(single_chs, 2)[1:-1]
            values_SI = np.repeat(single_values, 2)

        # Define the conversion keys for the calling routine.
        x_USconv = "dist1"
        y_USconv = these_props["conversion"]
        QAdetails = None

        # Get the column headers for a route plot.
        col_headers = self._ColHeaders("Distance", prop, units)

        # Get the autolabel.
        autolabel = self._BuildAutoLabel("profile", prop, units,
                                         orig_where, where)

        # Set a flag that this plot can only be plotted against distance,
        # not against time
        TX_axes = False

        return(QAlist, distances, x_USconv, values_SI, y_USconv,
               autolabel, col_headers, QAdetails, TX_axes)


    def IsTrafficProperty(self, prop):
        '''Take the name of a property and check if it is a traffic
        property.  Return True if it is and False if it is not.
        '''
        return(prop in self.traffic_prop)


    def GetProfileTraffic(self, distances, prop, orig_where, where, units,
                          keys, line_number, line_text, result_time, time):
        '''Take two lists of chainages along a route, the name of the
        property to plot, the system of units to use, a set of keys
        to a pandas database, the time to plot at, and the time the
        user wanted to plot at.

        Build traffic data at that time.  It might be built from the
        fixed traffic data or pulled out of a transient traffic pandas
        database at the required time.

        Return a list of the X values, a list of the Y values, a list
        of where in the geometry each value came from and a list of QA
        text to go at the top of the text file of curve data.
        The routines assumes that the property has been checked and
        that the list of keys and the result time all exist in the
        relevant pandas database.

        Parameters:
            self            class           Everything in the class.
            distances       tuple of (dist_keys, plot_dists)
                dist_keys                   A list of strings that are keys
                                            to the pandas databases.
                plot_dists                  A list of distances that are the
                                            locations of gridpoints in segments.
            prop            str             A string naming the property to plot.
            orig_where      str             A string defining where to plot in a
                                            a form that the user understands.
            where           str             A string defining where to plot in a
                                            form that this routine understands.
            units           str             The system of units the results are
                                            wanted in.  This could be "si" or "us".
            keys            []              A list of keys to the pandas database
                                            for that property.
            line_number     int             The line number that was read that
                                            prompted this call to open the file
                                            (used in error messages).
            line_text       str             The text of the line being read that
                                            prompted this call to open the file
                                            (used in error messages and written
                                            to the QA data).
            result_time     float           The time in the pandas database to
                                            take the results from.  This will be
                                            equal to or lower than the time the
                                            user requested.
            time            float           The time the user requested the plot
                                            be at.

        Returns:
            QAlist          []              A list giving some lines of QA data.
            distances       []              A list of distances in SI units
            x_USconv        str             The name of the conversion key to
                                            use to convert distances from metres
                                            to feet ("dist1")
            values_SI       []              A list of Y-values in SI units.
            y_USconv        str             The name of the conversion key to
                                            use to convert the Y values from SI
                                            units to US units.
            autolabel       str             A line of text that can be used as
                                            a graph key entry.
            col_headers     str             A string of text with suitable
                                            headers to appear above each column
                                            if someone loads a curve data file
                                            into a spreadsheet.
            QAdetails       []              A list detailing where each location
                                            on the X axis was in each tunnel.
                                            (e.g. chainage 1600 on route "EB"
                                            could be "# eastbound1 @ 2000"
                                            (note that 2000 in the tunnel is
                                            ch. 1600 in the route).
        '''

        # Get the properties of this type of curve and the database to use.
        these_props = self.properties[prop.lower()]
        db_to_use = these_props["var_name"]
        place =  these_props["place"]

        # Get some values we will need regardless of whether the traffic
        # is transient or fixed.
        veh_type = prop.rsplit(sep = '_', maxsplit = 1)[0]
        route_name, time = where.split(sep = "@")

        QAlist = ["# Hobyah profile (traffic data) QA"] + self._QAlines() + [\
                  '# Property plotted, ' + prop,
                  '# Property description, ' + these_props["descrip"],
                  '# Original locator, ' + orig_where,
                  '# Modified locator, ' + str(where),
                  '# Plot time wanted, ' + str(time),
                  '# Plot time used, ' + str(result_time),
                  '#',
                  '# X conversion key, "dist1", '
                    + USc.ConversionDetails("dist1")[:-1],
                  '# Y conversion key, "'
                    + these_props["conversion"] + '", '
                    + USc.ConversionDetails(these_props["conversion"])[:-1],
                  ]

        if db_to_use == "#fixed vehicle stuff":
            # The data is not in a pandas database (it is fixed flow or
            # density, not transient).  We need to build the data from
            # scratch.
            route = route_name.lower()

            # First check if this route has fixed traffic in it.  If it
            # doesn't, we give zero values.
            if route not in self.traffic1_dict:
                value = 0.0
            elif prop[-5:] == "_flow":
                flow_list, dens_list = self.traffic1_dict[route]
                if dens_list[-1] == 0.0:
                    # It's stationary traffic, so zero flow.
                    value = 0.0
                elif prop == "tot_flow":
                    # We limit the sum to the flows in case I do
                    # something stupid and add extra data to the
                    # end of the flow list.
                    value = sum(flow_list[:len(self.veh_types)])
                else:
                    veh_index = self.veh_types.index(veh_type.lower())
                    value = flow_list[veh_index]
            elif prop[-5:] == "_dens":
                flow_list, dens_list = self.traffic1_dict[route]
                if prop == "tot_dens":
                    # The sum of the densities is stored near the
                    # end of the list, along with a speed of zero.
                    value = dens_list[-2]
                else:
                    veh_index = self.veh_types.index(veh_type.lower())
                    value = dens_list[veh_index]

            QAdetails = []

            # Get a list of the locators in the route, correctly
            # arranged.
            tunnels = self.routes_dict[route]["signed_names"]
            for tun_name in tunnels:
                if tun_name[0] == "-":
                    # The tunnel is in the route backwards, so
                    # we reverse the entries we're adding
                    segs = self.tuns2frames[tun_name[1:]].copy()
                    segs.reverse()
                    for seg_num in segs:
                        locs = self.locators[seg_num].copy()
                        locs.reverse()
                        QAdetails.extend(locs)
                else:
                    # No need to reverse the entries.
                    segs = self.tuns2frames[tun_name]
                    for seg_num in segs:
                        QAdetails.extend(self.locators[seg_num])
            values_SI = (value,)*len(QAdetails)

        # Define the conversion keys for the calling routine.
        x_USconv = "dist1"
        y_USconv = these_props["conversion"]

        # Get the column headers for a route plot.
        col_headers = self._ColHeaders("Distance", prop, units)

        # Get the autolabel.
        autolabel = self._BuildAutoLabel("profile", prop, units,
                                         orig_where, where, result_time)

        # Set a flag that this plot can only be plotted against distance,
        # not against time.
        TX_axes = False

        # Check whether the values should be multiplied by -1.  Unsure
        # if this is necessary in the traffic properties routine, but
        # might as well have the code.
        if prop[0] == "-":
            values_SI = -np.array(values_SI)
        return(QAlist, distances[1], x_USconv, values_SI, y_USconv,
               autolabel, col_headers, QAdetails, TX_axes)


    def _SpoofPairs(self, prop_index, route_name):
        '''Take an index in segments_source defining a fixed property we
        want to plot and a route name.  Return a list of paired chainages
        and paired values.
        '''
        # First get the chainages.  This curve needs to show a stepped
        # profile, so we want the interior points to be doubled up.
        dict_to_use = route2segs[route_name]
        single_chs = dict_to_use["seg_chs"]
        distances = list(np.repeat(single_chs, 2))[1:-1]

        # Now get the list of segments, removing any negative signs.
        seg_list = [abs(seg) for seg in dict_to_use["segs"]]

        # Get the Y values from the appropriate place in segments_source
        # Build a list of values then double them up too.
        single_values = [segments_consts[seg][prop_index] for seg in seg_list]
        values_SI = list(np.repeat(single_values, 2))
        return(distances, values_SI)


    def _ColHeaders(self, x_name, prop, units):
        '''Take a name for the X axis data (typically "Time" or "Distance"
        but could also be something like "Volume flow" on fan characteristics).
        Take the name of a property and the name of a system of units ("si" or "us").
        Build a line that can be used as column headers in a text file
        holding curve data that can be plotted.

        Parameters:
            self            class           Everything in the class.
            x_name          str             Description of what's on the X axis.
            prop            str             A string naming the property to
                                            plot.
            units           str             The system of units the results are
                                            wanted in.  This could be "si" or
                                            "us".

        Returns:
            header_list     [str]           A list of strings of text with
                                            suitable headers to appear above
                                            each column if someone loads a curve
                                            data file into a spreadsheet.
        Errors:
            Aborts with 7101 if we need to add another entry in the
            dictionary 'print_units' below.

        '''
        # Build a set of units appropriate to each X axis name.
        print_units = {"time": ("s", "s"),
                       "distance": ("m", "ft"),
                       "timedist": ("m", "ft"),
                       "volume flow": ("m3/s", "cfm")
                      }
        try:
            (unit_SI, unit_US) = print_units[x_name.lower()]
        except KeyError:
            print('Ugh, need to add an entry for key "' + x_name.lower() + '" in\n'
                  'PROC _Colheaders in classHobyah.py.')
            err = ('> Tell the programmer that an entry for "' + x_name.lower() + '"\n'
                   '> needs to be added in Hobyahclass._Colheaders.'
                  )
            gen.WriteError(7101, err, self.log)
            gen.OopsIDidItAgain(self.log, file_name)

        # Get the two units texts for the property on the Y axis.
        loc_prop = self.properties[prop.lower()]["conversion"]
        (discard, (SI_name_wide, US_name_wide)) = USc.ConvertToSI(loc_prop, 1.0, False, "")
        SI_name = SI_name_wide.rstrip()
        US_name = US_name_wide.rstrip()
        if x_name.lower() == "timedist":
            # This type of curve can be plotted against both time and
            # distance.   Both time and distance are given in the curve
            # file, so we need both of them in the list of headers.
            # We need seven column headers.
            header_list1 = ["Time", "Distance", "Value",    # SI data
                            "Distance", "Value",            # US data
                            "Plot distance", "Plot value"]
            header_list2 = [" (s) ", "  (m)   ","(" + SI_name + ")",
                            "  (ft)  ", "(" + US_name + ")"]
            # Assume that we are plotting against distance.  If we are not,
            # then the routine that called this routine can change the entry
            # from distance to time.
            if units == "si":
                X_plot = "   (m)    "
            else:
                X_plot = "   (ft)   "
        elif x_name.lower() == "time":
            # This type of curve can only be plotted against time, so the
            # X axis values (times) in US units are the same as in SI units.
            # We only need three column headers.
            header_list1 = ["Time", "Value",    # SI data
                            "Value",            # US data
                            "Plot time", "Plot value"]
            header_list2 = [" (s) ", "(" + SI_name + ")",
                            "(" + US_name + ")"]
            X_plot = "   (s)   "
        else:
            # This type of curve is something where the X axis values in
            # SI units may differ from those in US units, such as pressure
            # versus volume flow on a fan characteristic.  We need four
            # column headers.
            header_list1 = [x_name, "Value",    # SI data
                            x_name, "Value",   # US data
                            "Plot " + x_name, "Plot value",
                          ]
            header_list2 = [" (" + unit_SI + ")",
                           " (" + SI_name + ")",
                           " (" + unit_US + ")",
                           " (" + US_name + ")",
                          ]
            # Set a relevant header for the column of X values being
            # plotted here.  The if clause below chooses between strings
            # like  "Plot volume flow (m^/s)" and "Plot volume flow (cfm)".
            if units == "si":
                X_plot = " (" + unit_SI + ")"
            else:
                X_plot = " (" + unit_US + ")"

        # Set a relevant header for the column of Y values that we plot.
        if units == "si":
            Y_plot = " (" + SI_name + ")"
        else:
            Y_plot = " (" + US_name + ")"

        header_list2.extend([X_plot, Y_plot])

        header_list = [header_list1, header_list2]
        return(header_list)


    def BuildDudBinaries(self):
        '''Take the contents of the class and write two new, faulty
        binary files from it.
        The first faulty file has the current binary file version but
        does not have a block of transient data, causing an EOF error.
        It is called by a Hobyah input file to trigger error 7022.
        The second faulty file has the current binary file version but
        does not have enough entries in its block of fixed data.  It
        is called by a Hobyah input file to trigger error 7024.
        '''
        new_name = "H-pickle-file-raise-EOF.bin"
        file = self.file_path + new_name

        with open(file, "wb") as outbin:
            pickle.dump("Hobyah.py binary version " + str(self.required),
                        outbin)
            # This next block of data must be updated when the contents
            # of the fixed block are added to in Hobyah.py.
            pickle.dump( (self.prog_type,
                          self.when_who,
                          self.file_name,
                          self.script_name,
                          self.script_date,
                          self.settings_dict2,
                          self.sectypes_dict,
                          self.tunnels_dict,
                          self.routes_dict,
                          self.fanchars_dict,
                          self.tunnelfans_dict,
                          self.JFblock_dict,
                          self.JFcalc_dict,
                          self.timedlosses_dict,
                          self.plotcontrol_dict,
                          self.tuple(aero_times),
                          self.tuple(segment_source),
                          self.tuns2segs,
                          self.tuple(segments_consts),
                          self.joins_dict,
                          self.dists,
                          self.locators,
                          self.route2segs_dict,
                          self.vehicles_dict,
                          self.vehcalc_dict,
                          self.r_traffic_dict,
                          self.t_traffic_dict,
                         ), outbin)
        print('Created new dud binary file "' + new_name + '".')

        new_name = "H-pickle-file-ends-early.hbn"
        file = self.file_path + new_name
        with open(file, "wb") as outbin:
            pickle.dump("Hobyah.py binary version " + str(self.required),
                        outbin)
            pickle.dump((self.prog_type,
                         self.when_who), outbin)
        print('Created new dud binary file "' + new_name + '".')
        return()


# Reminders about pandas databases used here:
#
#   Transient data in tunnels are pandas 2D arrays giving results in one
#   segment.  The index is plot time (float), the columns are the gridpoint
#   distances (also float).
#
#   To get all the values at one point over all plot
#   times use a slice like
#     c_oneseg[10000.]
#   where 10000. is a distance where there is a gridpoint.
#
#   To get all the values over distance at one instant
#   in time use a 'loc' slice like
#     c_oneseg.loc[102.5]
#   where 102.5 is the time of a calculation (seconds).
#
#   To get one value use a 'loc' slice with two entries
#     c_oneseg.loc[102.5, 10000.]
#
#   To get a list of the numbers used for the columns (distances) use .columns:
#     c_oneseg.columns
#
#   To get a list of the numbers used for the rows (times) use .index:
#     c_oneseg.index
#
#   To get a slice of the first column regardless of its column name
#   use iloc[:, 0].  To get a slice of the last column, use .iloc[:, -1].
#
# A list of the segment constants.  This is easier than trying to
# construct the segment data from the entries in the input file.
# Note that 'roughness' may be a negative Fanning friction factor
# instead of a roughness height in m.
#
#    segments_consts:  (area, perim, d_h, roughness,
#                       zeta_back_bf, zeta_back_fb,
#                       zeta_fwd_bf, zeta_fwd_fb,
#                       back_type, back_value, fwd_type, fwd_value,
#                       fric_const, dtdx, dx_local, numpy_count,
#                       navigable)


# The text below is useful when developing in a terminal session.
'''
import importlib
import classHobyah as clH
log = open("log_discard.txt", "w")
subf = "test-files"
hbf = clH.Hobyahdata(subf, "ok-031-fans-in-parallel.hbn", log)
hbf = clH.Hobyahdata(subf, "ok-010-manual-simple-example.hbn", log)
hbf = clH.Hobyahdata(subf, "ok-032-fans-in-parallel.hbn", log)
hbf = clH.Hobyahdata(subf, "ok-040-moving-traffic.hbn", log)

importlib.reload(clH); hbf = clH.Hobyahdata(subf, "ok-032-fans-in-parallel.hbn", log)
importlib.reload(clH); okbin = clH.Hobyahdata(subf, "ok-009.hbn", log)
This work is licensed under CC BY-SA 4.0. To view a copy of this license, visit http://creativecommons.org/licenses/by-sa/4.0/
'''

