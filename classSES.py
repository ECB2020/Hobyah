#! python3
#
# Copyright 2020-2025, Ewan Bennett
#
# All rights reserved.
#
# Released under the BSD 2-clause licence (SPDX identifier: BSD-2-Clause)
#
# email: ewanbennett@fastmail.com
#
# A class for manipulating SES data from binary files generated by the
# SESconv.py program (which processes .PRN, .TMP and .OUT files written
# out by several versions of SES).
# Note that classSES needs the Python libraries "numpy" and "pandas"
# to be installed on the machine.
#
# The class has methods for the following:
#  * getting transient data at one point in an SES geometry:
#    GetTransientData().
#
#  * getting transient data (e.g. velocity) along an SES route at one time:
#    GetProfileTransient().
#
#  * getting fixed data (e.g. perimeter) along an SES route at one time:
#    GetProfileFixed().
#
#  * getting train performance data, plottable against distance and
#    time: GetTrainData().
#
#  * writing a new SES input file from the contents stored in the
#    class: WriteInputFile().
#    Input files can be generated for SES v4.1, SVS v6.6.2, OpenSES 4.3,
#    offline-SES 204.5.
#
#  * Printing the contents of the variables in the binary file in a
#    way that makes sense to human eyes (I think): PrettyClassPrint().
#
#  * Printing a list of the names of all the variables in the binary.
#    Use self.PrettyClassPrint("x")
#
#  * Describing the variables.  For example, use self.Describe("sec_DPs")
#    to show the contents of the pandas Dataframe called sec_DPs (it
#    holds the pressure drops in sections.
#
# Most of the methods have been written in ways that make it easy
# to call them from the script "Hobyah.py", and if you are considering
# using SESconv.py for something you may want to look at that file.
#
# Various other routines exist to do ancillary stuff like checking that
# the location to plot at is valid.
#
#

import sys
import os
import math
import re                 # regular expressions
import generics as gen    # general routines
import UScustomary as USc # imperial to metric conversion
import pickle

try:
    import numpy as np
except ModuleNotFoundError:
    print("> Ugh, can't process this run because Python's\n"
          '> "numpy" library is not installed on this computer.\n'
          '> Please get your local IT guru to install it, then\n'
          '> try again.  If you are your IT guru, good luck!\n'
         )
    if __name__ == "__main__":
        # Only call sys.exit() if we are running it directly (unlikely).
        sys.exit()
try:
    import pandas as pd
except ModuleNotFoundError:
    print("> Ugh, can't process this run because Python's\n"
          '> "pandas" library is not installed on this computer.\n'
          '> Please get your local IT guru to install it, then\n'
          '> try again.  If you are your IT guru, good luck!\n'
         )
    if __name__ == "__main__":
        sys.exit()


class SESdata:
    '''A Python 3 class for holding the fixed and transient data from
    an SES run.

    It returns a class that holds the following:
    * All the fixed properties of the segments, subsegments, nodes,
      routes, fires, fans, jet fans, trains etc.
    * All the transient data of conditions in sections, segments and
      subsegments.
    * Transient data of area, velocity and volume flow in each subpoint.
      A "subpoint" may be at the back end, midpoint or forward end of a
      subsegment.
      The area, velocity and volume flow account for the presence of
      moving trains (i.e. annulus area, air velocity in the annulus,
      volume flow in the annulus: these are very handy).
    * All the transient data of train performance.
    * All the transient data for ECZ estimates (changes to wall
      temperatures and mean temperatures in uncontrolled zones,
      heat flows in controlled zones).

    Various errors are written to the screen and to the logfile.
    This class is mostly used in programs that have a logfile already
    open and which have called the class while reading a line of input;
    the error messages require a line number and line text so that when
    something goes wrong the error messages are informative.
    '''

    # Initialize the data.
    def __init__(self, bin_path, bin_name, log,
                 line_number = 1, line_text = "no line of input"):
        '''Take a folder name, a file name, an already open log file,
        an optional Boolean and a couple of arguments that can be
        used in error messages.
        Read the contents into dictionaries and pandas DataFrames.  If
        the binary file is misformed, return an error message that
        points to the line number and line text in the file that created
        the class instance.
        If the Boolean 'silentsulk' is True, the routine will not
        write an error message if it is passed the name of a Hobyah
        binary file, it will just return None.

        Parameters:
            bin_path      str       The name of a folder
            bin_name      str       The name of an .sbn file
            log           handle    The handle of a log file that is open
                                    and that the class has permission to
                                    write to.
            line_number   int       The line number that was read that
                                    prompted this call to open the file
                                    (used in error messages).  If you are
                                    using the class from an interpreter,
                                    don't include it.
            line_text     str       The text of the line being read that
                                    prompted this call to open the file
                                    (used in error messages).  If you are
                                    using the class from an interpreter,
                                    don't include it.

        Returns:
            SESdata       class     All the fixed and transient data
                                    in the .sbn file if we successfully
                                    read the file.  None if an error
                                    occurred.
        '''
        # Set the file path.  We do some cleaning up and add a trailing
        # slash if needed (I keep forgetting it when running in the
        # interpreter).
        if bin_path == '':
            # Set the current directory as the file path.
            self.bin_path = os.getcwd()
        else:
            self.bin_path = bin_path

        # Add a trailing directory separator, if needed.
        if len(self.bin_path) > 1 and self.bin_path[-1] not in  "/\\":
            self.bin_path = self.bin_path + '/'
        self.bin_name = bin_name
        self.log = log

        # Read the fixed and transient data from the file.  The routine
        # returns a value identifying if this file was read successfully or not.
        # (None if faulty, True if OK).
        self.success = self._ReadSESData()
        if self.success is None:
            return(None)
        else:
            # Make a dictionary of the settable SES options.  The result is
            # a description that can be used in error messages.  These are
            # all settings from form 1C or form 1G, now held in
            # self.settings_dict.
            # We don't include the flywheel option because when there are
            # no flywheels the flywheel values are printed as zero.
            self.opt_descrip = {"tpot":    "train performance option (form 1C)",
                                "tempopt": "temperature simulation option (form 1C)",
                                "eczopt":  "environmental control option (form 1C)",
                                "supopt":  "supplementary print option (form 1C)",
                                "firopt":  "fire simulation option (form 1G)",
                               }

            # Make a set of conversion factor names for the conversions
            # that involve Joules, as there are two types of Joule: the
            # one used by SES v4.1 and the one used by anyone writing a
            # program from scratch (the IT BTU).
            if (self.prog_type in ("SES 4.10",   # SES
                                   "SES 4.2", "SES 4.3ALPHA", "SES 4.3", # OpenSES
                                  ) or self.prog_type[:6] == "SES 20"):  # offline-SES
                # We want to use the conversion factors based on the
                # SES v4.1 BTU (1 BTU = 1054.118 J ).
                energy_fac = "v4_1energy"
                watt1_fac = "v41_watt1"
                watt2_fac = "v41_watt2"
                kwatt_fac = "v41_kwatt"
                Mwatt_fac = "v41_Mwatt"
                thcon_fac = "v41_thcon"
                specheat_fac = "v41_specheat"
                SHTC_fac = "v41_SHTC"
                SHTC2_fac = "v41_SHTC2"
                wattpua_fac = "v41_wattpua"
                wperm_fac = "v41_wperm"
            else:
                # We want to use the conversion factors involving the
                # IT BTU (1 BTU = 1055.056 J).  We use this in Hobyah
                # conversions and for SVS v6 output files (because
                # IP2SI2IP.EXE seems to use the IT BTU instead of the
                # SES v4.1 BTU.
                energy_fac = "IT_energy"
                watt1_fac = "IT_watt1"
                watt2_fac = "IT_watt2"
                kwatt_fac = "IT_kwatt"
                Mwatt_fac = "IT_Mwatt"
                thcon_fac = "IT_thcon"
                specheat_fac = "IT_specheat"
                SHTC_fac = "IT_SHTC"
                SHTC2_fac = "IT_SHTC2"
                wattpua_fac = "IT_wattpua"
                wperm_fac = "IT_wperm"


            # This class can handle a number of different versions of SES
            # and the properties that can be plotted from them varies.
            # The list below is the base set of SES versions that can
            # plot everything.  Where a new version of SES is available
            # that plots additional stuff (such as runtime jet fan thrust)
            # it is added to this base list of program types that can
            # plot the basic properties.
            basic = ["SES 4.10",
                     "OpenSES 4.2", "OpenSES 4.3",
                     "SES 204.2", "SES 204.3",
                     "SES 204.4", "SES 204.5",
                     "SES 204.6",
                     "SVS 6.6.2",
                     ]

            # Make a dictionary of requirements and data for each plot type.
            # These include the version numbers of SES that can plot them,
            # the options that must be set in an SES file in order for the
            # property to be available in the output, and a definition of
            # where the property is plotted (e.g. pressures are in sections,
            # temperatures are in subsegments, annulus air velocities are
            # in three points inside each subsegment (back end, midpoint
            # and forward end), called "subpoints".
            # This also records if they are signed (i.e. they need to be
            # multiplied by -1 if they are back-to-front in routes).
            # Temperatures are not signed, air velocities and volume
            # flows are.
            self.properties = {
                "dp":       {"versions": basic,
                             "place": "section",
                             "descrip": "total pressure",
                             "conversion": "press1",
                             "signed": True,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.sec_DPs,
                             "open_air": 0.0, # The value to plot if outside the tunnel
                             # Pressure is only available with supplementary
                             # print options 3 and 5.
                             "supopt":  (3, 5),
                            },
                "dp_indiv": {"versions": basic,
                             "place": "section",
                             "descrip": "pressure drop in sections",
                             "conversion": "press1",
                             "signed": True,
                             "transient": True,
                             "curve_types": ("profile",),
                             "var_name": self.sec_DPs,
                             "open_air": 0.0,
                             "supopt":  (3, 5),
                            },
                "qses":     {"versions": basic,
                             "place": "segment",
                             "descrip": "SES volume flow",
                             "conversion": "volflow",
                             "signed": True,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.seg_flows,
                             "open_air": 0.0,
                             # This property is always available so we
                             # have no entries for supplementary print
                             # option (unlike the previous entry, "dp").
                            },
                "vses":     {"versions": basic,
                             "place": "segment",
                             "descrip": "SES air velocity",
                             "conversion": "speed1",
                             "signed": True,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.seg_vels,
                             "open_air": 0.0,
                            },
                "wall_temp":{"versions": basic,
                             "place": "subseg",
                             "descrip": "wall temperature",
                             "conversion": "temp",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.subseg_walltemps,
                             "open_air": 0.0,
                             "tempopt": (1, 2),
                            },
                "db":       {"versions": basic,
                             "place": "subseg",
                             "descrip": "air temperature",
                             "conversion": "temp",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.subseg_temps,
                             "open_air": self.settings_dict["ext_DB"],
                             "tempopt": (1, 2),
                            },
                "w":        {"versions": basic,
                             "place": "subseg",
                             "descrip": "water content",
                             "conversion": "W",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.subseg_humids,
                             "open_air": self.settings_dict["ext_W"],
                             "tempopt": (1, 2),
                            },
                "sens":     {"versions": basic,
                             "place": "subseg",
                             "descrip": "sensible heat gain",
                             "conversion": watt1_fac,
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.subseg_sens,
                             "open_air": 0.0,
                             "tempopt": (1, 2),
                            },
                "lat":      {"versions": basic,
                             "place": "subseg",
                             "descrip": "latent heat gain",
                             "conversion": watt1_fac,
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.subseg_lat,
                             "open_air": 0.0,
                             "tempopt": (1, 2),
                            },
                "sens_pul": {"versions": basic,
                             "place": "subseg",
                             "descrip": "sensible heat gain per m", # m or ft
                             "conversion": wperm_fac,
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.subseg_sens,
                             "open_air": 0.0,
                             "tempopt": (1, 2),
                            },
                "lat_pul":  {"versions": basic,
                             "place": "subseg",
                             "descrip": "latent heat gain per m", # m or ft
                             "conversion": wperm_fac,
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.subseg_lat,
                             "open_air": 0.0,
                             "tempopt": (1, 2),
                            },
                "annulus":  {"versions": basic,
                             "place": "subpoint",
                             "descrip": "annulus area",
                             "conversion": "area",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.subpoint_areas,
                             "open_air": 0.0,
                            },
                "qcold":    {"versions": basic,
                             "place": "subpoint",
                             "descrip": "cold volume flow",
                             "conversion": "volflow",
                             "signed": True,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.subpoint_coldflows,
                             "open_air": 0.0,
                            },
                "qwarm":    {"versions": basic,
                             "place": "subpoint",
                             "descrip": "warm volume flow",
                             "conversion": "volflow",
                             "signed": True,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.subpoint_warmflows,
                             "open_air": 0.0,
                            },
                "vcold":    {"versions": basic,
                             "place": "subpoint",
                             "descrip": "cold air velocity",
                             "conversion": "speed1",
                             "signed": True,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.subpoint_coldvels,
                             "open_air": 0.0,
                            },
                "vwarm":    {"versions": basic,
                             "place": "subpoint",
                             "descrip": "warm air velocity",
                             "conversion": "speed1",
                             "signed": True,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.subpoint_warmvels,
                             "open_air": 0.0,
                            },
                # The definitions of train properties start here.
                #
                "route":    {"versions": basic,
                             "place": "train",
                             "descrip": "route of",
                             "conversion": "nulldash",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.route_num,
                             "tpopt": (1, 2, 3),
                            },
                "type":     {"versions": basic,
                             "place": "train",
                             "descrip": "type of",
                             "conversion": "nulldash",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.train_type,
                             "tpopt": (1, 2, 3),
                            },
                # Chainage is a special property in one respect, in that
                # it can only be plotted against time, not against distance.
                "chainage": {"versions": basic,
                             "place": "train",
                             "descrip": "down end chainage of",
                             "conversion": "dist1",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.train_locn,
                             "tpopt": (1, 2, 3),
                            },
                # "time" is equivalent to "chainage" above but with the
                # axes switched over.
                "time":     {"versions": basic,
                             "place": "train",
                             "descrip": "down end chainage of",
                             "conversion": "seconds",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.train_locn,
                             "tpopt": (1, 2, 3),
                            },
                "speed":    {"versions": basic,
                             "place": "train",
                             "descrip": "speed of",
                             "conversion": "speed2",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.train_speed,
                             "tpopt": (1, 2, 3),
                            },
                "qtrains":  {"versions": basic,
                             "place": "train",
                             "descrip": "volume flow of",
                             "conversion": "volflow",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.train_speed,
                             "tpopt": (1, 2, 3),
                            },
                "accel":    {"versions": basic,
                             "place": "train",
                             "descrip": "acceleration of",
                             "conversion": "accel",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.train_accel,
                             "tpopt": (1, 2, 3),
                            },
                "aerodrag": {"versions": basic,
                             "place": "train",
                             "descrip": "aero drag of",
                             "conversion": "Force1",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.train_aerodrag,
                             "tpopt": (1, 2, 3),
                            },
                "cd":       {"versions": basic,
                             "place": "train",
                             "descrip": "drag coefficient of",
                             "conversion": "nulldash",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.train_coeff,
                             "tpopt": (1, 2, 3),
                            },
                "te":       {"versions": basic,
                             "place": "train",
                             "descrip": "tractive effort of",
                             "conversion": "Force1",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.train_TE,
                             "tpopt": (1, 2, 3),
                            },
                "motoramps":{"versions": basic,
                             "place": "train",
                             "descrip": "amps/motor on",
                             "conversion": "Amotor",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.motor_amps,
                             "tpopt": (1, 2, 3),
                            },
                "lineamps": {"versions": basic,
                             "place": "train",
                             "descrip": "amps/(powered car) on",
                             "conversion": "Acar",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.line_amps,
                             "tpopt": (1, 2, 3),
                            },
                "flywh_rpm":{"versions": basic,
                             "place": "train",
                             "descrip": "flywheel speed on",
                             "conversion": "rpm",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.flywh_rpm,
                             "tpopt": (1, 2, 3),
                            },
                "acceltemp":{"versions": basic,
                             "place": "train",
                             # "descrip": "acceleration grid temp of",
                             "descrip": "temp. of traction thermal mass on",
                             "conversion": "temp",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.accel_temp,
                             "tpopt": (1, 2, 3),
                            },
                "deceltemp":{"versions": basic,
                             "place": "train",
                             # "descrip": "deceleration grid temp of",
                             "descrip": "temp. of brake thermal mass on",
                             "conversion": "temp",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.decel_temp,
                             "tpopt": (1, 2, 3),
                            },
                "pwr_all":  {"versions": basic,
                             "place": "train",
                             "descrip": "power wasted by",
                             "conversion": watt1_fac,
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.pwr_all,
                             "tpopt": (1, 2, 3),
                            },
                "heat2air": {"versions": basic,
                             "place": "train",
                             "descrip": "heat to air by",
                             "conversion": watt1_fac,
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.heat_reject,
                             "tpopt": (1, 2, 3),
                            },
                "svseffic": {"versions": ("SVS 6.6.2",),
                             "place": "train",
                             "descrip": "SVS train efficiency",
                             "conversion": "nulldash",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.train_SVSeff,
                             "tpopt": (1, 2, 3),
                            },
                "mode":     {"versions": basic,
                             "place": "train",
                             "descrip": "travel mode of", # 0 to 7, see below.
            # MODEV(NUMV)  IS THE ARRAY THAT CONTAINS THE TRAIN PERFORMANCE
            #        OPERATING MODE OF EACH TRAIN.
            #        0 = STOPPED AT A STATION
            #        1 = MAINTAINING CONSTANT SPEED
            #        2 = ACCELERATING AT FULL AVAILABLE POWER
            #        3 = BRAKING FOR EITHER A SPEED RESTRICTION OR A STATION
            #                     (VARIABLE DECELERATION RATE)
            #        4 = BRAKING FOR EITHER A SPEED RESTRICTION OR A STATION
            #                     (CONSTANT DECELERATION RATE)
            #        5 = COASTING
            #        6 = MAINTAINING MINIMUM SPEED IN A TRACK SECTION WHERE
            #                     COASTING IS PERMITTED
            #        7 = ATTEMPTING TO MAINTAIN CONSTANT MINIMUM SPEED IN A
            #                     TRACK SECTION WHERE COASTING IS PERMITTED
            # The above description is from the SES v4.1 file "Record.txt".
                             "conversion": "nulldash",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.train_modev,
                             "tpopt": (1, 2, 3),
                             # This is only available with supplementary print
                             # options 2, 3, 4 and 5.
                             "supopt":  (2, 3, 4, 5),
                            },
                "pwr_aux":  {"versions": basic,
                             "place": "train",
                             "descrip": "auxiliary power drawn by",
                             "conversion": watt1_fac,
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.pwr_aux,
                             "tpopt": (1, 2, 3),
                             # This is only available with supplementary print
                             # options 2, 3, 4 and 5.
                             "supopt":  (2, 3, 4, 5),
                            },
                "pwr_prop": {"versions": basic,
                             "place": "train",
                             "descrip": "traction power drawn by",
                             "conversion": watt1_fac,
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.pwr_prop,
                             "tpopt": (1, 2, 3),
                             # This is only available with supplementary print
                             # options 2, 3, 4 and 5.
                             "supopt":  (2, 3, 4, 5),
                            },
                "pwr_regen":{"versions": basic,
                             "place": "train",
                             "descrip": "traction power regenerated by",
                             "conversion": watt1_fac,
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.pwr_regen,
                             "tpopt": (1, 2, 3),
                             # This is only available with supplementary print
                             # options 2, 3, 4 and 5.
                             "supopt":  (2, 3, 4, 5),
                            },
                "pwr_flywh":{"versions": basic,
                             "place": "train",
                             "descrip": "power from flywheels on",
                             "conversion": watt1_fac,
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.pwr_flywh,
                             "tpopt": (1, 2, 3),
                             # This is only available with supplementary print
                             # options 2, 3, 4 and 5.
                             "supopt":  (2, 3, 4, 5),
                            },
                "pwr_accel":{"versions": basic,
                             "place": "train",
                             "descrip": "power to traction thermal mass on",
                             "conversion": watt2_fac,
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.pwr_accel,
                             "tpopt": (1, 2, 3),
                             # This is only available with supplementary print
                             # options 2, 3, 4 and 5.
                             "supopt":  (2, 3, 4, 5),
                            },
                "pwr_decel":{"versions": basic,
                             "place": "train",
                             "descrip": "power to brake thermal mass on",
                             "conversion": watt2_fac,
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.pwr_decel,
                             "tpopt": (1, 2, 3),
                             # This is only available with supplementary print
                             # options 2, 3, 4 and 5.
                             "supopt":  (2, 3, 4, 5),
                            },
                "pwr_mech": {"versions": basic,
                             "place": "train",
                             "descrip": "power to overcome mechanical losses on",
                             "conversion": watt2_fac,
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.pwr_mech,
                             "tpopt": (1, 2, 3),
                             # This is only available with supplementary print
                             # options 2, 3, 4 and 5.
                             "supopt":  (2, 3, 4, 5),
                            },
                "heat_adm":{"versions": basic,
                             "place": "train",
                             "descrip": "propulsion heat to air on",
                             "conversion": wperm_fac,
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.heat_adm,
                             "tpopt": (1, 2, 3),
                             # This is only available with supplementary print
                             # options 2, 3, 4 and 5.
                             "supopt":  (2, 3, 4, 5),
                            },
                "heat_sens":{"versions": basic,
                             "place": "train",
                             "descrip": "auxiliary sensible heat to air on",
                             "conversion": wperm_fac,
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.heat_sens,
                             "tpopt": (1, 2, 3),
                             # This is only available with supplementary print
                             # options 2, 3, 4 and 5.
                             "supopt":  (2, 3, 4, 5),
                            },
                "heat_lat": {"versions": basic,
                             "place": "train",
                             "descrip": "auxiliary latent heat to air on",
                             "conversion": wperm_fac,
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.heat_lat,
                             "tpopt": (1, 2, 3),
                             # This is only available with supplementary print
                             # options 2, 3, 4 and 5.
                             "supopt":  (2, 3, 4, 5),
                            },
                "effic1":   {"versions": basic,
                             "place": "train",
                             "descrip": "traction efficiency of",
                             "conversion": "nulldash",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.train_eff,
                             "tpopt": (1, 2, 3),
                             # Traction efficiency is only available with
                             # supplementary print options 2, 3, 4 and 5.
                             "supopt":  (2, 3, 4, 5),
                            },
                "svsregen1":{"versions": ("SVS 6.6.2",),
                             "place": "train",
                             "descrip": "SVS train regen factor on",
                             "conversion": "nulldash",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.train_SVSregen,
                             # SVS regen fraction can vary with location
                             # on a route.  It is only available with
                             # supplementary print options 2, 3, 4 and 5.
                             "supopt":  (2, 3, 4, 5),
                             "tpopt": (1, 2, 3),
                            },
                # These are annulus areas at the ends of trains and
                # pressure changes across the train ends and due to
                # train skin friction.  These are only available in
                # offline-SES 204.6.
                "dp_up":    {"versions": ("204.6",),
                             "place": "train",
                             "descrip": "pressure change at up end of",
                             "conversion": "press1",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.dP_up,
                             "tpopt": (1, 2, 3),
                             # This is only available with supplementary print
                             # options 3 and 5.
                             "supopt":  (3, 5),
                            },
                "area_up":  {"versions": ("204.6",),
                             "place": "train",
                             "descrip": "annulus area at up end of",
                             "conversion": "area",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.area_up,
                             "tpopt": (1, 2, 3),
                             # This is only available with supplementary print
                             # options 3 and 5.
                             "supopt":  (3, 5),
                            },
                "dp_skin":  {"versions": ("204.6",),
                             "place": "train",
                             "descrip": "skin friction on",
                             "conversion": "press1",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.dP_skin,
                             "tpopt": (1, 2, 3),
                             # This is only available with supplementary print
                             # options 3 and 5.
                             "supopt":  (3, 5),
                            },
                "dp_down":  {"versions": ("204.6",),
                             "place": "train",
                             "descrip": "pressure change at up end of",
                             "conversion": "press1",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.dP_down,
                             "tpopt": (1, 2, 3),
                             # This is only available with supplementary print
                             # options 3 and 5.
                             "supopt":  (3, 5),
                            },
                "area_down":{"versions": ("204.6",),
                             "place": "train",
                             "descrip": "annulus area at up end of",
                             "conversion": "area",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient",),
                             "var_name": self.area_down,
                             "tpopt": (1, 2, 3),
                             # This is only available with supplementary print
                             # options 3 and 5.
                             "supopt":  (3, 5),
                            },
                # These are the properties that return data that can be
                # used by Hobyah.py to plot icons as gnuplot objects
                # (polygons, arrows, labels) instead of curves.
                "trains":   {"versions": basic,
                             "place": "route_icons",
                             "descrip": "train icons on ",
                             "conversion": "null",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("icons",),
                             "var_name": self.train_locn,
                             "open_air": "not used",
                            },
                "fires":    {"versions": basic,
                             "place": "route_icons",
                             "descrip": "fire icons on ",
                             "conversion": "null",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("icons",),
                             "var_name": self.form4_dict,
                             "open_air": "not used",
                            },
                "jetfans":  {"versions": basic,
                             "place": "route_icons",
                             "descrip": "jet fan icons on ",
                             "conversion": "null",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("icons",),
                             "var_name": self.form3_dict,
                             "open_air": "not used",
                            },
                # These are properties that are fixed and are defined in the
                # route definitions.  Because we do not have a pandas database
                # for these, we give pointers to the dictionary keys that
                # return the relevant lists of X values and lists of Y values.
                "elevations":{"versions": basic,
                              "place": "route",
                              "descrip": "route elevations",
                              "conversion": "dist1",
                              "signed": False,
                              "transient": False,
                              "curve_types": ("profile",),
                              "complexity": "simple",
                              "var_name": self.form8_dict,
                              "x_list": "single_chs",
                              "y_list": "elevations",
                              "open_air": "not used",
                              "tpopt": (1, 2),
                             },
                "gradients":{"versions": basic,
                             "place": "route",
                             "descrip": "route gradients",
                             "conversion": "null",
                             "signed": False,
                             "transient": False,
                             "curve_types": ("profile",),
                             "complexity": "simple",
                             "var_name": self.form8_dict,
                             "x_list": "paired_chs",
                             "y_list": "gradient2",
                             "open_air": "not used",
                             # When we plot SES gradients in Hobyah we want
                             # to show fraction -1 to +1, not percentage -100
                             # to +100.  In the binary file they are stored
                              # as percentages.
                             "multiplier" : 0.01,
                             "tpopt": (1, 2),
                            },
                "stacks":   {"versions": basic,
                             "place": "route",
                             "descrip": "stack elevations",
                             "conversion": "dist1",
                             "signed": False,
                             "transient": False,
                             "curve_types": ("profile",),
                             "complexity": "simple",
                             "var_name": self.form8_dict,
                             "x_list": "seg_chs",
                             "y_list": "seg_elevs",
                             "open_air": "not used",
                            },
                "stackgrads":{"versions": basic,
                              "place": "route",
                              "descrip": "stack gradients",
                              "conversion": "null",
                              "signed": False,
                              "transient": False,
                              "curve_types": ("profile",),
                              "complexity": "simple",
                              "var_name": self.form8_dict,
                              "x_list": "stack_chs",
                              "y_list": "stack_grads",
                              # When we plot SES gradients in Hobyah we want
                              # to show fraction -1 to +1, not percentage -100
                              # to +100.  In the binary file they are stored
                              # as percentages.
                              "multiplier" : 0.01,
                              "open_air": "not used",
                             },
                "speedlimits":{"versions": basic,
                               "place": "route",
                               "descrip": "speed limits",
                               "conversion": "speed2",
                               "signed": False,
                               "transient": False,
                               "curve_types": ("profile",),
                               "complexity": "simple",
                               "var_name": self.form8_dict,
                               "x_list": "paired_chs",
                               "y_list": "speedlimit2",
                               "open_air": "not used",
                               "tpopt": (1,),
                              },
                "radius":   {"versions": basic,
                             "place": "route",
                             "descrip": "track radius",
                             "conversion": "dist1",
                             "signed": False,
                             "transient": False,
                             "curve_types": ("profile",),
                             "complexity": "simple",
                             "var_name": self.form8_dict,
                             "x_list": "paired_chs",
                             "y_list": "radius2",
                             "open_air": "not used",
                             "tpopt": (1, 2),
                            },
                "sectors":  {"versions": basic,
                             "place": "route",
                             "descrip": "track sectors",
                             "conversion": "null",
                             "signed": False,
                             "transient": False,
                             "curve_types": ("profile",),
                             "complexity": "simple",
                             "var_name": self.form8_dict,
                             "x_list": "paired_chs",
                             "y_list": "sector2",
                             "open_air": "not used",
                             "tpopt": (1, 2),
                            },
                "coasting": {"versions": basic,
                             "place": "route",
                             "descrip": "coasting rule",
                             "conversion": "null",
                             "signed": False,
                             "transient": False,
                             "curve_types": ("profile",),
                             "complexity": "simple",
                             "var_name": self.form8_dict,
                             "x_list": "paired_chs",
                             "y_list": "coasting2",
                             "open_air": "not used",
                             "tpopt": (1,),
                            },
                # SVS has route-based regen braking factor, given as
                # a fraction 0-1 (form 8C) and a train-based regen factor
                # (form 9H-A).  If the former is zero at a given train
                # chainage, the latter is used.  The result is multiplied
                # by the train's regenerative braking effectiveness (which,
                # rather confusingly, is given as a percentage instead
                # of a fraction) to give the total fraction of regen
                # power in a given track section.
                # The following plot ("SVSregen2") is of the first of these
                # only.  Plot type "SVSregen1" (plotted on trains) gives
                # the combined result of the entries in forms 8C and
                # 9H-A, plotted against train chainage or against time.
                "svsregen2":{"versions": ("SVS 6.6.2",),
                             "place": "route",
                             "descrip": "SVS track regen factor",
                             "conversion": "null",
                             "signed": False,
                             "transient": False,
                             "curve_types": ("profile",),
                             "complexity": "simple",
                             "var_name": self.form8_dict,
                             "x_list": "paired_chs",
                             "y_list": "regen2",
                             "open_air": "not used",
                             "tpopt": (1, 2),
                            },
                "sections": {"versions": basic,
                             "place": "route",
                             "descrip": "section numbers",
                             "conversion": "null",
                             "signed": False,
                             "transient": False,
                             "curve_types": ("profile",),
                             "complexity": "double_up1",
                             "var_name": self.form8_dict,
                             "x_list": "sec_chs",
                             "y_list": "sec_list",
                             "open_air": "not used",
                            },
                "segments": {"versions": basic,
                             "place": "route",
                             "descrip": "segment numbers",
                             "conversion": "null",
                             "signed": False,
                             "transient": False,
                             "curve_types": ("profile",),
                             "complexity": "double_up1",
                             "var_name": self.form8_dict,
                             "x_list": "seg_chs",
                             "y_list": "seg_list",
                             "open_air": "not used",
                            },
                "subsegs":  {"versions": basic,
                             "place": "route",
                             "descrip": "count of subsegments",
                             "conversion": "null",
                             "signed": False,
                             "transient": False,
                             "curve_types": ("profile",),
                              "complexity": "double_up2",
                             "var_name": self.form8_dict,
                             "x_list": "seg_chs",
                             "y_list": "seg_nums",
                             "sub_dict": self.form3_dict,
                             "sub_key": "subsegs",
                             "open_air": "not used",
                            },
                "sublength": {"versions": basic,
                              "place": "route",
                              "descrip": "subsegment length",
                              "conversion": "dist1",
                              "signed": False,
                              "transient": False,
                              "curve_types": ("profile",),
                              "complexity": "double_up2",
                              "var_name": self.form8_dict,
                              "x_list": "seg_chs",
                              "y_list": "seg_nums",
                              "sub_dict": self.form3_dict,
                              "sub_key": "sublength",
                              "open_air": "not used",
                             },
                # This next keyword is the area in the segment definitions.
                # If you want to see the area change as trains move through
                # the tunnels, use the "annulus" keyword instead.
                "area":     {"versions": basic,
                             "place": "route",
                             "descrip": "segment areas",
                             "conversion": "area",
                             "signed": False,
                             "transient": False,
                             "curve_types": ("profile",),
                             "complexity": "double_up2",
                             "var_name": self.form8_dict,
                             "x_list": "seg_chs",
                             "y_list": "seg_nums",
                             "sub_dict": self.form3_dict,
                             "sub_key": "area",
                             "open_air": "not used",
                            },
                "fireseg":  {"versions": basic,
                             "place": "route",
                             "descrip": "fire segments",
                             "conversion": "null",
                             "signed": False,
                             "transient": False,
                             "curve_types": ("profile",),
                             "complexity": "double_up2",
                             "var_name": self.form8_dict,
                             "x_list": "seg_chs",
                             "y_list": "seg_nums",
                             "sub_dict": self.form3_dict,
                             "sub_key": "fireseg",
                             "open_air": "not used",
                            },
                "perimeter":{"versions": basic,
                             "place": "route",
                             "descrip": "segment perimeters",
                             "conversion": "dist1",
                             "signed": False,
                             "transient": False,
                             "curve_types": ("profile",),
                             "complexity": "double_up2",
                             "var_name": self.form8_dict,
                             "x_list": "seg_chs",
                             "y_list": "seg_nums",
                             "sub_dict": self.form3_dict,
                             "sub_key": "perim",
                             "open_air": "not used",
                            },
                "roughness":{"versions": basic,
                             "place": "route",
                             "descrip": "segment mean roughnesses",
                             "conversion": "dist1",
                             "signed": False,
                             "transient": False,
                             "curve_types": ("profile",),
                             "complexity": "double_up2",
                             "var_name": self.form8_dict,
                             "x_list": "seg_chs",
                             "y_list": "seg_nums",
                             "sub_dict": self.form3_dict,
                             "sub_key": "perim",
                             # SES stores roughness in mm, Hobyah stores
                             # it in m.  We want a consistent display (m)
                             # so we include a multiplier of 0.001 here.
                             "multiplier" : 0.001,
                             "open_air": "not used",
                            },
                # Darcy friction factor (four times Fanning friction factor).
                # Darcy friction factor is what SES uses, so this is what we
                # stored in the binary file.
                "darcy":    {"versions": basic,
                             "place": "route",
                             "descrip": "Darcy friction factors",
                             "conversion": "null",
                             "signed": False,
                             "transient": False,
                             "curve_types": ("profile",),
                             "complexity": "double_up2",
                             "var_name": self.form8_dict,
                             "x_list": "seg_chs",
                             "y_list": "seg_nums",
                             "sub_dict": self.form3_dict,
                             "sub_key": "darcy",
                             "open_air": "not used",
                            },
                # Fanning friction factor (one quarter of Darcy friction factor).
                # We use a multiplier of 0.25 to get it.
                "fanning":  {"versions": basic,
                             "place": "route",
                             "descrip": "Fanning friction factors",
                             "conversion": "null",
                             "signed": False,
                             "transient": False,
                             "curve_types": ("profile",),
                             "complexity": "double_up2",
                             "var_name": self.form8_dict,
                             "x_list": "seg_chs",
                             "y_list": "seg_nums",
                             "sub_dict": self.form3_dict,
                             "sub_key": "darcy",
                             "multiplier" : 0.25,
                             "open_air": "not used",
                            },
                "wetted":   {"versions": basic,
                             "place": "route",
                             "descrip": "wetted perimeter %age",
                             "conversion": "null",
                             "signed": False,
                             "transient": False,
                             "curve_types": ("profile",),
                             "complexity": "double_up2",
                             "var_name": self.form8_dict,
                             "x_list": "seg_chs",
                             "y_list": "seg_nums",
                             "sub_dict": self.form3_dict,
                             "sub_key": "wetted",
                             "open_air": "not used",
                            },
                # This next set of plots are mean values in uncontrolled
                # zones (means over the time duration of an ECZ estimate).
                "meandb_am":{"versions": basic,
                             "place": "subseg",
                             "descrip": "AM design hour mean air temperature",
                             "conversion": "temp",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.airT_AM,
                             "open_air": self.settings_dict["ext_DB"],
                             "tempopt": (1, 2),
                             "ECZopt": (1, 2),
                            },
                "meandb_pm":{"versions": basic,
                             "place": "subseg",
                             "descrip": "PM design hour mean air temperature",
                             "conversion": "temp",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.airT_PM,
                             "open_air": self.settings_dict["ext_DB"],
                             "tempopt": (1, 2),
                             "ECZopt": (1, 2),
                            },
                "meandb_off":{"versions": basic,
                             "place": "subseg",
                             "descrip": self.settings_dict["design_time"] + \
                                        " (off hour) mean air temperature",
                             "conversion": "temp",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.airT_off,
                             "open_air": self.settings_dict["ext_DB"],
                             "tempopt": (1, 2),
                             "ECZopt": (2,),
                            },
                "meanw_am": {"versions": basic,
                             "place": "subseg",
                             "descrip": "AM design hour mean humidity ratio",
                             "conversion": "temp",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.airW_AM,
                             "open_air": self.settings_dict["ext_W"],
                             "tempopt": (1, 2),
                             "ECZopt": (1, 2),
                            },
                "meanw_pm": {"versions": basic,
                             "place": "subseg",
                             "descrip": "PM design hour mean humidity ratio",
                             "conversion": "temp",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.airW_PM,
                             "open_air": self.settings_dict["ext_W"],
                             "tempopt": (1, 2),
                             "ECZopt": (1, 2),
                            },
                "meanw_off":{"versions": basic,
                             "place": "subseg",
                             "descrip": self.settings_dict["design_time"] + \
                                        " (off hour) mean humidity ratio",
                             "conversion": "temp",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.airW_off,
                             "open_air": self.settings_dict["ext_W"],
                             "tempopt": (1, 2),
                             "ECZopt": (2,),
                            },
                "wallt_am": {"versions": basic,
                             "place": "subseg",
                             "descrip": "AM design hour wall temperature",
                             "conversion": "temp",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.wallT_AM,
                             "open_air": 0.0,
                             "tempopt": (1, 2),
                             "ECZopt": (1, 2),
                            },
                "wallt_pm": {"versions": basic,
                             "place": "subseg",
                             "descrip": "PM design hour wall temperature",
                             "conversion": "temp",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.wallT_AM,
                             "open_air": 0.0,
                             "tempopt": (1, 2),
                             "ECZopt": (1, 2),
                            },
                # This next is actually pretty useless, because the
                # same data has been copied into 'wall_temp' at each
                # print timestep.  Its only advantage is that it has
                # a better description.  Note that the entry here for
                # "descrip" gets changed below if the run does ECZ
                # estimates (to "AM hour...", "PM hour..." or
                # "off-hour...").
                "wallt_used": {"versions": basic,
                             "place": "subseg",
                             "descrip": "design hour wall temperature",
                             "conversion": "temp",
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.wallT_used,
                             "open_air": 0.0,
                             "tempopt": (1, 2),
                             "ECZopt": (1, 2),
                            },
                "misc_sens":{"versions": basic,
                             "place": "subseg",
                             "descrip": "sensible heat from trains/misc",
                             "conversion": kwatt_fac,
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.misc_sens,
                             "open_air": 0.0,
                             "tempopt": (1, 2),
                             "ECZopt": (1, 2),
                            },
               "misc_lat":{"versions": basic,
                             "place": "subseg",
                             "descrip": "latent heat from trains/misc",
                             "conversion": kwatt_fac,
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.misc_lat,
                             "open_air": 0.0,
                             "tempopt": (1, 2),
                             "ECZopt": (1, 2),
                            },
                "steady_sens":{"versions": basic,
                             "place": "subseg",
                             "descrip": "sensible heat from fixed equipment",
                             "conversion": kwatt_fac,
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.steady_sens,
                             "open_air": 0.0,
                             "tempopt": (1, 2),
                             "ECZopt": (1, 2),
                            },
               "steady_lat":{"versions": basic,
                             "place": "subseg",
                             "descrip": "latent heat from fixed equipment",
                             "conversion": kwatt_fac,
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.steady_lat,
                             "open_air": 0.0,
                             "tempopt": (1, 2),
                             "ECZopt": (1, 2),
                            },
                "ground_sens":{"versions": basic,
                             "place": "subseg",
                             "descrip": "sensible heat from the ground",
                             "conversion": kwatt_fac,
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.ground_sens,
                             "open_air": 0.0,
                             "tempopt": (1, 2),
                             "ECZopt": (1, 2),
                            },
                "airex_sens":{"versions": basic,
                             "place": "subseg",
                             "descrip": "sensible heat from air exchange",
                             "conversion": kwatt_fac,
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.airex_sens,
                             "open_air": 0.0,
                             "tempopt": (1, 2),
                             "ECZopt": (1, 2),
                            },
               "airex_lat":{"versions": basic,
                             "place": "subseg",
                             "descrip": "latent heat from air exchange",
                             "conversion": kwatt_fac,
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.airex_lat,
                             "open_air": 0.0,
                             "tempopt": (1, 2),
                             "ECZopt": (1, 2),
                            },
                "hvac_sens":{"versions": basic,
                             "place": "subseg",
                             "descrip": "sensible heat from air conditioning",
                             "conversion": kwatt_fac,
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.hVAC_sens,
                             "open_air": 0.0,
                             "tempopt": (1, 2),
                             "ECZopt": (1, 2),
                            },
               "hvac_lat":{"versions": basic,
                             "place": "subseg",
                             "descrip": "latent heat from air conditioning",
                             "conversion": kwatt_fac,
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.hVAC_lat,
                             "open_air": 0.0,
                             "tempopt": (1, 2),
                             "ECZopt": (1, 2),
                            },
               "hvac_tot":{"versions": basic,
                             "place": "subseg",
                             "descrip": "total heat from air conditioning",
                             "conversion": kwatt_fac,
                             "signed": False,
                             "transient": True,
                             "curve_types": ("transient", "profile"),
                             "var_name": self.hVAC_total,
                             "open_air": 0.0,
                             "tempopt": (1, 2),
                             "ECZopt": (1, 2),
                            },
                # These next two are the runtime SVS cooling pipe properties
                # printed at each timestep.  These store values only in the
                # subsegments that each pipe runs through.  The variables
                # are a list of pandas DataFrames, one per cooling pipe.
                # They are commented out because the code to plot along
                # pipes and in routes hasn't been written yet.
                # "pipetemp": {"versions": ("SVS 6.6.2",),
                #              "place": "pipe",
                #              "descrip": "cooling pipe temperature",
                #              "conversion": "temp",
                #              "signed": False,
                #              "transient": True,
                #              "curve_types": ("transient", "profile",),
                #              "complexity": "simple",
                #              "var_name": self.coolpipe_temps,
                #              "curve_types": ("transient", "profile"),
                #              "open_air": 0.0,
                #             },
                # "pipe_ht": {"versions": ("SVS 6.6.2",),
                #              "place": "pipe",
                #              "descrip": "pipe heat transfer",
                #              "conversion": watt1_fac,
                #              "signed": False,
                #              "transient": True,
                #              "curve_types": ("transient", "profile",),
                #              "complexity": "simple",
                #              "var_name": self.coolpipe_HT,
                #              "open_air": 0.0,
                #             },
                # The rest of the entries are used to trigger various
                # error messages that are otherwise impossible to get to.
                "_t5042":   {"versions": ("SES 504.2",), # Used to trigger error 5042
                            },
                "_t5043":   {"versions": basic,
                             "place": "subpoint",
                             "descrip": "made-up curve type to trigger an error",
                             "conversion": "nulldash",
                             "curve_types": ("velleity",), # Used to trigger error 5043
                            },
                "_t50836":  {"versions": basic,
                             "place": "nullplace", # Used to trigger 5083 & 5086
                             "descrip": "made-up curve type to trigger an error",
                             "conversion": "nulldash",
                             "curve_types": ("transient", "profile"),
                            },
                "_t5090":   {"versions": basic,
                             "place": "subpoint", # Triggers error 5090 via an if clause
                             "descrip": "made-up curve type to trigger an error",
                             "conversion": "nulldash",
                             "curve_types": ("transient", "profile"),
                            },
                "_t5093":   {"versions": basic,
                             "place": "subpoint", # Triggers error 5093 via an if clause
                             "descrip": "made-up curve type to trigger an error",
                             "conversion": "nulldash",
                             "curve_types": ("transient", "profile"),
                            },
                "_t5096":   {"versions": basic,
                             "place": "subpoint", # Triggers error 5096 via an if clause
                             "descrip": "made-up curve type to trigger an error",
                             "conversion": "nulldash",
                             "curve_types": ("transient", "profile"),
                            },
                        }

            # Now add negative versions for the pressure, flows and velocities.
            # These are all multiplied by -1 when the values are generated.
            for new_key in ("-dp", "-qses", "-vses",
                        "-qcold", "-qwarm", "-vcold", "-vwarm"):
                self.properties.__setitem__(new_key,self.properties[new_key[1:]])

            # ECZ estimates are one of the most confusing things about
            # SES; I suspect partly because the authors didn't manage
            # to do everything they wanted with it before time ran out.
            # The following adjustments to the curve descriptions are
            # based on my understanding of the differences between
            # the ECZ AM peak hour and PM peak hour estimates.  I may
            # well be wrong; if you know something that I don't, I'd
            # be interested to hear about it.
            ECZopt = self.settings_dict["ECZopt"]
            if ECZopt in (1, 2):
                # Change the descriptions in the key for design hour wall
                # temperature to text that reflects the kind of ECZ estimate
                # being carried out in this run.
                if ECZopt == 1:
                    if self.settings_dict["hour"] < 12.0:
                        self.properties["wallt_used"]["descrip"] = "AM design hour wall temperature"
                        # This is a run in which the ECZ estimates are for
                        # the morning peak hour.  Change the autokeys
                        # of the PM peak hour mean values and the off-hour
                        # mean values to state that they are not valid.
                        # If you're doing a morning peak hour ECZ estimate,
                        # you should not be plotting off-hour or evening
                        # peak hour temperatures and expect them to give
                        # you valid data (see Section 5.10 of the SES v4.1
                        # User's Manual for details).
                        self.properties["wallt_pm"]["descrip"] = "non-valid PM wall temperature"
                        self.properties["meandb_pm"]["descrip"] = "non-valid PM mean air temperature"
                        self.properties["meanw_pm"]["descrip"] = "non-valid PM mean air humidity"
                        self.properties["meandb_off"]["descrip"] = "non-valid off-hour mean air temperature"
                        self.properties["meanw_off"]["descrip"] = "non-valid off-hour mean air humidity"
                    else:
                        self.properties["wallt_used"]["descrip"] = "PM design hour wall temperature"
                        # It's an evening peak hour estimate.  Trash the
                        # descriptions of the morning peak and off-hour
                        # plot types.
                        self.properties["wallt_am"]["descrip"] = "non-valid AM wall temperature"
                        self.properties["meandb_am"]["descrip"] = "non-valid AM mean air temperature"
                        self.properties["meanw_am"]["descrip"] = "non-valid AM mean air humidity"
                        self.properties["meandb_off"]["descrip"] = "non-valid off-hour mean air temperature"
                        self.properties["meanw_off"]["descrip"] = "non-valid off-hour mean air humidity"
                else:
                    newdesc = self.settings_dict["design_time"]  \
                              + " (off hour) wall temperature"
                    self.properties["wallt_used"]["descrip"] = newdesc
                    # It's an off hour estimate.  Trash the descriptions
                    # of the morning and evening peaks plot types.
                    self.properties["wallt_am"]["descrip"] = "non-valid AM wall temperature"
                    self.properties["meandb_am"]["descrip"] = "non-valid AM mean air temperature"
                    self.properties["meanw_am"]["descrip"] = "non-valid AM mean air humidity"
                    self.properties["wallt_pm"]["descrip"] = "non-valid PM wall temperature"
                    self.properties["meandb_pm"]["descrip"] = "non-valid PM mean air temperature"
                    self.properties["meanw_pm"]["descrip"] = "non-valid PM mean air humidity"


    def _ReadSESData(self):
        '''Read the fixed and transient data in the pickle file and return
           the data in it.

        Parameters:
            self          class     Literally everything in the class.

        Returns:
            Generates lists, dictionaries and pandas DataFrames of the
            runtime data.  Too many to list and constantly changing so
            see the code below.

        Errors:
            Aborts with 5001 if the filename is empty (can only happen
            called directly in an IDE).
            Aborts with 5002 if the first pickled item we read was not
            a string (it should be a version string along the lines of
            "SESconv.py binary version 3" or "SESconv.py binary version 42".
            Aborts with 5003 if the first pickled item we read started
            with "Hobyah.py binary version ".
            Aborts with 5004 if the first pickled item we read was a
            string but didn't start with "SESconv.py binary version " and
            end with an integer.
            Aborts with 5005 if the binary file's version was too low.
            Aborts with 5006 if the binary file's version was too high.
            Aborts with 5007 if the file doesn't exist.
            Aborts with 5008 if we don't have permission to read the file.

        Returns:
            None if an error occurred, True if all was well.
        '''

        if self.bin_name == "":
            # The name of the binary file is empty.  Complain and return.
            err = ("> The name of the binary file is blank.  The path is\n"
                   '> "' + self.bin_path + '".'
                  )
            gen.WriteError(5001, err, self.log)
            return(None)
        try:
            with open(self.bin_path + self.bin_name,'rb') as pkl:
                # Read the binary file version string and check it is
                # not too high and not too low.
                result = self._UnPickleData("the binary file version", 0, pkl)
                if result is None:
                    # We fouled up somehow.
                    return(None)
                else:
                    self.binversion_string = result

                # Now check the binary file version string.  We want it to
                # be a string like "SESconv.py binary version 3".  First
                # we complain if it is not a string, then check its contents
                # then we check for lower versions (no good) and higher
                # versions (also no good).
                if type(self.binversion_string) is not str:
                    # First get a suitable slice of whatever we have here,
                    # it might be helpful in tracing the error.  We turn
                    # it into a string and take the first 60 characters.
                    text = str(self.binversion_string).lstrip().rstrip()
                    if len(text) > 60:
                        text = text[:57] + "..."
                        class_text = str(type(self.binversion_string))[1:-1] + " and started\n> with:"
                    else:
                        class_text = str(type(self.binversion_string))[1:-1] + " and contained:"
                    err = ('> A binary file has a version string (the\n'
                           '> first thing in the binary file) that was\n'
                           '> not a string.  The .sbn file was probably\n'
                           '> not created by SESconv.py.\n'
                           '> The version string should have been some-\n'
                           '> thing like "SESconv.py binary version 12",\n'
                           '> but it was of ' + class_text + '\n'
                           '>    "' + text + '"\n'
                           '> The faulty file is "' + self.bin_name + '".'
                          )
                    gen.WriteError(5002, err, self.log)
                    return(None)

                # If we get to here we have a string.  Check it.  We want
                # it to be something like "SESconv.py binary version 3".  First
                # set a Boolean and split the string.
                dud = False
                parts = result.split()
                if result[:25] == "Hobyah.py binary version ":
                    # This is not a suitable file to be loaded into
                    # classSES, as it has all the fingerprints of a
                    # file intended for classHobyah.  Someone probably
                    # renamed a file so it ends with ".sbn" instead
                    # of ".hbn".
                    err = ('> A binary file has a version string (the\n'
                           '> first thing in the binary file) that\n'
                           '> looks like a Hobyah.py version string,\n'
                           '> not an SESconv.py version string.\n'
                           '> The version string should have been some-\n'
                           '> thing like "SESconv.py binary version 12",\n'
                           '> but it was\n'
                           '>    "' + result + '"\n'
                           '> Someone probably renamed a Hobyah.py\n'
                           '> ".hbn" file to end with ".sbn" instead.\n'
                           '> The faulty file is "' + self.bin_name + '".'
                          )
                    gen.WriteError(5003, err, self.log)
                    return(None)
                elif result[:26] != "SESconv.py binary version ":
                    # The first three words were incorrect.
                    dud = True
                elif len(parts) != 4:
                    # It had too many words in it.
                    dud = True
                elif not (parts[3].isdecimal()):
                    # The fourth word is not all digits.
                    dud = True

                if dud:
                    # The routine that called this class was probably
                    # not Hobyah.py.  Complain about the first string
                    # being wrong.
                    # Get a shortish slice of the string for the error
                    # message, as it could be enormous.  We take the
                    # first 60 characters or the first 57 and add an
                    # ellipsis.
                    if len(result) <= 60:
                        text = result
                    else:
                        text = result[:57] + "..."
                    err = ('> A binary file has a version string that\n'
                           "> didn't match the required form (the words\n"
                           '> "SESconv.py binary version XX") where XX is\n'
                           '> an integer.  Instead it was\n'
                           '>   "' + text + '"\n'
                           '> The faulty file is "' + self.bin_name + '".\n'
                           '> It was not created by SESconv.py, it just\n'
                           '> happens to be a pickle file that started\n'
                           '> with a string.'
                          )
                    gen.WriteError(5004, err, self.log)
                    return(None)
                else:
                    # This does look like a SESconv binary file.  Get the
                    # version as a number.  We don't have to try...catch
                    # this as we already checked that the fourth word is
                    # all digits.
                    self.binversion = int(parts[3])

                # Now check the version number.  The entry below is the version
                # number that this version of the class can handle.
                required = 12
                if self.binversion < required:
                    err = ('> A binary file has a version number that is\n'
                           '> too old for this program to process correctly.\n'
                           '> The file is of binary version ' + str(self.binversion)
                             + ' and this\n'
                           '> program can only handle files of version ' + str(required) + '.\n'
                           '> Please reprocess the SES output file with a\n'
                           '> version of SESconv.py that generates binary\n'
                           '> files of version ' + str(required) + '.\n'
                           '> The faulty file is "' + self.bin_name + '".'
                          )
                    gen.WriteError(5005, err, self.log)
                    return(None)
                elif self.binversion > required:
                    err = ('> A binary file has a version number that is\n'
                           '> too new for this program to process correctly.\n'
                           '> The file is of binary version ' + str(self.binversion)
                             + ' and this\n'
                           '> program can only handle files of version ' + str(required) + '.\n'
                           '> Please update your version of this program\n'
                           '> and its dependent modules.\n'
                           '> The faulty file is "' + self.bin_name + '".'
                          )
                    gen.WriteError(5006, err, self.log)
                    return(None)

                # Read the fixed data, giving the expected count of entries.
                # When this changes, we need to update the counter, the list
                # in the 'else' clause below and the list in the procedure
                # PrettyClassPrint.

                count = 25
                self.fixed_data = self._UnPickleData("the fixed data", count, pkl)
                if self.fixed_data is None:
                    return(None)
                else:
                    # Unpack 'count' entries to their correct variables.
                    (self.prog_type,
                     self.when_who,
                     self.prn_name,    # Name of the .PRN, .OUT or .TMP file
                     self.script_name, # Name of the script that created this
                     self.script_date, # Date the script was last edited
                     self.header,
                     self.footer,
                     self.comments,
                     self.settings_dict, # Forms 1B to 1G
                     self.form2_dict,
                     self.form3_dict,
                     self.form4_dict,
                     self.form5_dict,
                     self.sec_seg_dict,
                     self.form6_dict,
                     self.form7_fans,
                     self.form7_JFs,
                     self.form7D,
                     self.form8_dict,
                     self.form9_dict,
                     self.form10_dict,
                     self.form11_dict,
                     self.form12_dict,
                     self.form13_dict,
                     self.form14_dict) = self.fixed_data

                    # Convert the version number into a program type
                    # with the appropriate program prefix.  SESconv.py
                    # added "SES ", here we add the necessary prefix.
                    if self.prog_type in ("SES 4.2", "SES 4.3"):
                        # It's an OpenSES file.
                        self.full_prog = "Open" + self.prog_type
                    elif "SES 20" in self.prog_type:
                        # It's offline-SES file (version numbers are
                        # 204.2, 204.3 etc.
                        self.full_prog = "offline-" + self.prog_type
                    else:
                        # It's an SES or SVS file.
                        self.full_prog = self.prog_type


                    # Get the name of the SES input file from the footer.
                    # SVS needs the slice to start later than SES.
                    if self.prog_type in ("SVS 6.6.2", ):
                        candidate = self.footer[7:78].strip()
                    else:
                        # This works even if it is a spoofed footer from data
                        # in SES v4.2.
                        candidate = self.footer[5:78].strip()
                    # Look for the last instance of a forward slash
                    foldersep = candidate.rfind('/')
                    if foldersep != -1:
                        # We found a forward slash.
                        self.runfile_name = candidate[foldersep + 1:]
                    else:
                        # Try again, this time looking for a backslash.
                        foldersep = candidate.rfind('\\')
                        if foldersep != -1:
                            # We found a backslash.
                            self.runfile_name = candidate[foldersep + 1:]
                        else:
                            # The whole string is the SES input file name.
                            self.runfile_name = candidate

                # Read the transient data from the SES sbn file.
                # When this changes, we need to update the counter, the list
                # in the 'else' clause below and the list in the procedure
                # PrettyClassPrint.
                count = 76
                self.transient_data = self._UnPickleData("the transient data",
                                                         count, pkl)

                if self.transient_data is None:
                    return(None)
                else:
                    (self.subseg_names,
                     self.subpoint_keys,
                     self.print_times,
                     self.ECZ_times,
                     self.ECZ_indices,
                     self.sec_DPs,
                     self.seg_flows,
                     self.seg_vels,
                     self.subseg_walltemps,
                     self.subseg_temps,
                     self.subseg_humids,
                     self.subseg_sens,
                     self.subseg_lat,
                     self.subseg_denscorr,
                     self.seg_meandenscorr,
                     self.subpoint_areas,
                     self.subpoint_trainflows,
                     self.subpoint_coldflows,
                     self.subpoint_warmflows,
                     self.subpoint_coldvels,
                     self.subpoint_warmvels,
                     self.route_num,
                     self.train_type,
                     self.train_locn,
                     self.train_speed,
                     self.train_accel,
                     self.train_aerodrag,
                     self.train_coeff,
                     self.train_TE,
                     self.motor_amps,
                     self.line_amps,
                     self.flywh_rpm,
                     self.accel_temp,
                     self.decel_temp,
                     self.pwr_all,
                     self.heat_reject,
                     self.train_modev,
                     self.pwr_aux,
                     self.pwr_prop,
                     self.pwr_regen,
                     self.pwr_flywh,
                     self.pwr_accel,
                     self.pwr_decel,
                     self.pwr_mech,
                     self.heat_adm, # ADM = Accel, Decel & Mechanical
                     self.heat_sens, # heat from trains, not in zones
                     self.heat_lat,
                     self.train_eff,
                     self.train_SVSeff,
                     self.train_SVSregen,
                     self.dP_up,
                     self.area_up,
                     self.dP_skin,
                     self.dP_down,
                     self.area_down,
                     self.airT_AM,
                     self.airW_AM,
                     self.wallT_AM,
                     self.airT_PM,
                     self.airW_PM,
                     self.wallT_PM,
                     self.airT_off,
                     self.airW_off,
                     self.wallT_used,
                     self.misc_sens,
                     self.misc_lat,
                     self.steady_sens,
                     self.steady_lat,
                     self.ground_sens,
                     self.airex_sens,
                     self.airex_lat,
                     self.hVAC_sens,
                     self.hVAC_lat,
                     self.hVAC_total,
                     self.coolpipe_temps,
                     self.coolpipe_HT,
                    ) = self.transient_data
        except FileNotFoundError:
            # The binary file doesn't exist.  Complain and return.
            err = ("> A binary file does not exist.  The missing\n"
                   '> file is "' + self.bin_name + '" in folder\n'
                   '> "' + self.bin_path + '".'
                  )
            gen.WriteError(5007, err, self.log)
            return(None)
        except PermissionError:
            # The binary file exists but we don't have permission to
            # read it.  Complain and return.
            err = ("> A binary file has its permissions set\n"
                   "> so that you can't read the file.  The\n"
                   '> locked file is "' + self.bin_name + '".'
                  )
            gen.WriteError(5008, err, self.log)
            return(None)
        return(True)


    def _CheckSegNumber(self, seg_num, where, file_name, line_number, line_text):
        '''Take a segment number and check if it is in this SES file.  Raise
        an error if it is not.

        Parameters:
            self            class       Literally everything in the class.
            seg_num         str         String giving a segment number.
            where           str         A string defining where to plot.
            file_name       str         The name of the file being processed
                                        when this routine was called.  Used
                                        in error messages.  Not the name of
                                        the SES file being plotted from.
            line_number     int         The line number being processed.
                                        Used in error messages.
            line_text       str         The text of the line being
                                        processed.  Used in error messages.


        Returns:
            True if the segment is in the file, None if it is not.


        Errors:
            Aborts with 5101 if the segment is not present in the SES file.
        '''
        # Get all the integer keys in sec_seg_dict (a list of line and vent
        # segments combined).
        seg_list = [key for key in self.sec_seg_dict if type(key) is int]
        if int(seg_num) not in seg_list:
            # Sort the list of the segment numbers in this file then write
            # a suitable error message.
            seg_list.sort()
            seg_text = [str(seg_num) for seg_num in seg_list]
            err = ('> Tried to plot a curve in "' + file_name + '",\n'
                   '> but found that the identifier "' + where + '"\n'
                   '> referenced a segment (' + seg_num + ') that is not in \n'
                   '> SES file "' + self.runfile_name + '".\n'
                   '> Please edit the file to correct this.\n'
                   '> For what it is worth this is a list of\n'
                   '> the segment number(s) used in that file:\n'
                     + gen.FormatOnLines(seg_text)
                   )
            gen.WriteError(5101, err, self.log)
            gen.ErrorOnLine(line_number, line_text, self.log, False)
            return(None)
        return(True)


    def _CheckSubNumber(self, seg_num, sub_num, where,
                        file_name, line_number, line_text):
        '''Take a segment number and check if it is in this SES file.  Raise
        an error if it is not.

        Parameters:
            self            class       Literally everything in the class.
            seg_num         str         String giving a segment number.
            sub_num         str         String representing a subsegment
                                        number.
            where           str         A string defining where to plot.
            file_name       str         The name of the file being processed
                                        when this routine was called.  Used
                                        in error messages.  Not the name of
                                        the SES file being plotted from.
            line_number     int         The line number being processed.
                                        Used in error messages.
            line_text       str         The text of the line being
                                        processed.  Used in error messages.


        Returns:
            True if the segment is in the file, None if it is not.


        Errors:
            Aborts with 5121 if the subsegment is not present in the segment
            in the SES file.
        '''
        # Assume that we have already checked that the segment number exists
        # in the file.  Get the count of subsegments from the form 3 dictionary
        # or the form 5 dictionary.
        try:
            subsegs = self.form3_dict[int(seg_num)]["subsegs"]
        except KeyError:
            subsegs = self.form5_dict[int(seg_num)]["subsegs"]

        sub_wanted = int(sub_num)
        if int(sub_num) < 1 or int(sub_num) > subsegs:
            err = ('> Tried to plot a curve in "' + file_name + '",\n'
                   '> but found that the identifier "' + where + '"\n'
                   '> referenced a subsegment (' + sub_num + ') that does not\n'
                   '> exist in SES file "' + self.runfile_name + '".\n'
                   '> Segment ' + seg_num + ' has subsegments numbered from\n'
                   '> 1 to ' + str(subsegs) + '.\n'
                   '> Please edit the file to correct the\n'
                   '> subsegment number.'
                   )
            gen.WriteError(5121, err, self.log)
            gen.ErrorOnLine(line_number, line_text, self.log, False)
            return(None)
        return(True)


    def _CheckSecNumber(self, sec_num, where, file_name, line_number, line_text):
        '''Take a section number and check if it is in this SES file.  Raise
        an error if it is not.

        Parameters:
            self            class       Literally everything in the class.
            sec_num         str         String with "sec" and a section
                                        number.
            where           str         A string defining where to plot.
            file_name       str         The name of the file being processed
                                        when this routine was called.  Used
                                        in error messages.  Not the name of
                                        the SES file being plotted from.
            line_number     int         The line number being processed.
                                        Used in error messages.
            line_text       str         The text of the line being
                                        processed.  Used in error messages.


        Returns:
            True if the section is in the file, None if it is not.


        Errors:
            Aborts with 5141 if the section is not present in the SES file.
        '''
        # Get all the string keys in sec_seg_dict (a list of line and vent
        # sections combined, all preceded by "sec").
        sec_list = [key[3:] for key in self.sec_seg_dict if type(key) is str]
        if sec_num[3:] not in sec_list:
            # Sort the list of the section numbers in this file then write
            # a suitable error message.
            sec_list.sort()
            err = ('> Tried to plot a curve in "' + file_name + '",\n'
                   '> but found that the identifier "' + where + '"\n'
                   '> referenced a section (' + sec_num[3:] + ') that is not in \n'
                   '> SES file "' + self.runfile_name + '".\n'
                   '> Please edit the file to correct this.\n'
                   '> For what it is worth this is a list of the\n'
                   '> section numbers used in that file:\n'
                     + gen.FormatOnLines(sec_list)
                   )
            gen.WriteError(5141, err, self.log)
            gen.ErrorOnLine(line_number, line_text, self.log, False)
            return(None)
        return(True)


    def _CheckRouteNumber(self, route_num, where, file_name, line_number, line_text):
        '''Take a route number and check if it is in this SES file.  Raise
        an error if it is not.

        Parameters:
            self            class       Literally everything in the class.
            route_num       int         An integer route number.
            where           str         A string defining where to plot.
            file_name       str         The name of the file being processed
                                        when this routine was called.  Used
                                        in error messages.  Not the name of
                                        the SES file being plotted from.
            line_number     int         The line number being processed.
                                        Used in error messages.
            line_text       str         The text of the line being
                                        processed.  Used in error messages.


        Returns:
            True if the route is in the file, None if it is not.


        Errors:
            Aborts with 5161 if the SES file has no routes (i.e. no train
            simulation happening).
            Aborts with 5162 if the route is not present in the SES file.
        '''

        # First check if this file has a train simulation and fault if it
        # does not.
        tpopt = self.settings_dict["trperfopt"]
        if tpopt not in (1, 2, 3):
            err = ('> Tried to plot a curve in "' + file_name + '",\n'
                   '> but found that the identifier "' + where + '"\n'
                   '> referenced an SES route (' + str(route_num) + ') in SES\n'
                   '> file "' + self.runfile_name + '".\n'
                   '> That SES file does not have routes in it, because\n'
                   '> its train simulation option is not 1, 2 or 3.\n'
                   '> Please edit "' + file_name + '" to\n'
                   '> correct the curve definition.'
                   )
            gen.WriteError(5161, err, self.log)
            gen.ErrorOnLine(line_number, line_text, self.log, False)
            return(None)
        else:
            # Get the number of routes.
            routes = self.settings_dict["routes"]

        # Check if the route number we want lies outside the allowable
        # range (1 to "routes").
        if route_num < 1 or route_num > routes:
            err = ('> Tried to plot a curve in "' + file_name + '",\n'
                   '> but found that the identifier "' + where + '"\n'
                   '> referenced an SES route (' + str(route_num) + ') in SES\n'
                   '> file "' + self.runfile_name + '".\n'
                   '> That route does not exist in the SES file,\n'
                   '> it only has routes 1 to ' + str(routes) + '.\n'
                   '> Please edit "' + file_name + '" to\n'
                   '> correct the curve definition.'
                   )
            gen.WriteError(5162, err, self.log)
            gen.ErrorOnLine(line_number, line_text, self.log, False)
            return(None)
        return(True)


    def _CheckZoneStuff(self, where, prop, file_name, line_number, line_text):
        '''Take the location and curve type of a line plotting the total
        heat flows in a controlled zone.  Check if the zone exists, check
        that the zone is a controlled zone (instead of an uncontrolled
        zone) and that the property being plotted is valid for the entire
        zone (HVAC sensible heat load is valid; wall temperature is not).
        If all is well, return the relevant DataFrame key, which will be
        something like "zone5".

        Parameters:
            self            class       Literally everything in the class.
            where           str         A string defining where to plot,
                                        e.g. "ZONE005".
            prop            str         A string defining what to plot,
                                        hopefully something that can be
                                        summed over an entire zone.
            file_name       str         The name of the file being processed
                                        when this routine was called.  Used
                                        in error messages.  Not the name of
                                        the SES file being plotted from.
            line_number     int         The line number being processed.
                                        Used in error messages.
            line_text       str         The text of the line being
                                        processed.  Used in error messages.


        Returns:
            A suitable key to plotting in a zone; all lower case, with
            no leading zeros, like "zone2".


        Errors:
            Aborts with 5241 if there is no zone number, just "zone".
            Aborts with 5242 if there is text after the "zone" but
            it is not a number.
            Aborts with 5243 if the zone is not present in the SES file.
            Aborts with 5244 if the zone is not a controlled zone.
            Aborts with 5245 if the property being plotted is not
            suitable for plotting over an entire controlled zone.
        '''

        zones = self.settings_dict["eczones"]

        # Get the zone number out of the contents of where[4:], which
        # we expect to be a number.

        rest = where[4:]
        if rest == '':
            # There was nothing after "zone".
            err = ('> Tried to plot a curve in "' + file_name + '",\n'
                   '> but found that the location identifier "' + where + '"\n'
                   '> did not give a zone number.  Please edit the\n'
                   '> file to add a zone number (the file has '
                     + str(zones) + ' zone' + gen.Plural(zones) + ').'
                   )
            gen.WriteError(5241, err, self.log)
            gen.ErrorOnLine(line_number, line_text, self.log, False)
            return(None)
        else:
            try:
                # We have a zone number.
                zone_num = int(rest)
            except ValueError:
                # There was something after the word but it was not a
                # decimal number.
                err = ('> Tried to plot a curve in "' + file_name + '",\n'
                       '> but found that the location identifier "' + where + '"\n'
                       '> did not have a zone number in it, it had "'
                         + where[4:] + '"\n'
                       '> instead.  Please edit the file and change\n'
                       '> it to a suitable zone number for this file\n'
                       '> (1 to ' + str(zones) + ').'
                       )
                gen.WriteError(5242, err, self.log)
                gen.ErrorOnLine(line_number, line_text, self.log, False)
                return(None)


        # Check if the zone number we want lies outside the allowable
        # range (1 to "zones").
        if zone_num < 1 or zone_num > zones:
            err = ('> Tried to plot a curve in "' + file_name + '",\n'
                   '> but found that the identifier "' + where + '"\n'
                   '> referenced zone ' + str(zone_num) + ' in the SES file\n'
                   '>   "' + self.runfile_name + '".\n'
                   '> That zone does not exist in the SES file,\n'
                   '> it only has zones 1 to ' + str(zones) + '.\n'
                   '> Please edit "' + file_name + '" to\n'
                   '> correct the curve definition.'
                   )
            gen.WriteError(5243, err, self.log)
            gen.ErrorOnLine(line_number, line_text, self.log, False)
            return(None)
        # Check if the zone type is controlled and fault if it is not.
        zone_type = self.form11_dict[zone_num]["z_type"]
        if zone_type != 1:
            if zone_type == 2:
                text = "an uncontrolled\n> zone (type 2)"
            else:
                # It must be a type 3 zone.
                text = "a non-inertial\n> zone (type 3)"
            err = ('> Tried to plot a curve in "' + file_name + '",\n'
                   '> but found that the identifier "' + where + '"\n'
                   '> referenced zone ' + str(zone_num) + ' in SES file\n'
                   '>   "' + self.runfile_name + '".\n'
                   '> That zone exists in the SES file, but is not a\n'
                   '> controlled zone (type 1), it is ' + text +
                     '.  Please edit "' + file_name + '"\n'
                   '> to correct the curve definition so that it plots\n'
                   '> in a controlled zone or remove the curve definition.'
                   )
            gen.WriteError(5244, err, self.log)
            gen.ErrorOnLine(line_number, line_text, self.log, False)
            return(None)


        # Check if the property being plotted is valid for zones.  The
        # only properties that are valid over entire zones are the ones
        # calculated in controlled zones during ECZ estimates.
        allowed = ("misc_sens", "misc_lat",
                   "steady_sens", "steady_lat",
                   "ground_sens",
                   "airex_sens", "airex_lat",
                   "hvac_sens", "hvac_lat", "hvac_tot")
        if prop.lower() not in allowed:
            err = ('> Tried to plot a curve in "' + file_name + '",\n'
                   '> in zone ' + str(zone_num) + ' in SES\n'
                   '> file "' + self.runfile_name + '".\n'
                   '> That zone exists in the SES file, but the\n'
                   '> property you want to plot is not a valid\n'
                   '> property to plot across an entire controlled\n'
                   '> zone.  The only valid properties are:\n'
                     + gen.FormatOnLines(allowed) + '\n'
                   '> Please edit "' + file_name + '" to\n'
                   '> correct the curve definition.'
                   )
            gen.WriteError(5245, err, self.log)
            gen.ErrorOnLine(line_number, line_text, self.log, False)
            return(None)
        # Build a suitable key to the pandas DataFrame.
        db_key = "zone" + str(zone_num)
        return(db_key)


    def _UnPickleData(self, descrip, count, pkl):
        '''Read some data from a pickle file and check it is the correct
        length.  If it is, return it.  If it isn't, raise an error about
        too many or too few entries.  Catches the cases where the contents
        of the file aren't pickled and where the file ends unexpectedly.

        Parameters:
            self            class       Literally everything in the class.
            descrip         str         A description to use in any
                                        error messages.
            count           int         How many entries we expect the
                                        value being read to split into.
                                        If it is zero don't check the
                                        length.
            pkl             handle      The handle of the file to read from.

        Returns:
            The contents of the class from the file, None if not.

        Errors:
            Aborts with 5021 if the content was not a pickle object.
            Aborts with 5022 if the file ended unexpectedly.
            Aborts with 5023 if some other error occurred (the pickle
            module has many failure options).
            Aborts with 5024 if the length of the value was not what
            we expected it to be for this version of the .sbn file.
            (this usually gets raised when the structure of the .sbn
            file is modified to include new data but the binary file's
            version number hasn't been increased yet.



        '''
        try:
            value = pickle.load(pkl)
        except pickle.UnpicklingError:
            # This part of the binary file wasn't made by pickling.
            err = ('> The binary file "' + self.bin_name + '"\n'
                   '> is not a Python pickle file.  Please check\n'
                   '> whether it was generated from SESconv.py.\n'
                   '> The pickle.load() function failed while\n'
                   '> reading ' + descrip + '.'
                   )
            gen.WriteError(5021, err, self.log)
            return(None)
        except EOFError:
            # The binary file ended unexpectedly.
            err = ('> The binary file "' + self.bin_name + '"\n'
                   '> ended unexpectedly.  Please check whether\n'
                   '> it was generated from SESconv.py.\n'
                   '> The pickle.load() function failed while\n'
                   '> reading ' + descrip + '.'
                   )
            gen.WriteError(5022, err, self.log)
            return(None)
        except Exception as my_trace:
            # Every other kind of exception, with a traceback message.
            # I've triggered this when trying to read pickle files in
            # a new version of pandas that were written by an older
            # version of pandas.  Various obscure traceback messages
            # have come back:
            #
            #   Can't get attribute 'new_block' on <module 'pandas.core.internals.blocks'
            #
            #   No module named 'pandas.core.indexes.numeric'
            #
            # Reconverting the .PRN files with SESconv.py fixed it.
            err = ('> The binary file "' + self.bin_name + '"\n'
                   '> failed during a pickle.read() action.\n'
                   '> The most common cause of this error is a\n'
                   '> new version of numpy or pandas being fed\n'
                   '> array data written by an earlier version\n'
                   '> of numpy or pandas, in which case the way\n'
                   '> to solve the problem is to run SESconv.py\n'
                   '> on the SES output file again.\n'
                   '> It failed while reading ' + descrip + '\n'
                   '> with the following traceback message:'
                   )
            gen.WriteError(5023, err, self.log)
            print('>  ', my_trace)
            return(None)

        # If we get to here we read a block of data. Figure out how
        # long it is (most entries will be tuples rather than strings
        # of variable length).  If the expected count is zero we skip
        # this test, because we may have variable length blocks.
        if count != 0 and len(value) != count:
            # We'll be triggering this one a lot, each time the
            # format of the binary file changes.
            err = ('> The binary file "' + self.bin_name + '"\n'
                   '> has a block of data of unexpected length\n'
                   '> for ' + descrip + '.\n'
                   '> Expected ' + str(count)
                       + ' item' + gen.Plural(count) + ' but read '
                       + str(len(value)) + ' instead.'
                   )
            gen.WriteError(5024, err, self.log)
            return(None)
        return(value)


    def Describe(self, name = ""):
        '''A function to print help text about each variable in the class
        and show examples of how to interrogate the variable.

         * If 'name' is the name of a variable in the .sbn file it prints
           the help text for that variable.

         * If 'name' is blank or if 'name' is not the name of a valid
           variable it gives prints the valid names and their
           descriptions. This is useful if you forget what the name
           of a variable is or want to hunt for the name of something
           you assume exists in the file somewhere

        Parameters:
            self            class       Literally everything in the class.
            name            str         A string that can be empty, the name
                                        of a variable in the class, or a
                                        random string.

        Returns:
            None
        '''
        descrip = {
      "prog_type":
        'A string describing the name of the program that created the\n'
        'SES output file.  It could be "SES 4.10", "SES 204.5" or\n'
        '"SES 4.3".  It is used to determine whether a curve can be\n'
        'generated from the data in the file.  For example curves of\n'
        'jet fan thrust derated by local air temperature can be \n'
        'plotted from from SES 204.5 but not from 4.1 or 4.3.',
      "when_who":
        'A string giving the time and date that the binary file was\n'
        'created and the name of the user who ran the SESconv.py\n'
        'script, such as "11:09 on 22 Jun 2022 by tester"',
      "prn_name":
        'A string giving the name of the output file that this binary\n'
        'file was generated from, such as "foo.PRN", "foo.TMP" or\n'
        '"foo.OUT".',
      "script_name":
        'A string giving the name of the script that this binary file\n'
        'was generated from, such as "SESconv.py".',
      "script_date":
        'A string giving the time and date that the script that this\n'
        'binary file was last edited, such as "20:46 on 18 Jun 2023".',
      "header":
        'A string giving the header line from the SES output file.\n'
        "In programs that don't generate a header line, the header\n"
        'line is spoofed.',
      "footer":
        'A string giving the footer line from the SES output file.\n'
        "In programs that don't generate a footer line, the footer\n"
        'line is spoofed.',
      "comments":
        'A list of strings.  Each entry is a line of comment at the\n'
        'top of the SES input file (the contents of form 1A).',
      "settings_dict":
        'A dictionary containing the entries in forms 1B to 1G of\n'
        'the input file.  The keys are short descriptive phrases\n'
        'and the results are numbers or strings.\n',
      "form2_dict":
        'A dictionary containing the entries in forms 2A and 2B of\n'
        'the input file.  The keys are the section numbers (as\n'
        'integers), the results are sub-dictionaries with the details\n'
        'of each section (the entries in form 2, the type and the\n'
        'section length).\n',
      "form3_dict":
        'A dictionary containing the entries in forms 3A to 3F of\n'
        'the input file.  The keys are the segment numbers (as\n'
        'integers), the results are sub-dictionaries with the details\n'
        'of each line segment.\n',
      "form4_dict":
        'A dictionary containing the entries in form 4 of the input\n'
        'file.  The keys are the fire numbers (integers starting at\n'
        '1) and the results are sub-dictionaries with the details\n'
        'of each unsteady heat gain.\n'
        'The unsteady heat gains are in MW, not watts.',
      "form5_dict":
        'A dictionary containing the entries in forms 5A to 5D of\n'
        'the input file.  The keys are the segment numbers (as\n'
        'integers), the results are sub-dictionaries with the details\n'
        'of each ventilation segment.\n',
      "sec_seg_dict":
        'A dictionary that can be interrogated to find which segments\n'
        'are in a given section and which section a given segment is\n'
        'in.  It has two types of keys: integers and strings.\n'
        'The integer keys are segment numbers: they return an integer\n'
        'that is the section number the segment belongs to.\n'
        'The string keys (for example, "sec101") are section numbers:\n'
        'they return a list of integers and each integer in the list\n'
        'is a segment number in that section.\n',
      "form6_dict":
        'A dictionary containing the entries in forms 6A to 6H of\n'
        'the input file.  The keys are the node numbers (as integers),\n'
        'the results are sub-dictionaries with the details of each\n'
        'node.\n',
      "form7_fans":
        'A dictionary containing the entries in forms 7A and 7B of\n'
        'the input file.  The keys are the fan numbers (as integers),\n'
        'the results are sub-dictionaries with the details of each\n'
        'fan.  The entries include lists of the values of flow and\n'
        'fan total pressure on the calculated fan curve.\n',
      "form7_JFs":
        'A dictionary containing the entries in form 7C of the\n'
        'input file.  The keys are the jet fan numbers (integers\n'
        'starting at 1), the results are sub-dictionaries with\n'
        'the details of each jet fan.',
      "form8_dict":
        'A dictionary containing the entries in forms 8A to 8F of\n'
        'the input file.  The keys are the route numbers (as integers),\n'
        'the results are sub-dictionaries with the details of each\n'
        'route.  The results contain calculated data that is useful\n'
        'when plotting, such as lists of the segment and subsegment\n'
        'chainages, dictionaries of subpoint chainages and segment\n'
        'elevations.',
      "form9_dict":
        'A dictionary containing the entries in forms 9A to 9L of\n'
        'the input file.  The keys are the train numbers (integers\n'
        'starting at 1), the results are sub-dictionaries with\n'
        "the details of each train's inputs and the calculated\n"
        'tractive efforts, calculated currents and suchlike.',
      "form10_dict":
        'A dictionary containing the entries in form 10 of the\n'
        'input file.  The keys are the train numbers (integers\n'
        'starting at 1), the results are sub-dictionaries with\n'
        'the details of each train at the start of the run.\n',
      "form11_dict":
        'A dictionary containing the entries in forms 11A and 11B\n'
        'of the input file.  The keys are the zone numbers (integers\n'
        'starting at 1), the results are sub-dictionaries with\n'
        'the details of each zone.  If there is only one zone and\n'
        'no definition of the segments in the zones (which is often\n'
        'the case, the list of segments is built from the dictionary\n'
        'keys of "form3_dict" and "form5_dict".',
      "form12_dict":
        'A dictionary containing the entries in form 12 of the input\n'
        'file.  There are no sub-dictionaries, just keys that return\n'
        'one number (such as temperature tabulation increment) or a\n'
        'list of numbers (such as a list of the time intervals).\n',
      "form13_dict":
        'A dictionary containing the entries in form 12 of the input\n'
        'file.',
      "form14_dict":
        'A dictionary containing the entries in form 14 of the input\n'
        'file.  There are no sub-dictionaries, just keys that return\n'
        'one number (such as pipe inlet temperature) or a list of\n'
        'numbers (such as a list of the sections the cooling pipe\n'
        'passes through).\n',
      "subseg_names":
        'A list of strings giving the names of all the subsegments in\n'
        "the run, such as ['201-1','201-2', ...]",
      "subpoint_keys":
        'A list of strings giving the names of all the subpoints in\n'
        "the run, such as ['201-1b','201-1m','201-1f','201-2b', ...]"
        '\n',
      "print_times":
        'A list of real numbers giving the print times in the output\n'
        'file.  Some simulation errors cause the state of the run to\n'
        'printed at the timestep where the failure occurred and these\n'
        'appear in the list.  Environmental control zone estimates\n'
        'cause the state of the system to be printed twice at the\n'
        'same time (with different temperatures).  In this case the\n'
        'first of the two is decremented by 0.05 seconds so that\n'
        'when the times are used as database keys there are no\n'
        'duplicate times.',
      "ECZ_times":
        'A list of real numbers giving the times at which environmental\n'
        'control zone estimates (ECZ estimates) occur in the file.\n',
      "sec_DPs":
        'A pandas DataFrame giving the pressure drops in every section\n'
        'at every timestep.  The columns are strings like "sec102"\n'
        '(representing section 102).  The indices are the print times\n'
        'given as floats.  The values are in Pa.  If the pressures\n'
        'are not printed to the output file, the values are NaN.',
      "seg_flows":
        'A pandas DataFrame giving the volume flows in the open\n'
        'tunnel in every segment at every timestep.  The columns\n'
        'are integers (the segment numbers).  The indices are the\n'
        'print times given as floats.\n'
        'The values are in m^3/s.\n',
      "seg_vels":
        'A pandas DataFrame giving the air velocities in the open\n'
        'tunnel in every segment at every timestep.  The columns\n'
        'are integers (the segment numbers).  The indices are the\n'
        'print times given as floats.\n'
        'The values are in m^3/s.\n',
      "subseg_walltemps":
        'A pandas DataFrame giving the wall temperature in every\n'
        'subsegment at every timestep.  The columns are strings\n'
        'giving the segment number and subsegment numbers, such\n'
        'as "204-5" for subsegment 5 in segment 204.  The indices\n'
        'are the print times given as floats.\n'
        'The values are in deg C and may be updated in fire runs\n'
        'or by environmental control zone estimates.\n',
      "subseg_temps":
        'A pandas DataFrame giving the air temperature in every\n'
        'subsegment at every timestep.  The columns are strings\n'
        'giving the segment number and subsegment numbers, such\n'
        'as "204-5" for subsegment 5 in segment 204.  The indices\n'
        'are the print times given as floats.\n'
        'The values are in deg C.\n',
      "subseg_humids":
        'A pandas DataFrame giving the air humidities in every\n'
        'subsegment at every timestep.  The columns are strings\n'
        'giving the segment number and subsegment numbers, such\n'
        'as "204-5" for subsegment 5 in segment 204.  The indices\n'
        'are the print times given as floats.\n'
        'The values are humidity ratio (kg water per kg of dry\n'
        'air).  There is no option to show humidity as wet-bulb\n'
        'temperature or relative humidity.\n',
      "subseg_sens":
        'A pandas DataFrame giving the sensible heat gains in\n'
        'every subsegment at every timestep.  The columns are\n'
        'strings giving the segment number and subsegment numbers,\n'
        'such as "204-5" for subsegment 5 in segment 204.  The\n'
        'indices are the print times given as floats.\n'
        'The values are in watts.\n',
      "subseg_lat":
        'A pandas DataFrame giving the latent heat gains in\n'
        'every subsegment at every timestep.  The columns are\n'
        'strings giving the segment number and subsegment numbers,\n'
        'such as "204-5" for subsegment 5 in segment 204.  The\n'
        'indices are the print times given as floats.\n'
        'The values are in watts.\n',
      "subseg_denscorr":
        'A pandas DataFrame giving the ratio of absolute air\n'
        'temperature in a subsegment to the absolute outside air\n'
        'temperature.  SES uses this as a proxy for density ratio\n'
        'in fire runs.\n'
        'Values are given for every subsegment at every timestep.\n'
        'The columns are strings giving the segment number and\n'
        'subsegment numbers, such as "204-5" for subsegment 5 in\n'
        'segment 204.  The indices are the print times given as\n'
        'floats.  \n'
        'If the air in the subsegment is warmer than outside,\n'
        'the ratio is over 1.\n'
        'The values are not of much interest to engineers but\n'
        'are used when verifying the calculation of warm volume\n'
        'flow and warm air velocity.\n'
        'The values are ratios of absolute temperature (K/K).',
      "seg_meandenscorr":
        'A pandas DataFrame giving the ratio of the mean absolute\n'
        'air temperature in all the subsegments in a vent segment\n'
        'to the absolute outside air temperature.\n'
        'SES uses this as a proxy for density ratio in fire runs\n'
        'when calculating fan performance and pressure losses in\n'
        'vent segments.\n'
        'Values are given for every segment at every timestep.\n'
        'The columns are integers giving the segment number.\n'
        'The indices are the print times given as floats.\n'
        'If the mean temperature of air in the segment is higher\n'
        'than outside, the ratio is over 1.\n'
        'The values are not of much interest to engineers but are\n'
        'used when verifying the calculation of fan density.\n'
        'The values are ratios of absolute temperature (K/K).',
      "subpoint_areas":
        'A pandas DataFrame giving the annulus area at subpoints\n'
        '(subpoints are located at the back end, midpoint and forward\n'
        'end of every subsegment).\n'
        'Values are given for every subpoint at every timestep.\n'
        'The columns are strings giving the subpoint ID, such as\n'
        '"512-4b", "512-4m", or "512-4f".\n'
        'The indices are the print times given as floats.\n'
        'The values are in m^2.',
      "subpoint_trainflows":
        'A pandas DataFrame giving the net volume flow of trains at\n'
        'subpoints (subpoints are located at the back end, midpoint\n'
        'and forward end of every subsegment).\n'
        'Values are given for every subpoint at every timestep.\n'
        'The columns are strings giving the subpoint ID, such as\n'
        '"512-4b", "512-4m", or "512-4f".\n'
        'The indices are the print times given as floats.\n'
        'The values are not of much interest to engineers but are\n'
        'used when verifying the calculation of volume flow and air\n'
        'velocity in the annulus around trains.\n'
        'The values are in m^3/s.',
      "subpoint_coldflows":
        'A pandas DataFrame giving the net volume flow of cold air at\n'
        'subpoints (subpoints are located at the back end, midpoint\n'
        'and forward end of every subsegment).  These volume flows\n'
        'account for the flow of air and the flow of trains, but\n'
        'do not account for the change in air density due to air\n'
        'heating up (train heat, fires etc.).\n'
        'Values are given for every subpoint at every timestep.\n'
        'The columns are strings giving the subpoint ID, such as\n'
        '"512-4b", "512-4m", or "512-4f".\n'
        'The indices are the print times given as floats.\n'
        'The values are in m^3/s.',
      "subpoint_warmflows":
        'A pandas DataFrame giving the net volume flow of warm air at\n'
        'subpoints (subpoints are located at the back end, midpoint\n'
        'and forward end of every subsegment).  These volume flows\n'
        'account for the flow of air, the flow of trains and the\n'
        'change in air density due to air heating up (train heat,\n'
        'fires etc.).\n'
        'Values are given for every subpoint at every timestep.\n'
        'The columns are strings giving the subpoint ID, such as\n'
        '"512-4b", "512-4m", or "512-4f".\n'
        'The indices are the print times given as floats.\n'
        'The values are in m^3/s.',
      "subpoint_coldvels":
        'A pandas DataFrame giving the net velocity of cold air at\n'
        'subpoints (subpoints are located at the back end, midpoint\n'
        'and forward end of every subsegment).  These velocities\n'
        'account for the flow of air, the flow of trains and the\n'
        'local annulus area, but do not account for the change in\n'
        'air density due to air heating up (train heat, fires etc.).\n'
        'Values are given for every subpoint at every timestep.\n'
        'The columns are strings giving the subpoint ID, such as\n'
        '"512-4b", "512-4m", or "512-4f".\n'
        'The indices are the print times given as floats.\n'
        'The values are in m/s.',
      "subpoint_warmvels":
        'A pandas DataFrame giving the net velocity of warm air at\n'
        'subpoints (subpoints are located at the back end, midpoint\n'
        'and forward end of every subsegment).  These velocities\n'
        'account for the flow of air, the flow of trains, the local\n'
        'annulus area and the change in air density due to air\n'
        'heating up (train heat, fires etc.).\n'
        'Values are given for every subpoint at every timestep.\n'
        'The columns are strings giving the subpoint ID, such as\n'
        '"512-4b", "512-4m", or "512-4f".\n'
        'The indices are the print times given as floats.\n'
        'The values are in m/s.',
      "route_num":
        'A pandas DataFrame giving the route number of a train\n'
        'number.\n'
        'Values are given for every train at every timestep.  In\n'
        'the event that a train leaves the system and its train\n'
        'number is re-used at a later time, there is no connection\n'
        'between the trains, which can be confusing.\n'
        'The columns are integer train numbers in the range 0 to 99.\n'
        'The indices are the print times given as floats.\n'
        'The values are dimensionless.',
      "train_type":
        'A pandas DataFrame giving the train type of a train.\n'
        'Values are given for every train at every timestep.  In\n'
        'the event that a train leaves the system and its train\n'
        'number is re-used at a later time, there is no connection\n'
        'between the trains, which can be confusing.\n'
        'The columns are integer train numbers in the range 0 to 99.\n'
        'The indices are the print times given as floats.\n'
        'The values are dimensionless.',
      "train_locn":
        'A pandas DataFrame giving the chainage of a train on its\n'
        'route.\n'
        'Values are given for every train at every timestep.  In\n'
        'the event that a train leaves the system and its train\n'
        'number is re-used at a later time, there is no connection\n'
        'between the trains, which can be confusing.\n'
        'The columns are integer train numbers in the range 0 to 99.\n'
        'The indices are the print times given as floats.\n'
        'The values are the location of the down end (train nose\n'
        'in SES) in metres.',
      "train_speed":
        'A pandas DataFrame giving the speed of a train on its\n'
        'route.\n'
        'Values are given for every train at every timestep.  In\n'
        'the event that a train leaves the system and its train\n'
        'number is re-used at a later time, there is no connection\n'
        'between the trains, which can be confusing.\n'
        'The columns are integer train numbers in the range 0 to 99.\n'
        'The indices are the print times given as floats.\n'
        'The values are in km/h.',
      "train_accel":
        'A pandas DataFrame giving the acceleration of a train on\n'
        'its route.\n'
        'Values are given for every train at every timestep.  In\n'
        'the event that a train leaves the system and its train\n'
        'number is re-used at a later time, there is no connection\n'
        'between the trains, which can be confusing.\n'
        'The columns are integer train numbers in the range 0 to 99.\n'
        'The indices are the print times given as floats.\n'
        'The values are in m/s^2 (+ve when the train is accelerating,\n'
        '-ve when it is decelerating).',
      "train_aerodrag":
        'A pandas DataFrame giving the drag of a train on its route\n'
        'Values are given for every train at every timestep.  In\n'
        'the event that a train leaves the system and its train\n'
        'number is re-used at a later time, there is no connection\n'
        'between the trains, which can be confusing.\n'
        'The columns are integer train numbers in the range 0 to 99.\n'
        'The indices are the print times given as floats.\n'
        'The values are in Newtons per train.',
      "train_coeff":
        'A pandas DataFrame giving the drag factor of a train on\n'
        'its route.\n'
        'The drag factor is the train drag divided by the dynamic\n'
        'pressure of train speed and the train area.  It is pretty\n'
        'much useless: better to use "train_aerodrag" instead.\n'
        'Values are given for every train at every timestep.  In\n'
        'the event that a train leaves the system and its train\n'
        'number is re-used at a later time, there is no connection\n'
        'between the trains, which can be confusing.\n'
        'The columns are integer train numbers in the range 0 to 99.\n'
        'The indices are the print times given as floats.\n'
        'The values are dimensionless.',
      "train_TE":
        'A pandas DataFrame giving the tractive effort of a train\n'
        'on its route.\n'
        'Values are given for every train at every timestep.  In\n'
        'the event that a train leaves the system and its train\n'
        'number is re-used at a later time, there is no connection\n'
        'between the trains, which can be confusing.\n'
        'The columns are integer train numbers in the range 0 to 99.\n'
        'The indices are the print times given as floats.\n'
        'The values are in Newtons per train.',
      "motor_amps":
        'A pandas DataFrame giving the motor current of a train\n'
        'on its route.\n'
        'Values are given for every train at every timestep.  In\n'
        'the event that a train leaves the system and its train\n'
        'number is re-used at a later time, there is no connection\n'
        'between the trains, which can be confusing.\n'
        'The columns are integer train numbers in the range 0 to 99.\n'
        'The indices are the print times given as floats.\n'
        'The values are in amps per motor.',
      "line_amps":
        'A pandas DataFrame giving the line current of a train\n'
        'on its route.\n'
        'Values are given for every train at every timestep.  In\n'
        'the event that a train leaves the system and its train\n'
        'number is re-used at a later time, there is no connection\n'
        'between the trains, which can be confusing.\n'
        'The columns are integer train numbers in the range 0 to 99.\n'
        'The indices are the print times given as floats.\n'
        'The values are in amps per powered car.',
      "flywh_rpm":
        'A pandas DataFrame giving the rotational speed of the \n'
        'flywheels on a train.  If the train type has no flywheel,\n'
        'the value is zero.\n'
        'Values are given for every train at every timestep.  In\n'
        'the event that a train leaves the system and its train\n'
        'number is re-used at a later time, there is no connection\n'
        'between the trains, which can be confusing.\n'
        'The columns are integer train numbers in the range 0 to 99.\n'
        'The indices are the print times given as floats.\n'
        'The values are in rpm.',
      "accel_temp":
        'A pandas DataFrame giving the temperature of the lumped\n'
        'parameter mass that represents the traction power system.\n'
        'Values are given for every train at every timestep.  In\n'
        'the event that a train leaves the system and its train\n'
        'number is re-used at a later time, there is no connection\n'
        'between the trains, which can be confusing.\n'
        'The columns are integer train numbers in the range 0 to 99.\n'
        'The indices are the print times given as floats.\n'
        'The values are in degrees Celsius.',
      "decel_temp":
        'A pandas DataFrame giving the temperature of the lumped\n'
        'parameter mass that represents the train braking system.\n'
        'Values are given for every train at every timestep.  In\n'
        'the event that a train leaves the system and its train\n'
        'number is re-used at a later time, there is no connection\n'
        'between the trains, which can be confusing.\n'
        'The columns are integer train numbers in the range 0 to 99.\n'
        'The indices are the print times given as floats.\n'
        'The values are in degrees Celsius.',
      "pwr_all":
        'A pandas DataFrame giving the heat from passengers and\n'
        'mechanical resistances plus the power sent to the lumped\n'
        'parameter masses that represent the traction power and\n'
        'braking systems.\n'
        'In SES it is the variable HETGEN (in PRINT.FOR),\n'
        'which is the sum of the following train performance arrays:\n'
        '  * QAXSV (sensible heat from people on the train),\n'
        '  * QACCV (power wasted in the traction power system),\n'
        '  * QDECV (power not regenerated in the braking system) and\n'
        '  * RMHTV (power to overcome rolling resistances and\n'
        '           curve resistance).\n'
        'Values are given for every train at every timestep.  In\n'
        'the event that a train leaves the system and its train\n'
        'number is re-used at a later time, there is no connection\n'
        'between the trains, which can be confusing.\n'
        'The columns are integer train numbers in the range 0 to 99.\n'
        'The indices are the print times given as floats.\n'
        'The values are in watts per train (not watts per unit\n'
        'length of train as printed in the SES output).',
      "heat_reject":
        'A pandas DataFrame giving the heat transferred to the air\n'
        'from passengers, mechanical resistances and the lumped\n'
        'parameter masses that represent the traction power and\n'
        'braking systems.\n'
        'In SES it is the variable QTRPF (in PRINT.FOR),\n'
        'which is the sum of the following train performance arrays:\n'
        '  * QAXSV (sensible heat from people on the train),\n'
        '  * QPRPV (heat from rolling resistance, curve resistance,\n'
        '           the acceleration grid and the deceleration grid).\n'
        'Values are given for every train at every timestep.  In\n'
        'the event that a train leaves the system and its train\n'
        'number is re-used at a later time, there is no connection\n'
        'between the trains, which can be confusing.\n'
        'The columns are integer train numbers in the range 0 to 99.\n'
        'The indices are the print times given as floats.\n'
        'The values are in watts per train (not watts per unit\n'
        'length of train as printed in the SES output).',
      "train_modev":
        'A pandas DataFrame giving an integer number that identifies\n'
        'what a train is doing.  Values can be 0 to 7, as follows:\n'
        '    0 = Stopped at a station\n'
        '    1 = Maintaining constant speed\n'
        '    2 = Accelerating at full available power\n'
        '    3 = Braking for either a speed restriction or a station\n'
        '                 (variable deceleration rate)\n'
        '    4 = Braking for either a speed restriction or a station\n'
        '                 (constant deceleration rate)\n'
        '    5 = Coasting\n'
        '    6 = Maintaining minimum speed in a track section where\n'
        '                 coasting is permitted\n'
        '    7 = Attempting to maintain constant minimum speed in a\n'
        '                 track section where coasting is permitted\n'
        'The corresponding variable in SES Fortran is called MODEV.\n'
        'Values are given for every train at every timestep, but\n'
        'only in files with supplementary print options 2, 3, 4\n'
        'and 5 and train performance options 1, 2 and 3.  In the\n'
        'event that a train leaves the system and its train number\n'
        'is re-used at a later time, there is no connection between\n'
        'the trains, which can be confusing.\n'
        'event that a train leaves the system and its train\n'
        'number is re-used at a later time, the train route and\n'
        'train type may be different.\n'
        'The columns are integer train numbers in the range 0 to 99.\n'
        'The indices are the print times given as floats.\n'
        'The values are dimensionless.',
      "pwr_aux":
        'A pandas DataFrame giving the power drawn from the pantograph\n'
        'to run the ancillary loads on a train.  \n'
        'In SES it is the variable PAUXV (calculated in TRAIN.FOR).\n'
        'It is the auxiliary loads on the train plus the product\n'
        'of "power draw per person on the train" and "count of\n'
        'peopleon the train".\n'
        'Values are given for every train at every timestep, but\n'
        'only in files with supplementary print options 2, 3, 4\n'
        'and 5 and train performance options 1, 2 and 3.  In the\n'
        'event that a train leaves the system and its train number\n'
        'is re-used at a later time, there is no connection between\n'
        'the trains, which can be confusing.\n'
        'The columns are integer train numbers in the range 0 to 99.\n'
        'The indices are the print times given as floats.\n'
        'The values are in watts per train.',
      "pwr_prop":
        'A pandas DataFrame giving the power drawn from the pantograph\n'
        "by the train's traction power system.\n"
        'In SES it is the variable PPROPV (calculated in many\n'
        'different routines, depending on the train performance\n'
        'option).\n'
        'Values are given for every train at every timestep, but\n'
        'only in files with supplementary print options 2, 3, 4\n'
        'and 5 and train performance options 1, 2 and 3.  In the\n'
        'event that a train leaves the system and its train number\n'
        'is re-used at a later time, there is no connection between\n'
        'the trains, which can be confusing.\n'
        'The columns are integer train numbers in the range 0 to 99.\n'
        'The indices are the print times given as floats.\n'
        'The values are in watts per train.',
      "pwr_regen":
        'A pandas DataFrame giving the power returned to the pantograph\n'
        "by the train's traction power system.\n"
        'In SES it is the variable PREGNV (calculated in HEAT.FOR).\n'
        'Values are given for every train at every timestep, but\n'
        'only in files with supplementary print options 2, 3, 4\n'
        'and 5 and train performance options 1, 2 and 3.  In the\n'
        'event that a train leaves the system and its train number\n'
        'is re-used at a later time, there is no connection between\n'
        'the trains, which can be confusing.\n'
        'In trains with onboard flywheels, it is always zero.\n'
        'The columns are integer train numbers in the range 0 to 99.\n'
        'The indices are the print times given as floats.\n'
        'The values are in watts per train.',
      "pwr_flywh":
        'A pandas DataFrame giving the power passing to (+ve) or\n'
        "from (-ve) the train's onboard flywheels.\n"
        'In SES it is the variable PFLYV (calculated in FLYWHL.FOR).\n'
        'Values are given for every train at every timestep, but\n'
        'only in files with supplementary print options 2, 3, 4\n'
        'and 5 and train performance options 1, 2 and 3.  In the\n'
        'event that a train leaves the system and its train number\n'
        'is re-used at a later time, there is no connection between\n'
        'the trains, which can be confusing.\n'
        'If the train does not have an on-board energy storage\n'
        'system, the values are always zero.\n'
        'The columns are integer train numbers in the range 0 to 99.\n'
        'The indices are the print times given as floats.\n'
        'The values are in watts per train.',
      "pwr_accel":
        'A pandas DataFrame giving the power sent to the acceleration\n'
        "grid by the train's traction power system.  This power is\n"
        "used to raise the acceleration grid's temperature.\n"
        'In SES it is the variable QACCV (calculated in HEAT.FOR\n'
        'and FLYWHL.FOR).\n'
        'Values are given for every train at every timestep, but\n'
        'only in files with supplementary print options 2, 3, 4\n'
        'and 5 and train performance options 1, 2 and 3.  In the\n'
        'event that a train leaves the system and its train number\n'
        'is re-used at a later time, there is no connection between\n'
        'the trains, which can be confusing.\n'
        'The columns are integer train numbers in the range 0 to 99.\n'
        'The indices are the print times given as floats.\n'
        'The values are in watts per train.',
      "pwr_decel":
        'A pandas DataFrame giving the power sent to the deceleration\n'
        "grid by the train's braking system.  This power is used to\n"
        "raise the acceleration grid's temperature.  In SES it is\n"
        'the variable QDECV (calculated in HEAT.FOR and FLYWHL.FOR).\n'
        'Values are given for every train at every timestep, but\n'
        'only in files with supplementary print options 2, 3, 4\n'
        'and 5 and train performance options 1, 2 and 3.  In the\n'
        'event that a train leaves the system and its train number\n'
        'is re-used at a later time, there is no connection between\n'
        'the trains, which can be confusing.\n'
        'The columns are integer train numbers in the range 0 to 99.\n'
        'The indices are the print times given as floats.\n'
        'The values are in watts per train.',
      "pwr_mech":
        'A pandas DataFrame giving the heat sent to the air by static\n'
        'resistance, rolling resistance and curve/flange resistance.\n'
        'In SES it is the variable RMHTV (calculated in two places\n'
        'TRAIN.FOR).  When using train performance option 1 the\n'
        'calculation is correct, but in train performance option 2\n'
        'the flange resistance is too low by a factor of train\n'
        'mass in tons.\n'
        'Values are given for every train at every timestep, but\n'
        'only in files with supplementary print options 2, 3, 4\n'
        'and 5 and train performance options 1, 2 and 3.  In the\n'
        'event that a train leaves the system and its train number\n'
        'is re-used at a later time, there is no connection between\n'
        'the trains, which can be confusing.\n'
        'The columns are integer train numbers in the range 0 to 99.\n'
        'The indices are the print times given as floats.\n'
        'The values are in watts per train.',
      "heat_adm":
        'A pandas DataFrame giving the heat sent to the air by three\n'
        'systems: the acceleration grid, the deceleration grid and\n'
        'mechanical resistances (this is where the acronym "adm"\n'
        'comes from).  It is calculated in GRID.FOR as SES variable\n'
        'QPRPV.\n'
        'Values are given for every train at every timestep, but\n'
        'only in files with supplementary print options 2, 3, 4\n'
        'and 5 and train performance options 1, 2 and 3.  In the\n'
        'event that a train leaves the system and its train number\n'
        'is re-used at a later time, there is no connection between\n'
        'the trains, which can be confusing.\n'
        'The columns are integer train numbers in the range 0 to 99.\n'
        'The indices are the print times given as floats.\n'
        'The values are in watts per train (not watts per unit\n'
        'length of train as printed in the SES output).',
      "heat_sens":
        'A pandas DataFrame giving the sensible heat sent to the\n'
        "air by a train's auxiliary loads and people onboard.\n"
        'It is calculated in TRAIN.FOR as SES variable QAXSV.\n'
        'Values are given for every train at every timestep, but\n'
        'only in files with supplementary print options 2, 3, 4\n'
        'and 5 and train performance options 1, 2 and 3.  In the\n'
        'event that a train leaves the system and its train number\n'
        'is re-used at a later time, there is no connection between\n'
        'the trains, which can be confusing.\n'
        'The columns are integer train numbers in the range 0 to 99.\n'
        'The indices are the print times given as floats.\n'
        'The values are in watts per train (not watts per unit\n'
        'length of train as printed in the SES output).',
      "heat_lat":
        'A pandas DataFrame giving the latent heat sent to the\n'
        "air by a train's auxiliary loads and people onboard.\n"
        'It is calculated in TRAIN.FOR as SES variable QAXLV.\n'
        'Values are given for every train at every timestep, but\n'
        'only in files with supplementary print options 2, 3, 4\n'
        'and 5 and train performance options 1, 2 and 3.  In the\n'
        'event that a train leaves the system and its train number\n'
        'is re-used at a later time, there is no connection between\n'
        'the trains, which can be confusing.\n'
        'The columns are integer train numbers in the range 0 to 99.\n'
        'The indices are the print times given as floats.\n'
        'The values are in watts per train (not watts per unit\n'
        'length of train as printed in the SES output).',
      "train_eff":
        "A pandas DataFrame giving the efficiency of a train's\n"
        'traction power system.  It is calculated by SESconv.py\n'
        'as the power delivered at the wheel-rail interface\n'
        'divided by the sum of the power delivered at the wheel-rail\n'
        'interface and the power sent to the acceleration grid by\n'
        'losses in the traction power system.\n'
        'Values are given for every train at every timestep, but\n'
        'only in files with supplementary print options 2, 3, 4\n'
        'and 5 and train performance options 1 and 2 and 3.  In the\n'
        'event that a train leaves the system and its train number\n'
        'is re-used at a later time, there is no connection between\n'
        'the trains, which can be confusing.\n'
        'The columns are integer train numbers in the range 0 to 99.\n'
        'The indices are the print times given as floats.\n'
        'The values are dimensionless fractions from zero to one.\n'
        'If the traction power system is off at a particular time\n'
        '(which would be the case if the train was stationary, coasting\n'
        'or braking) the value is zero.',
      "train_eff":
        "A pandas DataFrame giving the efficiency of a train's\n"
        'traction power system.  It is calculated by SESconv.py\n'
        'as the power delivered at the wheel-rail interface\n',
      "airT_AM":
        'A pandas DataFrame giving ECZ estimate data, the mean\n'
        'dry-bulb air temperature during the morning peak hour.\n'
        'It is only valid in runs with peak-hour ECZ estimates\n'
        'when the hour in form 1B is 8.0.\n'
        'It is calculated in DTHTS2.FOR as SES variable TSMEAN.\n'
        'Values are given at the start and end of the run with two\n'
        'values each time an ECZ estimate is calculated.\n'
        'The columns are strings giving the segment number and\n'
        'subsegment numbers, such as "204-5" for subsegment 5 in\n'
        'segment 204.  The indices are the times given as floats.\n'
        'The values are in deg C.\n',
      "airW_AM":
        'A pandas DataFrame giving ECZ estimate data, the mean\n'
        'air humidity ratio during the morning peak hour.\n'
        'It is only valid in runs with peak-hour ECZ estimates\n'
        'when the hour in form 1B is 8.0.\n'
        'It is calculated in DTHTS2.FOR as SES variable HUMMSS\n'
        'and in FORCEL.FOR as local variable HRATIO.\n'
        'Values are given at the start and end of the run with two\n'
        'values each time an ECZ estimate is calculated.\n'
        'The columns are strings giving the segment number and\n'
        'subsegment numbers, such as "204-5" for subsegment 5 in\n'
        'segment 204.  The indices are the times given as floats.\n'
        'The values are in kg/kg.\n',
      "wallT_AM":
        'A pandas DataFrame giving ECZ estimate data, the mean\n'
        'wall temperature during the morning peak hour.\n'
        'It is only valid in runs with peak-hour ECZ estimates\n'
        'when the hour in form 1B is 8.0.\n'
        'It is calculated in DTHTS2.FOR as SES variable TSFALS.\n'
        'Values are given at the start and end of the run with two\n'
        'values each time an ECZ estimate is calculated.\n'
        'The columns are strings giving the segment number and\n'
        'subsegment numbers, such as "204-5" for subsegment 5 in\n'
        'segment 204.  The indices are the times given as floats.\n'
        'The values are in deg C.\n',
      "airT_PM":
        'A pandas DataFrame giving ECZ estimate data, the mean\n'
        'dry-bulb air temperature during the evening peak hour.\n'
        'It is only valid in runs with peak-hour ECZ estimates\n'
        'when the hour in form 1B is 17.0.\n'
        'It is calculated in DTHTS2.FOR as SES variable TSMAX\n'
        'and in FORCE1.FOR as local variable TAIR.\n'
        'Values are given at the start and end of the run with two\n'
        'values each time an ECZ estimate is calculated.\n'
        'The columns are strings giving the segment number and\n'
        'subsegment numbers, such as "204-5" for subsegment 5 in\n'
        'segment 204.  The indices are the times given as floats.\n'
        'The values are in deg C.\n',
      "airW_PM":
        'A pandas DataFrame giving ECZ estimate data, the mean\n'
        'air humidity ratio during the evening peak hour.\n'
        'It is only valid in runs with peak-hour ECZ estimates\n'
        'when the hour in form 1B is 17.0.\n'
        'It is calculated in DTHTS2.FOR as SES variable HUMESS\n'
        'and in FORCEL.FOR as local variable HRATIO.\n'
        'Values are given at the start and end of the run with two\n'
        'values each time an ECZ estimate is calculated.\n'
        'The columns are strings giving the segment number and\n'
        'subsegment numbers, such as "204-5" for subsegment 5 in\n'
        'segment 204.  The indices are the times given as floats.\n'
        'The values are in kg/kg.\n',
      "wallT_PM":
        'A pandas DataFrame giving ECZ estimate data, the mean\n'
        'wall temperature during the evening peak hour.\n'
        'It is only valid in runs with peak-hour ECZ estimates\n'
        'when the hour in form 1B is 17.0.\n'
        'It is calculated in DTHTS2.FOR as SES variable TSFMLS\n'
        'and in WLLTM2.FOR as local variable TWALLA.\n'
        'Values are given at the start and end of the run with two\n'
        'values each time an ECZ estimate is calculated.\n'
        'The columns are strings giving the segment number and\n'
        'subsegment numbers, such as "204-5" for subsegment 5 in\n'
        'segment 204.  The indices are the times given as floats.\n'
        'The values are in deg C.\n',
      "airT_PM":
        'A pandas DataFrame giving ECZ estimate data, the mean\n'
        'dry-bulb air temperature during off hour calculations.\n'
        'It is only valid in runs with off-hour ECZ estimates.\n'
        'It is calculated in DTHTS2.FOR as SES variable TSMAX\n'
        'and in FORCE1.FOR as local variable TAIR.\n'
        'Values are given at the start and end of the run with two\n'
        'values each time an ECZ estimate is calculated.\n'
        'The columns are strings giving the segment number and\n'
        'subsegment numbers, such as "204-5" for subsegment 5 in\n'
        'segment 204.  The indices are the times given as floats.\n'
        'The values are in deg C.\n',
      "airW_PM":
        'A pandas DataFrame giving ECZ estimate data, the mean\n'
        'air humidity ratio during off hour calculations.\n'
        'It is only valid in runs with off-hour ECZ estimates.\n'
        'It is calculated in DTHTS2.FOR as SES variable HUMESS\n'
        'and in FORCEL.FOR as local variable HRATIO.\n'
        'Values are given at the start and end of the run with two\n'
        'values each time an ECZ estimate is calculated.\n'
        'The columns are strings giving the segment number and\n'
        'subsegment numbers, such as "204-5" for subsegment 5 in\n'
        'segment 204.  The indices are the times given as floats.\n'
        'The values are in kg/kg.\n',
      "wallT_used":
        'A pandas DataFrame giving ECZ estimate data, the mean\n'
        'wall temperature during the design hour.\n'
        'It is set to the AM wall temperatures during morning peak\n'
        'hour estimates, to the PM wall temperatures during evening\n'
        'peak hour estimates, and to the initial wall temperatures\n'
        'during off hour estimates.\n'
        'Values are given at the start and end of the run with two\n'
        'values each time an ECZ estimate is calculated.\n'
        'The columns are strings giving the segment number and\n'
        'subsegment numbers, such as "204-5" for subsegment 5 in\n'
        'segment 204.  The indices are the times given as floats.\n'
        'The values are in deg C.\n',
      "misc_sens":
        'A pandas DataFrame giving ECZ estimates over controlled\n'
        'zones (total of all the subsegments in the zone).\n'
        'It is the sensible heat flow from fixed heat gains and\n'
        'from trains.\n'
        'Values are given at the start and end of the run, as are\n'
        'two values each time an ECZ estimate is calculated.\n'
        'The columns are strings, but with two types: strings\n'
        'giving the segment number and subsegment numbers, such\n'
        'as "204-5" for subsegment 5 in segment 204; and strings\n'
        'giving the zone number preceded by the word "zone", such\n'
        'as "zone2" (to give the total over the entire zone).\n'
        'The indices are the times given as floats.  The values\n'
        'are given in watts.\n',
      "misc_lat":
        'A pandas DataFrame giving ECZ estimates over controlled\n'
        'zones (total of all the subsegments in the zone).\n'
        'It is the latent heat flow from fixed heat gains and\n'
        'from trains.\n'
        'Values are given at the start and end of the run, as are\n'
        'two values each time an ECZ estimate is calculated.\n'
        'The columns are strings, but with two types: strings\n'
        'giving the segment number and subsegment numbers, such\n'
        'as "204-5" for subsegment 5 in segment 204; and strings\n'
        'giving the zone number preceded by the word "zone", such\n'
        'as "zone2" (to give the total over the entire zone).\n'
        'The indices are the times given as floats.  The values\n'
        'are given in watts.\n',
                     # self.misc_lat,
                     # self.steady_sens,
                     # self.steady_lat,
                     # self.ground_sens,
                     # self.airex_sens,
                     # self.airex_lat,
                     # self.hVAC_sens,
                     # self.hVAC_lat,
                     # self.hVAC_total,
        }




        if name.lower() in descrip:
            print(descrip[name.lower()])

        return(None)


    def PrettyClassPrint(self, name = "", decpl = -1, describe = False):
        '''A function to print the contents of an SES .sbn file in a
        human-readable way.  This is mostly so that people who may
        want to use the contents of SESconv.py binary files to do other
        things have a way of easily seeing what the contents are.
        There is an optional argument 'name':

         * If 'name' is the name of a variable in the .sbn file it prints
           the contents of that variable only.

         * If 'name' is blank the entire contents are printed (this can take
           up a lot of space in the terminal window).

         * If 'name' is not the name of a valid variable it gives a list of
           the valid names.  This is useful if you forget what the name of
           a variable is: use PrettyClassPrint("blah") and it returns a list
           of all the names.


        Parameters:
            self            class       Literally everything in the class.
            name            str         A string that can be empty, the name
                                        of a variable in the class, or a
                                        random string.
            decpl           int         The count of decimal places to
                                        print the variable to.  If not
                                        set, pandas will decide how
                                        many decimal places to show.
            describe        Bool        If True, prints a description
                                        of the variable using the
                                        self.Describe() function.

        Returns:
            None
        '''
        # Make a list of the properties we want to ignore.
        ignore = ['fixed_data', 'transient_data', 'log', 'opt_descrip',
                  'properties', 'success', 'silentsulk',]
        # Make a list of the properties we know we have at the moment.
        # Last updated to version 8 binary files.
        fixed_known = ['binversion_string',
                       'binversion',
                       'bin_path',
                       'bin_name',
                       'runfile_name',
                       'prn_name',
                       'prog_type',
                       'full_prog',
                       'script_date',
                       'script_name',
                       'when_who',
                       'comments',
                       'header',
                       'footer',
                       'settings_dict',
                       'form2_dict', 'form3_dict', 'form4_dict', 'form5_dict',
                       'form6_dict', 'form7_fans', 'form7_JFs', 'form8_dict',
                       'form9_dict', 'form10_dict', 'form11_dict', 'form12_dict',
                       'form13_dict', 'form14_dict',
                       'print_times',
                       'ECZ_times',
                       'sec_seg_dict'
                      ]
        # Set the decimal places to round the runtime pandas DataFrames
        # to when printing them.  This can be overridden by passing
        # 'rounded' as False.
        decpls  = {'sec_DPs': 3,
                   'seg_flows': 3,
                   'seg_vels': 3,
                   'subseg_names': -1, # -1 signals these are not numbers.
                   'subseg_humids': 5,
                   'subseg_lat': 1,
                   'subseg_sens': 1,
                   'subseg_denscorr': 6,
                   'seg_meandenscorr': 6,
                   'subseg_walltemps': 3,
                   'subseg_temps': 3,
                   'subpoint_keys': -1, # Not numbers.
                   'subpoint_areas': 3,
                   'subpoint_trainflows': 3,
                   'subpoint_coldflows': 3,
                   'subpoint_coldvels': 3,
                   'subpoint_warmflows': 3,
                   'subpoint_warmvels': 3,
                   'route_num': 0,
                   'train_type': 0,
                   'train_locn': 3,
                   'train_speed': 2,
                   'train_accel': 4,
                   'train_aerodrag': 1,
                   'train_coeff': 4,
                   'train_TE': 1,
                   'motor_amps': 1,
                   'line_amps': 1,
                   'flywh_rpm': 1,
                   'accel_temp': 3,
                   'decel_temp': 3,
                   'pwr_all': 1,
                   'heat_reject': 1,
                   'train_modev': 0,
                   'pwr_aux': 1,
                   'pwr_prop': 1,
                   'pwr_regen': 1,
                   'pwr_flywh': 1,
                   'pwr_accel': 1,
                   'pwr_decel': 1,
                   'pwr_mech': 1,
                   'heat_adm': 1,
                   'heat_sens': 1,
                   'heat_lat': 1,
                   'train_eff': 4, # Fractional value, 0 to 1.  Not %.
                   'dP_up': 3,
                   'area_up': 3,
                   'dP_skin': 3,
                   'dP_down': 3,
                   'area_down': 3,
                   'train_SVSeff': 2,
                   'train_SVSregen': 4,
                   'airT_AM': 3,
                   'airT_PM': 3,
                   'airT_off': 3,
                   'airW_AM': 3,
                   'airW_PM': 3,
                   'airW_off': 1,
                   'airex_lat': 1,
                   'airex_sens': 1,
                   'ground_sens': 1,
                   'misc_lat': 1,
                   'misc_sens': 1,
                   'steady_lat': 1,
                   'steady_sens': 1,
                   'wallT_AM': 3,
                   'wallT_PM': 3,
                   'wallT_used': 3,
                   'misc_sens': 2,
                   'misc_lat': 2,
                   'steady_sens': 2,
                   'steady_lat': 2,
                   'ground_sens': 2,
                   'airex_sens': 2,
                   'airex_lat': 2,
                   'hVAC_sens': 2,
                   'hVAC_lat': 2,
                   'hVAC_total': 2,
                   'coolpipe_temps': 2,
                   'coolpipe_HT': 2,
                  }
        trans_known = list(decpls.keys())

        # Make a list of any properties that we haven't handled yet.  We
        # get a list of all of them (dir.self()).  Then we ignore the ones
        # that:
        #  * start with a capital letter (functions inside the class),
        #  * ones that start with an underscore (internal values/functions)
        #  * the ones already in 'ignore',
        #  * the ones already in 'fixed_known',
        #  * the ones already in 'trans_known'.
        # Ideally this would be empty.  But as we add more content to the
        # binary file it may not be, so this is where we pick up on that.
        # Note that this test relies on the first letter of the arrays
        # that hold the properties being in lower case.
        missed = [entry for entry in dir(self) if entry[0].islower() and
                                                  not (entry in ignore or
                                                       entry in fixed_known or
                                                       entry in trans_known)
                 ]
        if missed != []:
            print("Unexpected entries in the binary file:")
            for entry in missed:
                self._DebugPrint(entry)
            print("There were unexpected entries in the binary file:", missed)

        if name == "":
            # The user wanted everything.
            print('='*78 + '\n'
                  'Start of the pretty-printout of the contents of the binary\n'
                  'file "' + self.bin_name + '".  A few ground rules:\n'
                  '  * everything saved in the binary file is in SI units.\n'
                  '  * the binary file has a fixed section (containing the\n'
                  '  * contents of forms 1A to 13) and a transient section\n'
                  '  * containing the runtime output.\n'
                  '  * a few extra things have been added here and there\n'
                  '    that are not in the SES input file.  For example,\n'
                  '    - there is an entry for jet fan thrust (Newtons) in\n'
                  '      form7JF_dict.\n'
                  '    - There is an entry for the section length in form2_dict\n'
                  '      (section length cannot be known until forms 3 and 5\n'
                  '      are read).\n'
                  '    - There is a lot of additional data in form9_dict for\n'
                  '      things like true traction efficiency.'
                 )
            print("Known fixed entries in the binary file:")
            for entry in fixed_known:
                self._DebugPrint(entry)
                print('')
            print("Known transient entries in the binary file:")
            for entry in trans_known:
                self._DebugPrint(entry)
                print('')

            print('End of the pretty-printout of the contents of the binary file.\n'
                  + '='*78 + '\n')
        else:
            # The user wanted to print one variable.  Check if it exists.
            if name in fixed_known + trans_known + missed:
                print('Printing the contents of "' + name + '" in "' + self.bin_name + '".')
                if decpl != -1:
                    # Use the decimal places supplied by the user.
                    self._DebugPrint(name, decpl)
                elif name in decpls:
                    # Use the default decimal places from the dictionary
                    # for this variable.
                    self._DebugPrint(name, decpls[name])
                else:
                    self._DebugPrint(name)
                print('Printed the contents of "' + name + '" only.\n')
            else:
                print('> Tried to print the contents of "' + name + '" in\n'
                      '> "' + self.bin_name + '"' + " but it doesn't exist.\n"
                      '> Here are the valid names:\n'
                      + gen.FormatOnLines(fixed_known + trans_known + missed))
        return()


    def _DebugPrint(self, name, decpl = -1):
        '''Take the name of an item (list, string, dictionary).  Print the
        contents in a human-readable way.

        Parameters:
            self            class       Literally everything in the class.
            name            str         The name by which this is
                                        known (this is an ugly hack
                                        to get something that makes
                                        sense to the reader).
            decpl           str/int     Either "not used" or a count
                                        of decimal places.

        Returns:
            None
        '''
        # Get the contents of the named thing.  I don't like using
        # "eval()" and will change if a better option presents itself.
        item = eval("self." + name)

        if type(item) is bool:
            print('  Boolean "self.' + name + '":', item)
        elif type(item) is int:
            print('  int "self.' + name + '":', item)
        elif type(item) is float:
            print('  float "self.' + name + '":', gen.FloatText(item))
        elif type(item) is str:
            print('  str "self.' + name + '": ' + "'" + item + "'")
        elif type(item) in (tuple, list):
            print('  list "self.' + name + '":', item)
            # for entry in item:
            #     print("  ", entry)
        elif type(item) is dict:
            print('  dict "self.' + name + '":')
            for subitem in item:
                if type(subitem) is float:
                    # It's a number, remove spurious trailing digits and
                    # print it.
                    print("    ", item,":", gen.FloatText(item[item]))
                try:
                    this_item = item[subitem]
                except KeyError:
                    # It's not a sub-dictionary
                    print("    ", subitem,":", item[subitem])
                else:
                    # It is a subdictionary.  Print its entries on individual
                    # indented lines.
                    if type(this_item) is dict:
                        print('    subdict "' + str(subitem) + '":')
                        for sub_key in this_item:
                            print('      "' + str(sub_key) + '":', this_item[sub_key])
                    else:
                        # It's something subscriptable but not a dictionary.
                        print("    ", subitem,":", item[subitem])
        elif type(item) is pd.DataFrame:
            # Printing of pandas DataFrames is well formatted, a neat
            # touch about the library that I appreciate.

            # Check if we have a count of decimal places.  There is nothing
            # to stop a user providing a string as the count of decimal
            # places, we guard against that by checking the type.
            if (type(decpl) not in (int, float)) or decpl < 0:
                # The user didn't give a number or gave a negative number.
                # Let pandas decide how many decimal places to show.
                print('  pandas DataFrame "self.' + name + '":\n', item, '\n')
            else:
                # The user set a valid number for the count of decimal
                # places.
                print("Rounding to", decpl, "decimal place" +    \
                      gen.Plural(decpl) + '.')
                rounded = item.round(decimals = int(decpl))
                print('  pandas DataFrame "self.' + name + '":\n', rounded, '\n')
        else:
            print('  unknown type: "self.', name + '":\n', item)
        return()


    def CheckProperty(self, prop, curve_type, file_name, line_number, line_text):
        '''Take the name of the property to plot (velocity, volume flow,
        temperature etc.).  Check if this property can be plotted from this
        SES run.  If it can, return True if it is a transient plot (such as
        volume flow) and False if it is a fixed plot (such as elevation).
        If it can't be plotted, write a detailed error message telling the
        user either that it can't be plotted at all or telling the user what
        options need to be set in the SES run to allow it to be plotted
        (e.g. if you want pressures, you need to set the supplementary print
        option 3 or 5).

        Parameters:
            self            class       Literally everything in the class.
            prop            str         A string naming the property to
                                        plot.
            curve_type      str         A string describing what kind of
                                        curve this is, e.g. transient,
                                        profile etc.  Used in error
                                        messages.
            file_name       str         The name of the file being processed
                                        when this routine was called.  Used
                                        in error messages.  Not the name of
                                        the SES file being plotted from.
            line_number     int         The line number being processed.
                                        Used in error messages.
            line_text       str         The text of the line being
                                        processed.  Used in error messages.


        Returns:
            transient       Bool        True if the property is transient,
                                        False if it is not.

        Errors:
            Aborts with 5041 if the name of the property is not a valid one.
            Aborts with 5042 if the property cannot be plotted from this
            output file because the version of SES used doesn't support it.
            Aborts with 5043 if the user tried to plot train speed as a
            profile plot.  The error message (which I expect to turn up
            a lot of times) tells them to plot it as a transient property
            then add an optional argument that tells the program to plot
            train nose chainage instead of time.
            Aborts with 5044 if the property is not suitable for the curve
            type.  For example, it wouldn't make sense to try to plot the
            fan characteristic curve on a waterfall diagram.
            Aborts with 5045 if the property cannot be plotted from this
            output file because it is a property that can only be plotted
            from SES runs with certain options set (e.g. pressure drops
            need supplementary print option 3 or 5) but this run does not
            have those options set.
        '''


        # First check that the property is plottable.
        availables = list(self.properties.keys())
        if prop.lower() not in availables:
            # Strip out all the test properties in availables.
            plottables = [entry for entry in availables if entry[0] != '_']
            err = ('> Came across an invalid plot type in "' + file_name + '".\n'
                   '> The plot type was "' + prop + '", to be plotted\n'
                   '> from an SES output file.  Unfortunately that\n'
                   '> property is not valid for SES files, you can\n'
                   '> only plot the following:\n'
                   + gen.FormatOnLines(plottables) +
                   '\n> Please edit the file to correct it.'
                   )
            gen.WriteError(5041, err, self.log)
            gen.ErrorOnLine(line_number, line_text, self.log, False)
            return(None)
        else:
            # It is a valid SES property.
            curve_props = self.properties[prop.lower()]

        # Now check if the property is available in this version of SES.
        # We don't have any instances of this yet, but will in future when
        # we have more details.
        if self.prog_type not in curve_props["versions"]:
            err = ('> Came across an invalid plot type in "' + file_name + '".\n'
                   '> The plot type was "' + prop + '", to be plotted\n'
                   '> from SES file "' + self.runfile_name + '".\n'
                   '> Unfortunately the version of SES used to\n'
                   '> run it was ' + self.prog_type + ' which cannot produce\n'
                   '> this plot type.  The following version(s)\n'
                   '> of SES produce it:\n'
                   + gen.FormatOnLines(curve_props["versions"]) +
                   '\n> Please edit the file to remove the curve or\n'
                   '> rerun the SES file in a suitable version of\n'
                   '> SES and reprocess it.'
                   )
            gen.WriteError(5042, err, self.log)
            gen.ErrorOnLine(line_number, line_text, self.log, False)
            return(None)

        if curve_type not in curve_props["curve_types"]:
            # Catch a common but annoying mistake that I make all the
            # time and write a detailed error message for it.
            if curve_type == "profile" and prop == "speed":
                stem = line_text.split(sep = "profile", maxsplit = 1)
                mod_text = stem[0] + "transient  " + stem[1]  \
                           + "  xaxis:=chainage"
                err = ('> Came across an invalid plot type in "'
                         + file_name + '".\n'
                       '> The plot type was "speed", to be plotted\n'
                       '> on a profile plot.\n'
                       '> Unfortunately train speeds can only be\n'
                       '> plotted using the transient keyword.  If you\n'
                       '> want the X-axis values to be chainage instead\n'
                       '> of time, add the "xaxis:=chainage" optional\n'
                       '> argument.\n'
                       '> If you want to plot train speed against\n'
                       '> chainage, please adjust your line to read\n'
                       '> as follows:\n'
                       '>   ' + mod_text
                       )
                gen.WriteError(5043, err, self.log)
                gen.ErrorOnLine(line_number, line_text, self.log, False)
                return(None)
            else:
                err = ('> Came across an invalid plot type in "' + file_name + '".\n'
                       '> The plot type was "' + prop + '", to be plotted\n'
                       '> on a ' + curve_type + ' plot.\n'
                       '> Unfortunately that plot type can only be\n'
                       '> plotted in '
                        + gen.FormatOnLines(curve_props["curve_types"])[4:-1]
                        + ' curves.\n'
                       '> Please edit the file to adjust or remove\n'
                       '> the entry.'
                       )
                gen.WriteError(5044, err, self.log)
                gen.ErrorOnLine(line_number, line_text, self.log, False)
                return(None)

        # Now check if the file needs specific programs options to be set
        # and if so, whether it has them set.
        for opt_key in self.opt_descrip:
            # First check if this option key is in the curve properties.
            # If it is not, the value of that option does not matter.
            if opt_key in curve_props:
                # This property does depend on this option.  Get the
                # value of the option set and the list of values that
                # it needs to be to have the data in this output file.
                opt_used  = self.settings_dict[opt_key]
                opts_needed = curve_props[opt_key]
                if opt_used not in opts_needed:
                    # This run did not provide the property we want to
                    # plot in its output file.  Complain.
                    err = ('> Came across an invalid plot type in "' + file_name + '".\n'
                           '> The plot type was "' + prop + '", to be plotted\n'
                           '> from an SES output file.  Unfortunately the\n'
                           '> ' + self.opt_descrip[opt_key]  + ' was\n'
                           '> set to ' + str(opt_used)
                             + ' so these results were not in the\n'
                           '> printed output.\n'
                           '> That option needs to be set to '
                             + gen.FormatOnLines(opts_needed, "or")[4:] + '\n'
                           '> Please either rerun SES file "'
                             + self.runfile_name + '"\n'
                           '> with the option set correctly and reprocess its\n'
                           '> .PRN file with SESconv.py, or remove the curve.'
                          )
                    gen.WriteError(5045, err, self.log)
                    gen.ErrorOnLine(line_number, line_text, self.log, False)
                    return(None)

        # If we get to here then data for this curve type is in this SES file.
        #
        return(curve_props["transient"])


    def _CheckAt(self, where, allowed, locators, file_name, line_number, line_text):
        '''Take a property to plot that contains an '@' symbol, such as
        "route4@1200", "route4ud@1200 ".  The first could be route 4 at
        distance 1200 m, the second would be plotting at up and down ends
        of all subsegments in route 4 at time 1200 seconds.
        Check if it is syntactically valid and return an error message if
        it is not.

        Parameters:
            self            class       Literally everything in the class.
            where           str         A string defining where to plot.
            allowed         (,)         A tuple of acceptable entries at the
                                        start of "where", such as "route"
                                        and "train".
            locators        str         A string giving which letters are
                                        allowed before the "@".  Generally
                                        either "" or "umd".
            file_name       str         The name of the file being processed
                                        when this routine was called.  Used
                                        in error messages.  Not the name of
                                        the SES file being plotted from.
            line_number     int         The line number being processed.
                                        Used in error messages.
            line_text       str         The text of the line being
                                        processed.  Used in error messages.


        Returns:
            parts           []          A list of two parts of the location.


        Errors:
            Aborts with 5061 if the location starts with an "@".
            Aborts with 5062 if the location ends with an "@".
            Aborts with 5063 if the location contained more than one "@".
            Aborts with 5064 if distance/time after the @ was not a number.
            Aborts with 5065 if the first part of the entity was not in
            the list of allowable words.
            Aborts with 5066 if the first part of the entity did not have
            anything after it, i.e. it was just "route" or "train".
            Aborts with 5067 if the first part of the entity did not have
            a number after it.
            Aborts with 5068 if the first part of the entity had something
            else after the number that was not wanted.
            Aborts with 5069 if the first part of the entity ended with
            something other than a number, "u", "m" or "d".
        '''

        if where[0] == "@":
            err = ('> Tried to plot a curve in "' + file_name + '",\n'
                   '> but found that the location identifier "' + where + '"\n'
                   '> started with the symbol "@", meaning that the entity\n'
                   '> to plot at (tunnel, route, train etc.) was not given.\n'
                   '> Please edit the file to correct it.'
                   )
            gen.WriteError(5061, err, self.log)
            gen.ErrorOnLine(line_number, line_text, self.log, False)
            return(None)
        elif where[-1] == "@":
            err = ('> Tried to plot a curve in "' + file_name + '",\n'
                   '> but found that the location identifier "' + where + '"\n'
                   '> ended with the symbol "@", meaning that the second\n'
                   '> part of the identifier (distance along an entity or\n'
                   '> time to plot at) was not given.\n'
                   '> Please edit the file to correct it.'
                   )
            gen.WriteError(5062, err, self.log)
            gen.ErrorOnLine(line_number, line_text, self.log, False)
            return(None)

        parts = where.split(sep = "@")
        parts_low = where.lower().split(sep = "@")
        if len(parts) >= 3:
            # There was more than one instance of "@" in the word.
            err = ('> Tried to plot a curve in "' + file_name + '",\n'
                   '> but found that the location identifier "' + where + '"\n'
                   '> contained more than one "@" symbol.\n'
                   '> Please edit the file to correct it.'
                   )
            gen.WriteError(5063, err, self.log)
            gen.ErrorOnLine(line_number, line_text, self.log, False)
            return(None)
        else:
            (thing, dist_text) = parts_low

        # If we get to here, we look for a real number after the @ to set a
        # distance along a route or tunnel, or a distance offset from the
        # down end of a train.
        try:
            distance = float(dist_text)
        except ValueError:
            # The text after the @ was not a number.
            err = ('> Tried to plot a curve in "' + file_name + '",\n'
                   '> but found that second part of the location\n'
                   '> identifier "' + where + '" was not a number,\n'
                   '> it was "' + parts[1] + '" instead.\n'
                   '> Please edit the file to correct it.'
                   )
            gen.WriteError(5064, err, self.log)
            gen.ErrorOnLine(line_number, line_text, self.log, False)
            return(None)


        # If we get to here everything is OK, we have two parts and the
        # second part is a number.

        # Now check if the character at start of the first part of the
        # location are a word in the list of allowed words.
        first_word = parts_low[0]

        # Now check if the character at start of the first part of the
        # location are a word in the list of allowed words.  We check
        # each entry in the list of allowed words.  We make a default
        # entry for use in the next check if no allowed word is found.
        for candidate in allowed:
            if first_word[:len(candidate)] == candidate:
                # We have a match.  Set the first word so that we pass
                # the next test.
                first_word =  candidate
                break

        if first_word not in allowed:
            err = ('> Tried to plot a curve in "' + file_name + '",\n'
                   '> but found that first part of the location\n'
                   '> identifier "' + where + '" was not an allowed\n'
                   '> word, it was "' + first_word
                      + '".  The only words allowed\n'
                   '> are:\n'
                     + gen.FormatOnLines(allowed) + "\n"
                   '> Please edit the file to correct it.'
                   )
            gen.WriteError(5065, err, self.log)
            gen.ErrorOnLine(line_number, line_text, self.log, False)
            return(None)
        # Get everything after the valid word into a new string.
        first_rest = parts_low[0][len(first_word):]

        if first_rest == '':
            # There was nothing before the "@" except an acceptable word.
            # There was not a number after the acceptable word.  It was
            # something like "route@1200" instead of "route8@1200"
            err = ('> Tried to plot a curve in "' + file_name + '",\n'
                   '> but found that first part of the location\n'
                   '> identifier "' + where + '" only contained the\n'
                   '> word "' + thing + '" without a '
                     + thing.lower() + ' number before\n'
                   '> the "@".  Please edit the file to add a\n'
                   '> ' + thing.lower() + ' number.'
                   )
            gen.WriteError(5066, err, self.log)
            gen.ErrorOnLine(line_number, line_text, self.log, False)
            return(None)
        elif first_rest.isdecimal():
            # Everything between the first word and the "@" was a decimal.
            # Turn it into an integer and set the locator to something
            # that the user cannot spoof.
            thing_number = int(first_rest)
            locator = '#default'
        elif first_rest[0].isdecimal():
            # There was at least one decimal after the valid word.  Get
            # all the decimals after the valid word and turn them into
            # an integer.  Load everything after the decimals into the
            # locator, we will deal with that when we return to the
            # routine that called _Checkat.
            # Point to the number after the first decimal number.
            for index, char in enumerate(first_rest):
                if char.isdecimal():
                    partition = index + 1
                else:
                    break

            thing_number = int(first_rest[:partition])
            locator = first_rest[partition:]
        else:
            # There was something after the word but it did not start
            # with a decimal number.
            err = ('> Tried to plot a curve in "' + file_name + '",\n'
                   '> but found that first part of the location\n'
                   '> identifier "' + where + '" did not have a\n'
                   '> ' + first_word.lower()
                      + ' number after it, it had "' + parts[0][5:] + '"\n'
                   '> instead.  Please edit the file and change\n'
                   '> it to a suitable ' + first_word + ' number.'
                   )
            gen.WriteError(5067, err, self.log)
            gen.ErrorOnLine(line_number, line_text, self.log, False)
            return(None)

        # Now check the locator text against the allowable entries in
        # 'locators'.  Fault if someone included a locator
        # where none was wanted (transient curves).
        if locator == '#default':
            if locators == '':
                # Everything is fine.  We are looking at a transient
                # curve and received no locators.
                locator == ''
            else:
                # Set the default locator for route plots.  When
                # we get back to the routine that called here a suitable
                # set of entries is made, depending on the type of
                # curve (e.g. "umd" for subpoint curves, "ud" for
                # subseg curves).
                locator = '#default'
        else:
            # The user set an entry for a locator string.
            if locators == '':
                # The user set a locator for a transient curve, which
                # does not need them (it figures out where to plot by
                # itself).  Complain.
                err = ('> Tried to plot a curve in "' + file_name + '",\n'
                       '> but found that first part of the location\n'
                       '> identifier "' + where + '" had extra and\n'
                       '> unnecessary detail (a subpoint identifier).\n'
                       '> Please remove "' + locator
                         + '" from just before the "@".'
                       )
                gen.WriteError(5068, err, self.log)
                gen.ErrorOnLine(line_number, line_text, self.log, False)
                return(None)
            else:
                # It's a route plot, which is allowed to have locators.  Check
                # that the letters in the locator are acceptable.
                for letter in locator:
                    if letter not in locators:
                        err = ('> Tried to plot a curve in "' + file_name + '",\n'
                               '> but found that first part of the location\n'
                               '> identifier "' + where + '" tried to plot at a\n'
                               '> subpoint identifier that does not exist, "'
                                + letter + '".\n'
                               '> The only acceptable sub-point identifiers are\n'
                               '> "u" (up end), "m", (midpoint) and "d" (down\n'
                               '> end) either alone or in any combination.\n'
                               '> Please remove "' + letter + '" from the line (and check\n'
                               '> for any other unacceptable letters).'
                               )
                        gen.WriteError(5069, err, self.log)
                        gen.ErrorOnLine(line_number, line_text, self.log, False)
                        return(None)

        # Return the location type ("train" or "route", its number, locator (if
        # any) and the distance or time.
        return(first_word, thing_number, locator, distance)


    def TransientAt(self, where, prop, curve_type, units, file_name,
                    line_number, line_text):
        '''Take the location of a property to plot against time, something
        like "route4@1200".  This means "plot something 1200 m (or feet)
        along route 4".
        Check if the location is syntactically valid and return an error
        message if it is not.  If it is valid, check if this location exists
        exists in the SES run and return error messages if it does not.
        If everything is OK otherwise, figure out the correct key to use
        to get the transient data out of the relevant pandas DataFrame in
        the SES binary file and return the key.
        This routine assumes that the property has already been checked
        by a call to self.CheckProperty.  If a dud property is provided
        it will cause an exception.

        Parameters:
            self            class       Literally everything in the class.
            prop            str         A string naming the property to
                                        plot.
            where           str         A string defining where to plot.
            curve_type      str         A string describing what kind of
                                        curve this is, e.g. transient,
                                        profile.  Used in error messages.
            units           str         The system of units the input is in.
                                        This could be "si" or "us".
            file_name       str         The name of the file being processed
                                        when this routine was called.  Used
                                        in error messages.  Not the name of
                                        the SES file being plotted from.
            line_number     int         The line number being processed.
                                        Used in error messages.
            line_text       str         The text of the line being
                                        processed.  Used in error messages.


        Returns:
            locn            str         The key to one of the pandas
                                        DataFrames in the SES run.  It
                                        could be:
                                         * a section ("sec210")
                                         * a segment ("120")
                                         * a subsegment ("132-5")
                                         * a subpoint ("304-5b")


        Errors:
            Aborts with 5081 if a train number was not in range.
            Aborts with 5082 if the test in 5081 needs to be modified
            to handle train number ranges in newer versions of SES.
            Aborts with 5083 if the code was not set to handle a new
            type of entity.  This can only happen when the programmer
            fouls up.
            Aborts with 5084 if distance along a route was below the
            route origin.
            Aborts with 5085 if distance along a route was above the
            end of the route.
            Aborts with 5086 if an SES pandas DataFrame key was an
            unrecognised type in the first if block.  This, too, can
            only happen in runs where the programmer fouled up.
            Aborts with 5087 if a segment number was given but the
            segment number was below 1.
            Aborts with 5088 if a segment number was given but the
            segment was not in the SES file.
            Aborts with 5089 if a section number was given but the
            plot required a segment number.
            Aborts with 5090 if we added a new pandas DataFrame key
            type without updating the second "if" block to handle it.
            Aborts with 5091 if a section number was given but the
            plot required a segment number and subsegment number.
            Aborts with 5092 if a segment number was given but the
            plot required a segment number and subsegment number.
            Aborts with 5093 if we added a new pandas DataFrame key
            type without updating the third "if" block to handle it.
            Aborts with 5094 if a section number was given but the
            plot required a subpoint locator.
            Aborts with 5095 if a segment number was given but the
            plot required a subpoint locator.
            Aborts with 5096 if we added a new pandas DataFrame key
            type without updating the fourth "if" block to handle it.
            Aborts with 5097 if we tried to plot a property on a train
            that the train is not able to provide (like fan total
            pressure rise).
            Aborts with 5098 if we added a pandas DataFrame key type
            that was not of type 'int' or 'str' without updating the
            an "if" block to handle keys in reversed segments.
        '''


        # There are several types of location, as follows:
        #  * a string with "@" in it for distance along a route or
        #    along a train ("route1@13490")
        #  * a string for a section ("sec210")
        #  * an integer for a segment (120)
        #  * a string for a subsegment ("132-5")
        #  * a string for a subpoint ("304-5b")
        #  * "zone" followd by a zone number.


        # Figure out what key to use from the plot types properties and
        # put it into "keytype".
        these_props = self.properties[prop.lower()]
        keytype = these_props["place"]

        if "@" in where:
            # Check the general structure of the location.  This returns
            # the name of the entity in lower case ("route", "train"),
            # the entity number as an integer and a distance as a float.
            allowed = ["route", "train"]#, "zone"]
            # Make a list of allowable locators (in this case nothing)
            locators = ""
            result = self._CheckAt(where, allowed, locators, file_name, line_number, line_text)
            if result is None:
                return(None)
            else:
                # Get the entity, the number and the distance along it.
                # Throw away the locator string, it is only used when
                # plotting along a route at a time.
                (entity, entity_no, discard, distance) = result

            # We have a valid descriptor like "route" or "train".  First
            # get the range of the numbers we are looking for at the
            # end of 'thing'.
            if entity == "train":
                # SES uses two characters for train numbers in the printout
                # so the 100th train is train 0, the 101st is train 1 again
                # and so on.  A future version of SES may have more digits
                # in train numbers and we catch that case here.
                if gen.CheckSESVer(self.prog_type):
                    # Check if the train train number is between 0 and 99.
                    if not (0 <= entity_no <= 99):
                        err = ('> Tried to plot a curve in "' + file_name + '",\n'
                               '> but found that first part of the location\n'
                               '> identifier "' + where + '" did not have a\n'
                               '> valid train number after it, it had "'
                                  + str(entity_no) + '"\n'
                               '> instead.  Valid entries are in the range\n'
                               '> 0 to 99.\n'
                               '> Please edit the file to correct it.'
                               )
                        gen.WriteError(5081, err, self.log)
                        gen.ErrorOnLine(line_number, line_text, self.log, False)
                        return(None)
                    # Check if the property cannot be plotted on a train.
                    if keytype != "train":
                        err = ('> Tried to plot a curve in "' + file_name + '",\n'
                               '> but found that the property being plotted\n'
                               '> "' + prop
                                 + '" could not be plotted on a train.\n'
                               '> Please edit the file to correct the curve\n'
                               '> definition.'
                               )
                        gen.WriteError(5097, err, self.log)
                        gen.ErrorOnLine(line_number, line_text, self.log, False)
                        return(None)
                else:
                    err = ('> Tell the programmer that the train number\n'
                           '> handling in classSES.TransientAt needs to be\n'
                           '> modified to handle output from '
                             + self.prog_type + '\n'
                           '> input files.'
                          )
                    gen.WriteError(5082, err, self.log)
                    gen.ErrorOnLine(line_number, line_text, self.log, False)
                    gen.OopsIDidItAgain(self.log, file_name)
                    return(None)
            elif entity == "route":
                result = self._CheckRouteNumber(entity_no, where,
                                file_name, line_number, line_text)
                if result is None:
                    return(None)
            else:
                # We added a new location type to "allowed" without adding
                # an elif branch to handle it here.
                # Get a list of the names of new entity for the error
                # message.  We pop the ones we've already created elif
                # branches for.
                allowed.remove("train")
                allowed.remove("route")
                # allowed.remove("zone")

                err = ('> Tell the programmer that an extra elif clause\n'
                       '> needs to be added in classSES.TransientAt\n'
                       '> to handle plot locations of type "' + allowed[0] + '".'
                      )
                gen.WriteError(5083, err, self.log)
                gen.ErrorOnLine(line_number, line_text, self.log, False)
                gen.OopsIDidItAgain(self.log, file_name)


            # If it's a distance from the down end of a train we don't
            # care what the number is, it passes.  But if it is a chainage
            # on a route we need to check that it lies between the route
            # origin and the end of the route.
            if entity == "route":
                # First we get the extents of the route and the distance
                # we want in SI units (recall that everything in the binary
                # file is in SI units).
                route_dict = self.form8_dict[entity_no]
                route_start = route_dict["single_chs"][0]
                route_end = route_dict["single_chs"][-1]

                if units == "us":
                    # Get the distance into SI units for the comparison and
                    # the extents of the route into US units for error messages.
                    dist_SI = USc.ConvertToSI("dist1", distance, False, self.log)[0]
                    start_text = str(round(USc.ConvertToUS("dist1", route_start, False, self.log)[0],2))
                    end_text = str(round(USc.ConvertToUS("dist1", route_end, False, self.log)[0],2))
                else:
                    # Everything is already in SI units.
                    dist_SI = distance
                    start_text = str(round(route_start,2))
                    end_text = str(round(route_end,2))
                if dist_SI < route_start:
                    route_text = 'route ' + str(entity_no)
                    dist_text = str(round(distance,2))
                    err = ('> Tried to plot a curve in "' + file_name + '",\n'
                           '> at a distance along ' + route_text + ' but the\n'
                           '> location in the route (' + dist_text
                             + ') is below \n'
                           '> the route origin (' + start_text + ').\n'
                           '> Please edit the file to correct it.'
                           )
                    gen.WriteError(5084, err, self.log)
                    gen.ErrorOnLine(line_number, line_text, self.log, False)
                    return(None)
                elif dist_SI > route_end:
                    route_text = 'route ' + str(entity_no)
                    dist_text = str(round(distance,2))
                    err = ('> Tried to plot a curve in "' + file_name + '",\n'
                           '> at a distance along ' + route_text + ' but the\n'
                           '> location in the route (' + dist_text
                             + ') is above \n'
                           '> the end of the route (' + end_text + ').\n'
                           '> Please edit the file to correct it.'
                           )
                    gen.WriteError(5085, err, self.log)
                    gen.ErrorOnLine(line_number, line_text, self.log, False)
                    return(None)

                # If we get to here it's all good.  Figure out if the location
                # is in the open air or in the tunnel.  If it's in the open
                # air we record that, if it's in a tunnel we figure out what
                # the appropriate pandas DataFrame key is.
                # First get list of chainages of subpoint locations and a list
                # of subpoint locations that correspond to them.
                sub_chs2 = route_dict["sub_chs2"] # A dictionary.
                sub_locns = list(sub_chs2.keys())
                sub_chs = [route_dict["sub_chs2"][key] for key in sub_locns]
                if dist_SI < sub_chs[0] or dist_SI > sub_chs[-1]:
                    # It's in the open air, so outside air temperature/humidity,
                    # zero air flow, air velocity etc.  Set the key such that
                    # the value outside is used.
                    db_key = "open_air"
                else:
                    # It's inside the tunnel.  Find the subpoint chainage
                    # closest to the chainage we want.  If the distance
                    # exactly matches a chainage at the back or forward
                    # end of a subsegment take the boundary on the up side
                    # in the route.
                    for (sub_index, chainage) in enumerate(sub_chs):
                        if chainage >= dist_SI:
                            # We are at or just above where we want to be.
                            break
                    # When we break out of the loop the value of sub_index
                    # points to the first chainage equal to or higher than
                    # the location.
                    if sub_index == 0:
                        # Our chainage is at the up portal in the SES run.
                        # Use that location as the DataFrame key.
                        db_key = sub_locns[sub_index]
                    elif sub_index == len(sub_chs) - 1:
                        # Our chainage is at the down portal in the SES run.
                        # Use that location as the DataFrame key.
                        db_key = sub_locns[sub_index]
                    else:
                        # Our chainage is in the middle somewhere.  Check
                        # if it is between the up end and the midpoint or
                        # between the midpoint and the down end.
                        down_ch = chainage
                        up_ch = sub_chs[sub_index - 1]
                        fraction = (distance - up_ch) / (down_ch - up_ch)
                        if fraction <= 0.5:
                            # It's nearer to the up chainage.  Go up
                            # the route to the boundary to use.
                            db_key = sub_locns[sub_index - 1]
                        else:
                            # Go down the route to the boundary to use.
                            db_key = sub_locns[sub_index]
                    # Take out any leading negative sign in the key (it
                    # signifies that the location is front to back in
                    # the route.
                    if type(db_key) is int:
                        # It's a segment key.
                        db_key = abs(db_key)
                    elif type(db_key) is str:
                        # It's a section, subsegment, or subpoint key.
                        # Adjust it if the section is reversed in the
                        # route.
                        if db_key[0]  == '-':
                            db_key = db_key[1:]
                    else:
                        # We added a new type of key to the pandas DataFrames
                        # (not an int or str) without adding code to handle
                        # it here.  Complain.
                        print(db_key, type(db_key))
                        err = ('> Tell the programmer that a new type of \n'
                               '> DataFrame key was added (not str or int)\n'
                               '> without adding the ability to handle it\n'
                               '> to an "if" clause in classSES.GetLocation.'
                              )
                        gen.WriteError(5098, err, self.log)
                        gen.ErrorOnLine(line_number, line_text, self.log, False)
                        gen.OopsIDidItAgain(self.log, file_name)
                        return(None)

                    # Once we get to here we have a DataFrame key that is
                    # a subpoint, e.g. "605-32f".  Some curve types
                    # don't need as much detail: temperatures apply
                    # all the way through subsegments so their keys look
                    # like "605-32".  Volume flows directly out of SES
                    # apply to a segment, so "605".  Pressures apply to a
                    # section, so "sec601".

                    # Get the segment number as a string.
                    seg_num = db_key.split(sep = '-')[0]
                    if keytype == "section":
                        # We need to get the section of this segment.
                        # Get the section number from the dictionary
                        # that holds the relationship between sections
                        # and segments (and segments and sections).
                        sec_num = self.sec_seg_dict[int(seg_num)]
                        # Build the correct DataFrame key
                        db_key = "sec" + str(sec_num)
                    elif keytype == "segment":
                        # We want the key to be an integer segment number.
                        db_key = seg_num
                    elif keytype == "subseg":
                        # We need to remove the "b", "m" or "f" from the
                        # subpoint key text.
                        db_key = db_key[:-1]
                    elif keytype == "subpoint":
                        # It's fine as it is. This is only here so we
                        # have the else clause below to catch when we
                        # add another type of key.
                        pass
                    else:
                        # We added a new type of key to the pandas DataFrames
                        # descriptions in self.properties without adding code
                        # to handle it here.  Complain.
                        err = ('> Tell the programmer that a pandas DataFrame\n'
                               '> key was added without adding the ability to\n'
                               '> handle it in classSES.TransientAt.'
                              )
                        gen.WriteError(5086, err, self.log)
                        gen.ErrorOnLine(line_number, line_text, self.log, False)
                        gen.OopsIDidItAgain(self.log, file_name)
                        return(None)
            else:
                # Our thing is a distance offset from the down end of a
                # train (likely a moving train).  Make the "DataFrame key"
                # be "train<train number>@<offset distance>.  This may not
                # be a valid key to a DataFrame but when we write the code to
                # handle plotting relative to moving trains (this is really,
                # really handy for getting temperatures alongside moving
                # trains in congestion runs) we will at least know that
                # we have a train number followed by an offset distance.
                # And we've already checked that they are numbers in valid
                # ranges, no need to do any further checks when we write
                # that code.
                db_key = where.lower()

            # Once we get to here, we have turned our <something><num>@<distance>
            # into either a valid key to where that is in a pandas DataFrame or into
            # "<train number>@<offset distance>".

        elif where[:4].lower() == "zone":
            result = self._CheckZoneStuff(where, prop, file_name,
                                          line_number, line_text)
            if result is None:
                return(None)
            else:
                # We know that the key (something like "zone2") is valid
                # and the property is one of the properties valid for
                # that zone, like HVAC sensible heat gain.
                db_key = result
                db_type = "zone"
        else:
            # It's not an "entity@distance" locator or a zone total.
            # So it must be a pointer to a location within the SES
            # geometry.  Check if it's a segment number.
            # I know I'll forget this, so here are the details of
            # how this regular expression was built up:
            #
            #   ^       Matches the start of the string.
            #
            #  [-+]     An optional sign, +ve or -ve.  We look for
            #           these here so that we catch negative numbers
            #           with error 5087 instead of error 5088 (5088
            #           is vaguer).
            #
            #   \d+     Any number of digits for the segment number.
            #
            #   $       Matches the end of the string.
            # Note that .
            result = re.match(r"^[-+]?\d+$", where)
            if result is not None:
                seg_num = where
                if int(seg_num) < 1:
                    err = ('> Tried to plot a curve in "' + file_name + '",\n'
                           '> but found that the segment identifier "' + where + '"\n'
                           '> was zero or negative.  Please edit the file\n'
                           '> to give a positive segment number.\n'
                           )
                    gen.WriteError(5087, err, self.log)
                    gen.ErrorOnLine(line_number, line_text, self.log, False)
                    return(None)
                else:
                    # Check if this segment number exists in this SES file.
                    result = self._CheckSegNumber(seg_num, where,
                                            file_name, line_number, line_text)
                    if result is None:
                        return(None)
                    else:
                        # We know it's a valid segment number.
                        db_key = seg_num
                        db_type = "segment"
            else:
                # Check if it's a segment and subsegment separated by
                # a dash, possible with one of "b", "m" or "f" after it.
                where_low = where.lower()
                #
                result = re.match(r"^\d+-\d+[bmf]?$", where_low)
                # Here are the details of how this regular expression
                # was built up:
                #
                #   ^       Matches the start of the string.
                #
                #   \d+     Any number of digits for the segment number
                #           (plus and minus signs are not permitted).
                #
                #    -      A mandatory dash between segment number and
                #           subsegment number (no spaces).
                #
                #   \d+     Any number of digits for the subsegment
                #           number.
                #
                #   [bmf]?  "b", "m", "f" or nothing.
                #
                #   $       Matches the end of the string.
                if result is not None:
                    db_key = where_low
                    if db_key[-1] in "bmf":
                        # The user gave a point inside a subsegment
                        db_type = "subpoint"
                        (seg_num, sub_num) = db_key[:-1].split(sep='-')
                    else:
                        # The user just gave a segment and a subsegment.
                        db_type = "subseg"
                        (seg_num, sub_num) = db_key.split(sep='-')
                    # Now check the segment number and subsegment number.
                    result = self._CheckSegNumber(seg_num, where,
                                            file_name, line_number, line_text)
                    if result is None:
                        return(None)
                    result = self._CheckSubNumber(seg_num, sub_num, where,
                                            file_name, line_number, line_text)
                    if result is None:
                        return(None)
                else:
                    # Check if it is a section number, e.g. "sec701".
                    where_low = where.lower()
                    result = re.match(r"^sec\d+$", where_low)
                    if result is not None:
                        # We have a match.
                        db_key = where_low
                        db_type = "section"
                        result = self._CheckSecNumber(db_key, where,
                                            file_name, line_number, line_text)
                        if result is None:
                            return(None)
                    else:
                        # It was not a section, segment, or subsegment.  Complain.
                        err = ('> Tried to plot a curve in "' + file_name + '",\n'
                               '> but found that the location identifier "' + where + '"\n'
                               '> was not a valid segment number (e.g. 123),\n'
                               '> segment-subseg combination (e.g. 104-5,\n'
                               '> 104-5b, 104-5m or 104-5f), or section\n'
                               '> number (e.g. sec204).  Please edit the\n'
                               '> file to give a valid SES location term.\n'
                               )
                        gen.WriteError(5088, err, self.log)
                        gen.ErrorOnLine(line_number, line_text, self.log, False)
                        return(None)

            # If we get to here we have set a db_key and the type that
            # was given (zone, section, segment, subseg or subpoint).
            # Check what kind of key was needed (keytype).  If (say) we
            # want a section key and the key given was a segment, we
            # derive the section key from the segment number.  If we need
            # a subsegment key and a section was given we complain (because
            # each section may contain many segments and subsegments).
            # Finally, if we need a subpoint key and a subsegment key was
            # given we default to the midpoint of the subsegment.

            # 'keytype' is what this plot type needs.  db_type is the key
            # that was in the input file.
            if prop == "_t5090":
                keytype = "segment"
                db_type = "trigger5090"
            elif prop == "_t5093":
                keytype = "subseg"
                db_type = "trigger5093"
            elif prop == "_t5096":
                keytype = "subpoint"
                db_type = "trigger5096"
            if keytype == "section":
                if db_type == "section":
                    # All is well.  We want a section key and we have one.
                    pass
                else:
                    # We were given a segment number, subseg or subpoint
                    # as a key.  Get the section of this segment.
                    # Get the section number from the dictionary
                    # that holds the relationship between sections
                    # and segments (and segments and sections).
                    seg_num = int(db_key.split(sep = '-')[0])
                    sec_num = self.sec_seg_dict[seg_num]
                    # Build the correct DataFrame key.
                    db_key = "sec" + str(sec_num)
            elif keytype == "segment":
                # We want the key to be an integer segment number.
                if db_type == "section":
                    # There may be more than one segment in a section,
                    # so we can't tell which segment to use.  Complain.
                    # We're going to phrase this error message to annoy
                    # pedants, by giving the number of the first segment
                    # in the section as an example of what to use to
                    # access the plot property.
                    first_seg = self.sec_seg_dict[db_key][0]
                    err = ('> Tried to plot a curve in "' + file_name + '",\n'
                           '> but found that the location identifier "' + where + '"\n'
                           '> was too vague: it defined a section number for \n'
                           '> a plot, but a segment number was needed.\n'
                           '> Please edit the file to give a valid segment\n'
                           '> number here e.g., ' + str(first_seg) + '.'
                          )
                    gen.WriteError(5089, err, self.log)
                    gen.ErrorOnLine(line_number, line_text, self.log, False)
                    return(None)
                elif db_type in ("segment", "subseg", "subpoint"):
                    # There was either a segment, subsegment or subpoint
                    # identifier in the input file.  Get the segment number
                    # on its own.
                    # We need to get the segment number out.  This works
                    # for all cases (segments don't have a '-' in them,
                    # subsegments and subpoints do).
                    db_key = db_key.split(sep = '-')[0]
                else:
                    # We added a new type of key to the pandas DataFrames
                    # descriptions in self.properties without adding code
                    # to handle it here.  Complain.
                    err = ('> Tell the programmer that a pandas DataFrame\n'
                           '> key was added without adding the ability to\n'
                           '> handle it in classSES.TransientAt.'
                          )
                    gen.WriteError(5090, err, self.log)
                    gen.ErrorOnLine(line_number, line_text, self.log, False)
                    gen.OopsIDidItAgain(self.log, file_name)
                    return(None)
            elif keytype == "subseg":
                # We want the key to be a string with a segment number
                # and a subsegment number
                if db_type == "section":
                    # There may be more than one subsegment in a section,
                    # so we can't tell which one to use.  Complain.
                    err = ('> Tried to plot a curve in "' + file_name + '",\n'
                           '> but found that the location identifier "' + where + '"\n'
                           '> was too vague: it defined a section number for\n'
                           '> a plot, but a segment and subsegment number was\n'
                           '> needed.  Please edit the file to give a valid\n'
                           '> segment and subsegment number e.g., 304-12.'
                          )
                    gen.WriteError(5091, err, self.log)
                    gen.ErrorOnLine(line_number, line_text, self.log, False)
                    return(None)
                elif db_type == "segment":
                    # There may be more than one subsegment in a segment,
                    # so we can't tell which one to use.  Complain.
                    err = ('> Tried to plot a curve in "' + file_name + '",\n'
                           '> but found that the location identifier "' + where + '"\n'
                           '> was too vague: it defined a segment number for\n'
                           '> a plot, but a segment and subsegment number was\n'
                           '> needed.  Please edit the file to give a valid\n'
                           '> segment and subsegment number e.g., 304-12.'
                          )
                    gen.WriteError(5092, err, self.log)
                    gen.ErrorOnLine(line_number, line_text, self.log, False)
                    return(None)
                elif db_type == "subseg":
                    # It was what we wanted.  Do nothing.
                    pass
                elif db_type == "subpoint":
                    # We had too much information, as the user defined a
                    # subpoint location (back end, midpoint or forward end
                    # of a subsegment.  Chop off the trailing letter in the
                    # key.
                    db_key = db_key[:-1]
                else:
                    # We added a new type of key to the pandas DataFrames
                    # descriptions in self.properties without adding code
                    # to handle it here.  Complain.
                    err = ('> Tell the programmer that a pandas DataFrame\n'
                           '> key was added without adding the ability to\n'
                           '> handle it in classSES.TransientAt.'
                          )
                    gen.WriteError(5093, err, self.log)
                    gen.ErrorOnLine(line_number, line_text, self.log, False)
                    gen.OopsIDidItAgain(self.log, file_name)
                    return(None)
            elif keytype == "subpoint":
                # We want the key to be a string with a segment number
                # and a subsegment number.  First define a long spiel
                # that we want to use in more than one error message.
                bloviate = ('> Please edit the file to give a valid subpoint\n'
                            '> location such as 304-12b, 304-12f or 304-12m\n'
                            '> (these are the back end, forward end and midpoint\n'
                            '> of the 12th subsegment of segment 504 respectively).\n'
                            '> Note that you can use "304-12" and the plot will\n'
                            '> default to the midpoint of the segment.  That\n'
                            '> can lead to trouble in some circumstances so\n'
                            '> please use it sparingly.'
                           )
                if db_type == "section":
                    # There may be more than one subsegment in a section,
                    # so we can't tell which one to use.  Complain.
                    err = ('> Tried to plot a curve in "' + file_name + '",\n'
                           '> but found that the location identifier "' + where + '"\n'
                           '> was too vague: it defined a section number for\n'
                           '> a plot, but a segment number, subsegment number\n'
                           '> and a location inside the subsegment (back end,\n'
                           '> midpoint or forward end) were needed (known in\n'
                           '> Hobyah as a subpoint location).\n' + bloviate
                          )
                    gen.WriteError(5094, err, self.log)
                    gen.ErrorOnLine(line_number, line_text, self.log, False)
                    return(None)
                elif db_type == "segment":
                    # There may be more than one subsegment in a segment,
                    # so we can't tell which one to use.  Complain.
                    err = ('> Tried to plot a curve in "' + file_name + '",\n'
                           '> but found that the location identifier "' + where + '"\n'
                           '> was too vague: it defined a segment number for\n'
                           '> a plot, but a segment number, subsegment number\n'
                           '> and a location inside the subsegment (back end,\n'
                           '> midpoint or forward end) were needed (known in\n'
                           '> Hobyah as a subpoint location).\n' + bloviate
                          )
                    gen.WriteError(5095, err, self.log)
                    gen.ErrorOnLine(line_number, line_text, self.log, False)
                    return(None)
                elif db_type == "subseg":
                    # We add a pointer to the midpoint of the subsegment in the
                    # DataFrame key.
                    db_key = db_key + 'm'
                elif db_type == "subpoint":
                    # We got what we wanted.
                    pass
                else:
                    # We added a new type of key to the pandas DataFrames
                    # descriptions in self.properties without adding code
                    # to handle it here.  Complain.
                    err = ('> Tell the programmer that a pandas DataFrame\n'
                           '> key was added without adding the ability to\n'
                           '> handle it in classSES.TransientAt.'
                          )
                    gen.WriteError(5096, err, self.log)
                    gen.ErrorOnLine(line_number, line_text, self.log, False)
                    gen.OopsIDidItAgain(self.log, file_name)
                    return(None)
        # Once we get to here we either have a valid key to a pandas database
        # for a transient plot at at a fixed point, the text string "open_air"
        # (which indicates that a distance along a route was not inside a tunnel)
        # or a checked key "train<num>@<valid_distance> which can be used by
        # another routine without having to be re-checked.
        return(db_key)


    def FanAt(self, where, prop, curve_type, units, file_name,
              line_number, line_text):
        '''Take the specification of a fan property to plot on a Q-P_tot
        diagram like "921@105".  This means 'plot a property of the fan
        in vent segment 921 at 105 seconds'.
        We return the fan number, direction, whether the fan is on
        or not and the time to plot at.  If there is no fan, the fan
        number is zero.

        Parameters:
            self            class           Everything in the class.
            where           str             A string defining where to plot
            prop            str             A string naming the property to plot.
            curve_type      str             A string describing what kind of
                                            curve this is, e.g. transient, profile
                                            etc.  Used in error messages.
            units           str             The system of units the input is in.
                                            This could be "si" or "us".
            file_name       str             The name of the file being processed
                                            when this routine was called.  Used in
                                            error messages.  Not the name of the
                                            .hbn file being plotted from.
            line_number     int             The line number being processed.  Used
                                            in error messages.
            line_text       str             The text of the line being processed.
                                            Used in error messages.

        Returns:
            fan_num         int             A key to form7_fans that returns
                                            the fan's properties.
            transient       Bool            True if this fan property is
                                            transient, False if it is not.
            time            float           The time the user wanted to plot at.
            result_time     float           The time to actually plot at.

        Errors:
            Aborts with 5221 if the segment nmber is a line segment, not
            a vent segment.
        '''
        # Figure out what key to use from the plot types properties and
        # put it into "keytype".
        these_props = self.properties[prop.lower()]

        # Check the vent segment number and time.
        #
        numbered = []
        result = self._CheckAt(where, numbered, file_name,
                                    line_number, line_text)
        if result is None:
            return(None)
        else:
            # Get the entity, the entity number (not used here) and the
            # time the user wants to plot at.
            (vent_seg, discard, time) = result

        # Raise an error if this is a line segment, not a vent segment.
        if vent_seg in self.form3_dict:
            err = ('> Tried to plot a curve in "' + file_name + '",\n'
                   '> with data of a fan in vent segment '
                     + str(vent_seg) + ' in this file.\n'
                   '> This segment is a line segment and cannot\n'
                   '> have a fan in it.\n'
                   '> Please edit the file to plot fan properties in\n'
                   '> a vent segment instead of a line segment.'
                  )
            gen.WriteError(5221, err, self.log)
            gen.ErrorOnLine(line_number, line_text, self.log, False)
            return(None)
        # Figure out which fan (if any) is in this vent segment.  If
        # there is no fan, SESconv.py will have stored a zero.
        fan_num = self.form5_dict[vent_seg]["fan_type"]

        transient = these_props["transient"]
        if transient:
            result_time = self._GetPlotTime(time)
        else:
            # This is a fixed property plot, like the input data for
            # the fan characteristic rather than the fan characteristic
            # when running at a given speed at a specific time.  The
            # routine calling this ought not to use "result_time", so
            # return something that will cause a crash.
            result_time = None
        return(transient, fan_num, time, result_time)


    def GetFanDataTransient(self, fan_num, prop, orig_where, where,
                            units, line_text, result_time, time):
        '''Take the definition of a transient fan curve and return the
        data needed to plot it and suitable QA data for the curve file.

        Parameters:
            self            class           Everything in the class.
            fan_num         str             A number that correlates to the
                                            fan type in form 7.  If there is
                                            no form in the vent segment the
                                            fan number is zero.
            prop            str             A string naming the property to plot.
            orig_where      str             A string defining where to plot in
                                            the form that was given in the input
                                            file, e.g. CTA-S@105.2.
            where           str             A string defining where to plot in
                                            a form that has a valid time for this
                                            file, e.g. CTA-S@104.0.
            units           str             The system of units the input is in.
                                            This could be "si" or "us".
            line_text       str             The text of the line being processed.
                                            Used in error messages.
            time            float           The time the user wanted to plot at.
            result_time     float           The time to actually plot at.

        Returns:
            QAlist          []              A list of lines tracing the data.
            fan_flows       []              A list of X-values (volume flows).
            x_USconv        str             "seconds", signifying that time in
                                            US units is the same as in SI units.
            fan_P_tots      []              A list of Y-values (gauge total
                                            pressure).
            y_USconv        float           The key to use in UScustomary.py to
                                            convert the Y values from SI to US
                                            units.
            autolabel       str             A line of text that can be used as
                                            a graph key entry.
            col_headers     str             A string of text with suitable
                                            headers to appear above each column
                                            if someone loads a curve data file
                                            into a spreadsheet.
        '''
        # Check if the fan number is zero and return data that plots
        # a blank.
        if fan_num == 0:
            speed = 0.0
            direction = +1.
        else:
            fan_details = self.form5_dict[fan_num]
            direction = fan_details["direction"]
            start_time = fan_details["start_time"]
            stop_time = fan_details["stop_time"]
            # This next is time duration it takes for the fan to
            # get to full speed.
            startup = fan_details["startup"]
            # Figure out the current fan speed.
            if time <= start_time or time > stop_time:
                # The fan is off.
                speed = 0.
            elif (time - start_time) < startup:
                # The fan is starting up.  We should use a weird
                # function from OMEGA.FOR to figure out what the
                # speed at the current time is, using a constant
                # set in FINS.FOR (TIMFT, calculated from the
                # runup time).
                if startup < 0.005:
                    timft = -1.E9
                else:
                    timft = -9.21034037 / startup **2
                    # Apparently -9.21034037 is ln(0.0001).
                # These next calculations are from OMEGA1.FOR
                # and they look a little suspect.  Not sure why
                # we add 1 and check for values under 80, but
                # that's what it does (I think).
                fraction = (time - start_time) < startup
                interim = timft * exp(fraction + 1.)**2
                # Check if it so close to full speed that
                # we might as well set the sped to 1
                if interim < 80:
                    speed = math.exp(interim)
                else:
                    speed = 1.0
            elif (stop_time - time) < startup:
                # The fan is has stopped, and is slowing down
                # using the same rules as for starting up.
                if startup < 0.005:
                    timft = -1.E9
                else:
                    timft = -9.21034037 / startup **2
                fraction = (time - start_time) < startup
                interim = timft * exp(fraction + 1.)**2
                # Check if it so close to stationary that
                # we might as well set the sped to 0
                if interim < 80:
                    speed = 1 - math.exp(interim)
                else:
                    speed = 0.0
            else:
                speed = 1.0

        # Get the details of the vent segment the fan is in, as we
        # need the volume flow and the mean air density to calculate
        # the location of the duty point.
        seg_num = int(where.split(sep="@")[0])


        if prop in ("system", "dutypoint"):
            # We want the total pressure rise across the fan expressed
            # as a system characteristic on the flow-total pressure plane
            # or as one point.  SES doesn't record the pressure across
            # the fans as an individual number so we have to figure
            # it out from the volume flow in the segment.
            # flow =

            P_tot = self.p_diff_dict[fan_name].loc[result_time]

            # We want the volume flow at inlet side of the fan (not
            # upwind of the fan).  This is so that we get the same
            # location even if the fan is being pushed into the reverse
            # flow region of its characteristic by a train or other fan.
            # If the fan is not rotating we will use the volume flow
            # in the first segment.
            if prop == "system":
                descrip_text = "System curve for"
            else:
                descrip_text = "Duty point of"
            if math.isclose(speed, 0.0):
                # The fan is off, so has no system characteristic.  Other
                # prime movers may be moving air through this segment but
                # they have nothing to do with this fan.  We put in two
                # points so that gnuplot doesn't complain about not
                # having anything to plot.
                fan_flows = [0.0, 0.01]
                fan_P_tots = [0.0, 0.0]
                direct_text = "(off)"
            else:
                if speed > 0.0:
                    # We want the volume flow at the right-hand end of the
                    # first segment.
                    fan_flow = self.q_bin[seg1].loc[result_time].iloc[-1]
                    # The fan is running in reverse so we switch the sign
                    # of the pressure.
                    P_tot = -P_tot
                    direct_text = "(forwards)"
                else:
                    # We want the volume flow at the left-hand end of the
                    # second segment.
                    fan_flow = -self.q_bin[seg2].loc[result_time].iloc[0]
                    direct_text = "(reverse)"

                if prop == "system":
                    # Get the multiplier of our Y = X**2 curve on the
                    # flow-total pressure plane.
                    if math.isclose(fan_flow, 0.0):
                        # We have zero flow, just draw a vertical line for
                        # the system characteristic.  This avoids a divide
                        # by zero error in the else clause below.
                        fan_flows = (0.0, 0.0)
                        fan_P_tots = (0.0, P_tot)
                    else:
                        # Build lists that plot the system curve.
                        gauls = P_tot / fan_flow**2
                        interval = fan_flow / 10.0
                        fan_flows = np.arange(interval, fan_flow * 1.04, interval)
                        fan_P_tots = gauls * fan_flows**2
                else:
                    # Build a list of one point that will be plotted with
                    # a point instead of with lines.
                    fan_flows = [fan_flow]
                    fan_P_tots = [P_tot]
        elif prop == "fanchar":
            char_data = self.fanchars_dict[char_name]
            # We want the fan characteristic at an instant in time, given
            # as volume flow and total pressure rise.
            if math.isclose(speed, 0.0):
                # The fan is off, so has no fan characteristic.  Other
                # prime movers may be moving air through this segment but
                # they have nothing to do with this fan.  We put in two
                # points so that gnuplot can plot a line.
                fan_flows = [0.0, 0.01]
                fan_P_tots = [0.0, 0.0]
                # Set a fan flow that ensures that we do not extend
                # the characteristic in either direction (see below).
                fan_flow = 0.005
                direct_text = "(off)"
            elif speed > 0.0:
                # We want the fan characteristic used for forwards
                # airflow.
                direct_text = "(forwards)"
                char_flows, char_P_tots = char_data["forwards"]
                fan_flows = [flow * speed for flow in char_flows]
                fan_flow = self.q_bin[seg1].loc[result_time].iloc[-1]

                # Figure out the air density at the fan inlet and turn
                # the fan_P_tots (which are dimensionless) into fan total
                # pressures at that air density and at the correct fan
                # speed.
                dens = self.dens_bin[seg1].loc[result_time].iloc[-1]
                P_adj = dens * self.settings_dict["psi"] * speed**2   \
                          / self.settings_dict["gamma"]**2
                fan_P_tots = [press * P_adj for press in char_P_tots]
            else:
                # We want the fan characteristic for used for reverse airflow.
                direct_text = "(reverse)"
                char_flows, char_P_tots = char_data["reverse"]
                fan_flows = [-flow * speed for flow in char_flows]
                fan_flow = -self.q_bin[seg1].loc[result_time].iloc[-1]

                dens = self.dens_bin[seg2].loc[result_time].iloc[0]
                P_adj = dens * self.settings_dict["psi"] * speed**2   \
                          / self.settings_dict["gamma"]**2
                fan_P_tots = [press * P_adj for press in char_P_tots]

            descrip_text = "P_t characteristic of"
            # Now check if the duty point is off the end of the fan
            # characteristic.  The fan could be forced off the end
            # (in reverse flow or freewheeling) due to the action of
            # another fan or a train.
            # If it is, extend the characteristic using linear
            # extrapolation from the closest pair of points on the curve
            # to the duty point. We put a break in the curve to emphasize
            # to the user that it is extrapolation.
            # Note that if you don't think extrapolation should be used,
            # there is nothing to stop you defining the freewheeling and
            # reverse flow parts of the characteristic yourself.
            if fan_flow < fan_flows[0]:
                Q1, Q2 = fan_flows[:2]
                P1, P2 = fan_P_tots[:2]
                Qrange = fan_flows[-1] - Q1
                # Check if the new duty point is more than 5% of the fan's
                # volume flow range to the left of Q3 and extend the
                # characteristic if it is.  Put in a break in the line
                # that lasts for 5% of the fan's flow range, that ought
                # to be visible on most graphs.
                Q3 = Q1 - 0.05 * Qrange
                if fan_flow < Q3:
                    P3 = gen.Interpolate(Q1, Q2, P1, P2, Q3, True, self.log)
                    P4 = gen.Interpolate(Q1, Q2, P1, P2, fan_flow, True, self.log)
                    fan_flows = [fan_flow, Q3, "     "] + fan_flows
                    fan_P_tots = [ P4,     P3, "     "] + fan_P_tots
            elif fan_flow > fan_flows[-1]:
                Q1, Q2 = fan_flows[-2:]
                P1, P2 = fan_P_tots[-2:]
                Qrange = Q2 - fan_flows[0]
                Q3 = Q2 + 0.02 * Qrange
                if fan_flow > Q3:
                    P3 = gen.Interpolate(Q1, Q2, P1, P2, Q3, True, self.log)
                    P4 = gen.Interpolate(Q1, Q2, P1, P2, fan_flow, True, self.log)
                    fan_flows.extend(["     ", Q3, fan_flow])
                    fan_P_tots.extend(["     ", P3, P4])


        # Define the conversion keys for the calling routine.
        x_USconv = these_props["Xconversion"]
        y_USconv = these_props["conversion"]

        # Now build some QA data that lets people trace where this data
        # came from.
        #

        QAlist = ["# Hobyah system/fan performance QA"] + self._QAlines() + [\
                  '# Property plotted, ' + prop,
                  '# Property description, ' + these_props["descrip"],
                  '# Original locator, ' + orig_where,
                  '# Modified locator, ' + where,
                  '# Segment description, ' +  'To do',
                  '#',  # Not used (plot time used)
                  '#',
                  '# X conversion key, "' + x_USconv + '", '
                    + USc.ConversionDetails(x_USconv),
                  '# Y conversion key, "' + y_USconv + '", '
                    + USc.ConversionDetails(y_USconv)[:-1],
                 ]

        # Get the column headers for a transient plot.
        col_headers = self._ColHeaders("Volume flow", prop, units)

        # autolabel = 'fan property "' + prop + '" with no autolabel'

        # Build the autolabel.  It's easier to do it here than in
        # PROC _BuildAutoLabel.
        time_text = gen.RoundText(result_time, 5)
        autolabel = (descrip_text + ' fan ' + self.OptQuotes(fan_name)
                     + ' at ' + time_text + " sec " + direct_text)

        return(QAlist, fan_flows, x_USconv, fan_P_tots, y_USconv, autolabel,
               col_headers)


    def _BuildAutoLabel(self, curve_type, prop, units, orig_where, where,
                      result_time = -1):
        '''Take a curve type, a property name, a set of locations, and
        (optionally) a time.  Turn them into an autolabel for the curve.
        This routine assumes that the property and locations have already
        been checked in earlier routines.

        Parameters:
            self            class       Literally everything in the class.
            curve_type      str         "transient", "profile", "waterfall"
                                        etc.
            prop            str         A string naming the property to plot
                                        that has been checked.
            units           str         "si" or "us".  Not used to convert
                                        the data, just to put the correct
                                        units in the autolabel.
            orig_where      str         A string defining where to plot in
                                        the form that was given in the input
                                        file, e.g. route2@1200.5 (for QA
                                        purposes).
            where           str         A string defining where to plot in a
                                        form that matches a pandas database
                                        in the binary file, e.g. "101-2m".
                                        When tunnel properties are being
                                        seen by a train that is in the open
                                        air, it will be "outside".
            result_time     float       The time that a profile was really
                                        plotted at, which may be equal to or
                                        less than the time asked for.

        Returns:
            autolabel         str       A line of text that can be used as
                                        a graph key entry.


        '''
        these_props = self.properties[prop.lower()]

        # Get the first part of the autolabel, the description. Capitalize
        # it if the first letter is lower case.
        first = these_props["descrip"] + " "
        if first[0].islower():
            # This if statement is to let us avoid turning "SES volume flow"
            # into "Ses volume flow", which is what would happen if we used
            # .capitalize() on that string.
            first = first[0].capitalize() + first[1:]

        # Figure out what the distance units text should be, in case we
        # need it.
        if units == "us":
            dist_unit = " ft "
        else:
            dist_unit = " m "

        # Get the second part, which depends on a few factors.
        if curve_type == "transient":
            # Figure out if the user gave a distance along a route, distance
            # from the down end of a train or directly referenced a section,
            # segment, subseg or subpoint.
            if "@" in orig_where:
                parts = orig_where.lower().split(sep = '@')
                # It was something like "train12@-50" or "route5@2000".
                entity_text = parts[0][5:]
                # Check if the property was intrinsic to the train or
                # a property seen by a passing train.
                if these_props["place"] == "train":
                    second = "train " + entity_text
                else:
                    # It was seen by a passing train.  Include the distance
                    # in the label and whether it was in the annulus or not.
                    dist_text = parts[1]
                    # Knock off any trailing ".0" in the distance text.
                    if dist_text[-2:] == ".0":
                        dist_text = dist_text[:-2]
                    # They gave a distance along a route or offset from a train
                    # end.
                    if parts[0][:5] == "route":
                        second = ("at " + dist_text + dist_unit
                                  + "on route " + entity_text
                                  + " (" + self._BuildSESLocator(where) + ")")
                    else:
                        if dist_text[0] != "-":
                            # It's going down the route.  Check for a leading plus
                            # sign and remove it if it is there.
                            if dist_text[0] == "+":
                                dist_text = dist_text[1:]
                            second = (dist_text + dist_unit + "down from the "
                                      + "down end of train " + entity_text
                                      + " (in front of it)")
                        else:
                            # The distance is going up the route.
                            # Figure out if the point we are plotting at is alongside
                            # the train or so far back that it is behind the tail
                            # and set the autolabel accordingly.
                            # We can't do this check at the moment because we have
                            # no data on the types of each train number (it's not
                            # in the .sbn file yet) so we just assume it is in
                            # the train's annulus.
                            if True:
                                second = (dist_text[1:] + dist_unit + "up from the "
                                          + "down end of train " + entity_text
                                          + " (in the annulus)")
                            else:
                                second = (dist_text[1:] + dist_unit + "up from the "
                                          + "down end of train " + entity_text
                                          + " (behind the tail)")
            elif where[:4] == "zone":
                # It's a plot of heat flows over all the subsegments
                # in a zone.
                second = "in zone " + where[4:]
            else:
                # The user specified an SES location directly.  Give the
                # resulting SES location.
                loc_text = self._BuildSESLocator(where)
                if loc_text[:8] == "subpoint":
                    # "at subpoint 132-5m"
                    second = "at " + loc_text
                else:
                    # "in section 132", "in segment 132", "in subseg 132-5"
                    second = "in " + loc_text
        elif curve_type == "profile":
            # It is a profile, so it must have an "@" in it.
            # It was something like "train12@-50" or "route5@2000".  We
            # split 'where' instead of orig_where because 'where' has
            # the time that was actually used. 'orig_where' has the time
            # that was asked for.
            parts = where.lower().split(sep = '@')
            # Get the number of the train or route as a string.  This
            # is fragile, as if we feed it more than one group of digit
            # characters they will get run together.  This is unlikely to
            # happen in SES but it might if we re-use this code elsewhere.
            entity_text = "".join(filter(str.isdigit, parts[0]))
            time_text = gen.RoundText(result_time, 5)
            if these_props["transient"] == False:
                # It is not a transient profile but a fixed one (such as
                # a vertical profile along a route.
                second = "along route " + entity_text
            else:
                second = ("along route " + entity_text + " at "
                          + time_text + " sec")
        return(first + second)


    def _QAlines(self):
        '''Return a set of lines of QA data with data about the
        provenance of the binary file.

        Parameters:
            self          class     Literally everything in the class.

        Returns:
            A list of QA data needed by many different routines.

        '''
        return(['# Name of binary, "' + self.bin_name + '"',
                 '# SES file, "' + self.runfile_name + '"',
                 '# SES header, "' + self.header + '"',
                 '# SES footer, "' + self.footer + '"',
                 '# Program, ' + self.full_prog,
                 '# Date created, "' + self.when_who + '"'])


    def _BuildSESLocator(self, where):
        '''Take a string with a section, segment, subseg or subpoint locator
        (e.g. "sec102", "594", "105-3" or 105-2m) and turn them into text
        suitable for use in an autolabel.  This assumes that the string has
        been checked by other routines and is built correctly.


        Parameters:
            self            class       Literally everything in the class.
            where           str         A string defining where to plot in a
                                        form that matches a pandas database
                                        in the binary file, e.g. "101-2m".

        Returns:
            locator         str         One of the following:
                                          "outside",
                                          "section 210",
                                          "segment 132",
                                          "subseg 153-2",
                                          "subpoint 207-9b".
        '''
        if where[:3] == "sec":
            locator = "section " + where[3:]
        elif where == "outside":
            locator = "outside"
        elif "-" not in where:
            # If it's just a number then it is a segment
            locator = "segment " + where
        elif where[-1] in "bmf":
            locator = "subpoint " + where
        else:
            locator = "subseg " + where
        return(locator)


    def GetTransientData(self, prop, orig_where, where, line_text, units = "si"):
        '''Take the contents of an SES file, a location and a property
        to plot against time.  We assume that the location and property
        have either already been checked or have been generated internally
        and are correct.  Make two lists: print times on the X axis
        and the SI values of the property on the Y axis.  Also return the
        keys needed to convert the values to US units and some QA data
        suitable for putting at the top of the curve data file.

        Parameters:
            self            class       Literally everything in the class.
            prop            str         A string naming the property to plot
                                        that has been checked.
            orig_where      str         A string defining where to plot in
                                        the form that was given in the input
                                        file, e.g. route2@1200.5 (for QA
                                        purposes).
            where           str         A string defining where to plot in a
                                        form that matches a pandas database
                                        in the binary file, e.g. "101-2m".
            line_text       str         The text of the line being
                                        processed.  Part of the QA.
            units           str         "si" or "us".  Not used to convert
                                        the data, just to put the correct
                                        units in the autolabel.

        Returns:
            QAlist          []          A list of lines tracing the data.
            x_data          []          A list of X-values (time in
                                        seconds).
            x_USconv        str         "seconds", signifying that time in
                                        US units is the same as in SI units.
            y_data          []          A list of Y-values in SI units.
            y_USconv        float       The key to use in UScustomary.py to
                                        convert the Y values from SI to US
                                        units.
            autolabel       str         A line of text that can be used as
                                        a graph key entry.
            col_headers [[str],[str]]   A list of two lists of strings
                                        used as headers.  They appear
                                        above each column if someone
                                        loads a curve data file into
                                        a spreadsheet.
        '''
        these_props = self.properties[prop.lower()]

        x_USconv = "seconds" # The X-axis is time.
        y_USconv = these_props["conversion"]

        # The x values are the print times except in data printed
        # after ECZ estimates.
        if prop.lower() in ("meandb_am", "meandb_pm", "meandb_off",
                            "meanw_am", "meanw_pm", "meanw_off",
                            "wallt_am", "wallt_pm", "wallt_used",
                            "misc_sens", "misc_lat",
                            "steady_sens", "steady_lat",
                            "ground_sens",
                            "airex_sens", "airex_lat",
                            "hvac_sens", "hvac_lat", "hvac_tot"):
            x_data = self.ECZ_indices
        else:
            x_data = self.print_times
        if where == "open_air":
            # The location is outside the tunnel.  Get the value outside.
            # into a list that is the same length as the x_data.
            y_data = [these_props["open_air"]] * len(x_data)
            autolabel = self._BuildAutoLabel("transient", prop, units,
                                             orig_where, "outside")
            descrip = "In the open air"
        elif prop in ("pipetemp", "pipe_ht"):
            # We need to be careful with SVS cooling pipes, as not every
            # subsegment or subpoint will have a cooling pipe passing
            # through it.
            # We can plot at a distance along a pipe, a distance along
            # a route and along a pipe or route at an instant in time.
            # Need to figure out if more than one pipe can pass through
            # a single segment: if only one can be in a segment we can
            # plot at subsegments and at subpoints; if more than one
            # can, we will have to choose a location and which pipe to
            # plot at.
            pass
        else:
            # It is inside the tunnel, in a zone or on a train.  First
            # check if the location is a segment.  If it is, turn the
            # segment number 'where' into an integer.
            if these_props["place"] == "segment":
                segnum = int(where)
                y_data = these_props["var_name"][segnum]
            elif "zone" in where:
                # This is a property across an entire zone.
                y_data = these_props["var_name"][where]
            else:
                y_data = these_props["var_name"][where]
                if "sec" in where:
                    # Get the description from the first segment in the
                    # section type.
                    segnum = self.sec_seg_dict[where][0]
                else:
                    segnum = int(where.split(sep='-')[0])




            # Check whether the values should be multiplied by -1.  This
            # occurs with properties like "-qcold" which is just "qcold"
            # multiplied by -1.
            if prop[0] == "-":
                y_data = [-value for value in y_data]
            autolabel = self._BuildAutoLabel("transient", prop, units,
                                             orig_where, where)
            # Check if the values need to be transformed into per unit
            # length values.
            if prop[-3:] == "pul":
                # This is a profile that is to be plotted as a value per metre
                # (or per foot) profile ("pul" is from "per unit length).
                # It's a little odd to want to plot Watts/metre in a
                # transient plot, but there's no reason not to include it.
                # We divide the value by the subsegment length in metres.
                # The conversion factor handles the conversion to feet.

                replacements = []
                # Get the length of the subsegments.
                try:
                    # First check if it is in a line segment.
                    sublength = self.form3_dict[segnum]["sublength"]
                except KeyError:
                    # It is in a vent segment.  This can't happen in
                    # standard SES routes (they can only contain line
                    # segments).  But it can happen in custom routes,
                    # where we have vent segments as pressure taps to
                    # atmosphere in smoke ducts - it lets us get the
                    # correct absolute air pressure in the duct.
                    sublength = self.form5_dict[segnum]["sublength"]
                y_data = [value / sublength for value in y_data]


        # Now build some QA data that lets people trace where this data
        # came from.
        #
        QAlist = ["# SES transient QA"] + self._QAlines() + [\
                  '# Property plotted, ' + prop,
                  '# Property description, ' + these_props["descrip"],
                  '# Original locator, ' + orig_where,
                  '# Modified locator, ' + where,
                  '# Segment description, ' +  '',
                  '#',  # Not used (plot time used)
                  '#',
                  '# X conversion key, null, 1.0',
                  '# Y conversion key, "'
                    + these_props["conversion"] + '", '
                    + USc.ConversionDetails(these_props["conversion"]),
                 ]

        # Get the column headers for a transient plot.
        col_headers = self._ColHeaders("Time", prop, units)
        # Set a flag that this plot can only be plotted against time.
        TX_axes = False

        return(QAlist, x_data, x_USconv, y_data, y_USconv, autolabel, col_headers, TX_axes)


    def RouteAt(self, where, prop, curve_type, units, file_name,
                optionals_dict, line_number, line_text):
        '''Take the location of a property to plot against distance, something
        like "route4umd@1200".  This means "plot something along route 4 at
        time 1200 seconds, or the closest lower time if 1200 is not in the
        SES output."  The "umd" entry specifies that the points plotted
        are to be at the up end, midpoint and down end of any subsegments
        in the list.  Variants can be "ud" (up end and down end only), "m"
        (midpoints only) etc.  It will even handle "du" as if it was "ud".
        Check if the route definition is syntactically valid and return an
        error message if it is not.  If it is valid, check if this route
        number exists in the SES run and return error messages if it does
        not.
        Check that the time is valid.
        If everything is OK, figure out the list of keys to use to get the
        transient data out of the relevant pandas DataFrame in the binary
        file and return the keys.
        This routine assumes that the property has already been checked
        by a call to self.CheckProperty.  If a dud property is provided
        it will cause an exception.

        Parameters:
            self            class       Literally everything in the class.
            prop            str         A string naming the property.
            where           str         A string defining where to plot
            curve_type      str         A string describing what kind of
                                        curve this is, e.g. transient,
                                        profile etc.  Used in error
                                        messages.
            units           str         The system of units the input is in.
                                        This could be "si" or "us".
            file_name       str         The name of the file being processed
                                        when this routine was called.  Used
                                        in error messages.  Not the name of
                                        the SES file being plotted from.
            optionals_dict  {}          Dictionary of the optional entries
                                        on the line.
            line_number     int         The line number being processed.
                                        Used in error messages.
            line_text       str         The text of the line being
                                        processed.  Used in error messages.


        Returns:
            ??


        Errors:
            Raises 5261 if a pressure profile had an optional argument that
            gave a vent segment to take the pressure at the start of the
            route from, but the vent segment is not in the run.
            Raises 5262 if the definition had no "@" in it.
        '''



        # Figure out what key to use from the plot type's properties and
        # whether we can allow it not to have a time entry.
        these_props = self.properties[prop.lower()]
        keytype = these_props["place"]
        transient = these_props["transient"]

        if "@" not in where:
            # There was no "@" in the entry.
            err = ('> Tried to plot a curve in "' + file_name + '",\n'
                   '> but found that the location identifier was\n'
                   '> invalid.  It was "' + where + '" whereas it should\n'
                   '> be something like "route4@120".\n'
                   '> Please edit the file to correct it.'
                   )
            gen.WriteError(5262, err, self.log)
            gen.ErrorOnLine(line_number, line_text, self.log, False)
            return(None)


        # Check the general structure of the location.  This returns
        # the name of the entity in lower case ("route" is the only
        # option at the moment), the entity number as an integer and
        # the time as a float.  If it is not a transient plot the time
        # will be ignored and returned as -1.
        allowed = ["route", ]
        result = self._CheckAt(where, allowed, "umd", file_name, line_number, line_text)
        if result is None:
            return(None)
        else:
            (entity, entity_no, locator, time) = result

        # Check if this route number (entity_no) exists in this SES file.
        result = self._CheckRouteNumber(entity_no, where,
                        file_name, line_number, line_text)
        if result is None:
            return(None)

        # Set the default print time to be the last time step.  This catches
        # the case where the time in the input is long after the run ends.
        result_time = self.print_times[-1]
        # Now get the print time equal to or just below the desired time.  If
        # a user puts in a negative time we don't fault, we just print at zero
        # seconds.
        for index, p_time in enumerate(self.print_times):
            # We check math.isclose first, in case there are slight floating
            # point mismatches.  Python's 'math.isclose' function treats a
            # value that is within 10-9 of (in this context, one nanosecond
            # below) the desired time as being close enough to match.
            # After we check that, we check if the current time is higher
            # than the desired time.  If it is we print at the time before the
            # current time.
            if math.isclose(time, p_time):
                result_time = p_time
                break
            elif p_time > time:
                # The current entry in the print times is too high.  Get
                # the one below and break.
                result_time = self.print_times[index - 1]
                break

        # Check if the default locators have been asked for and if so, set
        # them for plots along subseg and subpoints.  Locators are ignored
        # in plots along sections and segments so there is no need to set
        # defaults for those.

        if locator == "#default":
            if keytype == "subseg":
                # These are properties that are constant along the length
                # of subsegments, such as dry-bulb temperature.  Set the
                # locator to "ud" so that we get a stepped curve.
                locator = "ud"
            elif keytype == "subpoint":
                # These are properties that vary within subsegments, such
                # as volume flow in the annulus around trains.  Get the
                # maximum detail by default.
                locator = "umd"
            else:
                # It is a curve that does not use locators.
                locator = "unused"
        else:
            # The user gave a string in the input file.  Sort it
            # into reverse alphabetical order, so that it is easier
            # to process.
            locator = ''.join(sorted(locator, reverse= True))

        # Now we figure out if this plot should be at section ends, segment
        # ends, subsegment ends or subpoint locations.  For each, generate
        # a suitable set of lists to use in the pandas DataFrames or the
        # route lists.
        if keytype == "section":
            # It is plots at section ends.  Get the chainages
            # at the ends of sections.
            chs_base = self.form8_dict[entity_no]["sec_chs"]
            distances = list(np.repeat(chs_base, 2))[1:-1]

            # Get the section numbers.  Note that these may be
            # negative, signifying that the section is in the route
            # backwards.
            keys_base = self.form8_dict[entity_no]["sec_list2"]
            keys = list(np.repeat(keys_base, 2))
        elif keytype == "segment":
            # Get the chainages at the ends of segments from form 8.
            # The 'np.repeat' function is a way of turning a list of
            # chainage (e.g. [100.2, 500.5, 720.8]) into a list
            # of doubles ([100.2, 100.2, 500.5, 500.5, 720.8, 720.8]).
            # We only have one instance of the first and last chainages,
            # i.e. we actually want [100.2, 500.5, 500.5, 720.8]
            chs_base = self.form8_dict[entity_no]["seg_chs"]
            distances = list(np.repeat(chs_base, 2))[1:-1]

            # Get the segment numbers.  Note that these may be
            # negative, signifying that the segment is in the route
            # backwards.
            keys_base = self.form8_dict[entity_no]["seg_list"]
            keys = list(np.repeat(keys_base, 2))
        elif keytype in ("subseg", "subpoint"):
            # Build a list of the relevant keys from the list of
            # segments in the route.
            sub_chs2 = self.form8_dict[entity_no]["sub_chs2"]
            # Do "umd", "ud" and "m" first, as these are the most
            # likely cases.  Then do "u" and "d" as these are easy.
            # Leave the weirdest ones ("um" and "md") for last.  In
            # all cases the segment numbers may be negative.
            if locator == "umd":
                keys =  list(sub_chs2.keys())
            elif locator == "ud":
                # We want the up ends and down ends in the route (back ends
                # and forward ends in the subsegments.  Pull out all the
                # keys in "sub_chs2" that don't end in "m" (midpoint).
                keys =  [key for key in sub_chs2 if key[-1] != "m"]
            elif locator == "m":
                keys =  list(self.form8_dict[entity_no]["sub_midIDs"])
            elif locator == "u":
                keys =  list(self.form8_dict[entity_no]["sub_upIDs"])
            elif locator == "d":
                keys =  list(self.form8_dict[entity_no]["sub_downIDs"])
            elif locator == "um":
                subs_to_remove =  list(self.form8_dict[entity_no]["sub_downIDs"])
                keys = [key for key in sub_chs2 if key not in subs_to_remove]
            elif locator == "md":
                subs_to_remove =  list(self.form8_dict[entity_no]["sub_upIDs"])
                keys = [key for key in sub_chs2 if key not in subs_to_remove]
            else:
                print("Fouled up in classSES.RouteAt with an invalid subpoint "
                      "locator:", locator)
                gen.OopsIDidItAgain(log)
                sys.exit()
            # Now that we have the keys we need, build a list of the
            # chainages.
            distances = [sub_chs2[key] for key in keys]

            # If we are plotting a subsegment property strip off all the
            # instances of "b", "m" and "f" from the keys, as these are
            # what the subsegment pandas databases need.
            if keytype == "subseg":
                keys = [key[:-1] for key in keys]
        elif keytype in ("route_icons", "route"):
            # We only came here to check the route number and get the time,
            # we spoof the distances and keys.
            distances = "Unused variable set in RouteAt"
            keys = "Unused variable set in RouteAt"

        if prop.lower() == 'dp':
            # The 'dp' plot type in profiles is a cumulative pressure
            # profile and has an optional argument that returns the
            # number of a segment to get the datum pressure from.
            # This is intended to be used in smoke ducts with a pressure
            # tapping at the up end in the route from the duct to
            # atmosphere.
            try:
                datumseg = int(optionals_dict["datum"])
            except KeyError:
                pass
            else:
                # Check if the vent segment exists and fault if it
                # does not.
                if datumseg not in self.form5_dict and  \
                   datumseg not in self.form3_dict:
                    err = ('> Tried to plot a pressure profile in "' + file_name
                             + '",\n'
                           '> but found that the optional argument "datum"\n'
                           '> (which gives a segment number to take a\n'
                           '> pressure from to offset the pressure profile\n'
                           '> by) gave a dud segment number (' + str(datumseg)
                             + ').\n'
                           '> Please edit the file to give a valid segment\n'
                           '> number or remove the optional entry.'
                          )
                    gen.WriteError(5261, err, self.log)
                    gen.ErrorOnLine(line_number, line_text, self.log, False)
                    return(None)

        return(transient, distances, keys, time, result_time)


    def _GetChainages(self, nose_locn, index, result_time, profile):
        '''Take a train nose chainage index number, time and the type
        of profile wanted (flat, stack or route).
        Build a sorted list of the nose and tail chainages along with any
        chainages of interest along the length of the train.  Build
        another list with the associated elevations.
            If the profile is "flat", set the nose and tail chainages and set
            the elevations to zero.
            If the profile is "route", use the route section chainages/elevations
            If the profile is "stack", use the elevations derived from stack
            heights.  If the train is entirely outside the tunnels, return an
            empty list.


        Parameters:
            self            class       Literally everything in the class.
            where           str         A string defining where to plot in a
                                        form that this routine understands.
            optionals_dict  {}          A dictionary of optional entries
                                        that set what kind of Y-values to
                                        use in the icons.
            result_time     float       The time in the pandas database to
                                        take the results from.  This will be
                                        equal to or lower than the time the
                                        user requested.
            profile         str         "route", "stack" or "flat".  If
                                        it is "stack", clip the train
                                        so that only the portion of it
                                        that is inside the tunnel is
                                        shown.


        Returns:
            A list of sub-lists.  There is one sub-list for each train
            at the timestep.  Each sub-list has four entries:
            chs             []          A list of chainages, starting at
                                        the tail and ending at the nose.
            elevs           []          A list of elevations at each
                                        chainage.
            upclip          bool        True if the train has its up end
                                        outside the tunnel and the entry
                                        in "profile" is "stack".
            downclip        bool        True if the train has its down end
                                        outside the tunnel and the entry
                                        in "profile" is "stack".
            gnucomment      "str"       A descriptive comment to add to
                                        the gnuplot file.  Example:
                                        "train 5 on route 3 at time 240.0"
        '''
        # Get details of the train: route it is on and length.
        tr_route = self.route_num.loc[result_time, index]
        tr_type = self.train_type.loc[result_time, index]
        tr_length = self.form9_dict[tr_type]["length"]
        tail_locn = nose_locn - tr_length

        # Set the default values for clipping the up and down end.
        upclip = False
        downclip = False

        # Now process the train, depending on whether this profile is
        # "flat" (nice and easy), "route" (show the changes of track
        # elevation along the train) or "stack" (show the part of the
        # train that is underground and show the changes of stack
        # elevation along the train.
        if profile == "flat":
            # Use zero for the elevations.
            chs_list = [tail_locn, nose_locn]
            elevs_list = [0.0, 0.0]
        elif profile == "route":
            # Figure out the elevations of the nose and tail and
            # possible changes of gradient along the length of the
            # train.  This only makes sense for runs with train
            # performance options 1 or 2.  Option 3 (explicit heat
            # gains) has no gradients in its routes, so we'll show
            # it as flat.
            if self.settings_dict["trperfopt"] == 3:
                chs_list = [tail_locn, nose_locn]
                elev_list = [0.0, 0.0]
            else:
                # Get the lists of the chainages and their associated
                # elevations.
                chs = self.form8_dict[tr_route]["single_chs"]
                elevs = self.form8_dict[tr_route]["elevations"]
                chs_list, elevs_list = self._GetTrainElevs(nose_locn,
                                                    tail_locn, chs, elevs)
        else:
            # The profile must be "stack".  Figure out the elevations from
            # the profile generated by the segment stack heights instead of
            # the route sections.
            seg_chs = self.form8_dict[tr_route]["seg_chs"]
            seg_elevs = self.form8_dict[tr_route]["seg_elevs"]
            # The train may be completely in the tunnel, partly
            # inside or entirely outside.  Figure out which it is.
            if nose_locn < seg_chs[0] or tail_locn > seg_chs[-1]:
                # It is in the open air.  Return an empty list.
                chs_list = []
                elevs_list = []
            else:
                if nose_locn > seg_chs[-1]:
                    # Chop off the nose and tell the program calling this
                    # to not draw an endcap on the down end of the train.
                    nose_locn = seg_chs[-1]
                    downclip = True
                if tail_locn < seg_chs[0]:
                    # Chop off the tail and tell the program calling this
                    # to not draw an endcap on the up end of the train.
                    tail_locn = seg_chs[0]
                    upclip = True
                chs_list, elevs_list = self._GetTrainElevs(nose_locn, tail_locn,
                                                         seg_chs, seg_elevs)
        return(chs_list, elevs_list, downclip, upclip)


    def _GetTrainElevs(self, nose_locn, tail_locn, chs, elevs):
        '''Take the chainages of a train nose and tail and a list
        of chainages and elevations (could be route elevations or
        stack elevations).  Return lists of the chainages and
        elevations between the nose and tail.
        This can also be used to get the elevations of fires,
        which start and end in a particular subsegment.


        Parameters:
            self            class       Literally everything in the class.
            nose_locn       float       The chainage of the train nose.
            tail_locn       float       The chainage of the train tail.
            chs             [float]     A list of chainages.
            elevs           [float]     A list of elevations at those
                                        chainages.

        Returns:
            chs_list        [float]     A list of chainages starting
                                        at the nose chainage and ending
                                        at the tail chainage.
            elevs_list      [float]     A list of elevations at those
                                        chainages.
        '''
        nose_elev = np.interp(nose_locn, chs, elevs)
        # If a train spawns near the start of the route, the tail could
        # be at a lower chainage and we must extrapolate to get its
        # elevation.
        if tail_locn < chs[0]:
            tail_elev = gen.Interpolate(chs[0], chs[1], elevs[0], elevs[1],
                                        tail_locn, True, self.log)
        else:
            tail_elev = np.interp(tail_locn, chs, elevs)

        # Get lists of all the points between the nose and tail.
        chs_list = ( [tail_locn]
                     + [ch for ch in chs if tail_locn < ch < nose_locn]
                     + [nose_locn]
                   )
        if len(chs_list) == 2:
            # There were no changes of track section under the train.
            # We have all the elevations we need.
            elevs_list = [tail_elev, nose_elev]
        else:
            # We need to put a slice of the list of elevations in the
            # middle of our list.  Find the extents of it and build
            # the list.
            start = chs.index(chs_list[1])
            finish = start + len(chs_list) - 2
            elevs_list = ( [tail_elev] + elevs[start:finish]
                            + [nose_elev]
                         )
        return(chs_list, elevs_list)


    def TrainIcons(self, where, line_number, optionals_dict, result_time):
        '''Take the route to show trains on, the dictionary of optional
        entries on the line and the time to plot them at.

        Figure out where the train ends are and what elevation they are at.
        Also figure out where changes of gradient happen.

        If the optional entry "profile" is assigned the value "flat" we just
        return lists of list of the down end chainage and up end chainage of
        the trains on that route, paired with the word "flat" instead of an
        elevation.
        If the optional entry "type" is assigned the value "stack", then
        when the train is in the tunnel the height profile is given by the
        stack heights (when the train is outside the tunnel the elevation
        is given by the route elevations).  If the optional entry "type"
        is "elevation" or is absent, the elevations are given by the route
        elevations.

        Parameters:
            self            class       Literally everything in the class.
            where           str         A string defining where to plot in a
                                        form that this routine understands.
            optionals_dict  {}          A dictionary of optional entries
                                        that set what kind of Y-values to
                                        use in the icons.
            result_time     float       The time in the pandas database to
                                        take the results from.  This will be
                                        equal to or lower than the time the
                                        user requested.

        Returns:
            A list of sub-lists.  There is one sub-list for each train
            at the timestep.  Each sub-list has four entries:
            chs             []          A list of chainages, starting at
                                        the tail and ending at the nose.
            elevs           []          A list of elevations at each
                                        chainage.
            gnucomment      "str"       A descriptive comment to add to
                                        the gnuplot file.  Example:
                                        "  # Train 5 at time 240"
        '''
        # We assume that "where" has already been checked for correctness
        # and whether the route number exists in this SES file (i.e. that
        # we've already called TransientAt().
        route_num = int(where[5:].split(sep = "@")[0])


        # Loop over the pandas database that contains the train nose
        # locations at the result time.  Build a list of entries that
        # the program calling us can use to build a set of gnuplot
        # "set object polygon" commands to draw the trains.
        train_defs = []
        for (index, nose_locn) in enumerate(self.train_locn.loc[result_time]):
            # Check if the nose location is a NaN.  If it is, the train
            # is not active at the moment and the train definitions
            # remains empty.
            tr_route = self.route_num.loc[result_time, index]
            if not(math.isnan(nose_locn)) and (int(tr_route) == route_num):
                # Call a routine that makes a list of the relevant
                # chainages and elevations.  First check if the user
                # set the optional entry that makes the locations flat.
                if "profile" in optionals_dict:
                    # This optional entry could be "flat", "stack" or "route".
                    profile = optionals_dict["profile"]
                else:
                    # The default is to use the elevations in the route
                    # definition.
                    profile = "route"

                chs, elevs, downclip, upclip = \
                    self._GetChainages(nose_locn, index, result_time, profile)
                if chs == []:
                    # The train was completely outside the tunnel system
                    # when we wanted to plot stack elevations.
                    pass
                else:
                    # Build a comment that goes at the end of the gnuplot
                    # command identifying the train
                    if index == 0:
                        train_num = 100
                    else:
                        train_num = index
                    gnucomment = ("train " + str(index)
                                  + " on route " + str(route_num)
                                  + " at time " + str(result_time)
                                  + ".  From line " + str(line_number))

                    train_defs.append([chs, elevs, gnucomment,
                                       downclip, upclip])
        return(train_defs)




    def _GetHeights(self, ch_list, route_num, optionals_dict):
        '''Take a list of chainages along a route and an optionals dictionary.
        Figure out if there was an optional entry for profile (it could be
        flat, stack or route).  If there was not, use stacks.
        Build a list of chainages and elevations.
            If the profile is "flat", set the elevations to zero.
            If the profile is "route", use the route section chainages/elevations
            If the profile is "stack", use the elevations derived from stack
            heights.
        This routine assumes that the chainage wanted does not lie outside
        the start and end chainages of the route or stack chainages.  It is
        intended for getting the heights of entities like fires and jet fans.


        Parameters:
            self            class       Literally everything in the class.
            chs_list        []          A list of chainages that we want the
                                        elevations at.
            optionals_dict  {}          A dictionary of optional entries
                                        that set what kind of Y-values to
                                        use in the icons.


        Returns:
            elevs           []          A list of elevations at each
                                        chainage.
        '''

        # Get the optional entry that makes the locations flat.
        if "profile" in optionals_dict:
            # This optional entry could be "flat", "stack" or "route".
            profile = optionals_dict["profile"]
        else:
            # The default is to use the elevations in the stack
            # definition, because this routine is called for entities
            # like jet fans or fires.
            profile = "stack"

        if profile == "flat":
            # Use zero for the elevations.
            elevs_list = [0.0]*len(ch_list)
        elif profile == "route":
            # Figure out the elevations of the nose and tail and
            # possible changes of gradient along the length of the
            # train.  This only makes sense for runs with train
            # performance options 1 or 2.  Option 3 (explicit heat
            # gains) has no gradients in its routes, so we'll show
            # it as flat.
            if self.settings_dict["trperfopt"] == 3:
                elevs_list = [0.0]*len(ch_list)
            else:
                # Get the lists of the chainages and their associated
                # elevations.
                chs = self.form8_dict[route_num]["single_chs"]
                elevs = self.form8_dict[route_num]["elevations"]
                elevs_list = [ np.interp(ch, chs, elevs) for ch in ch_list]
        else:
            # The profile must be "stack".  Figure out the elevations from
            # the profile generated by the segment stack heights instead of
            # the route sections.
            chs = self.form8_dict[route_num]["seg_chs"]
            elevs = self.form8_dict[route_num]["seg_elevs"]
            elevs_list = [ np.interp(ch, chs, elevs) for ch in ch_list]
        return(elevs_list)



    def JetFanIcons(self, where, line_number, optionals_dict, result_time):
        '''Take the route to show jet fans on, the dictionary of optional
        entries on the line and the time to plot them at.

        Figure out where the jet fans ends are and what elevation they are
        at, what gradient they are on and which direction they are blowing.

        If the optional entry "profile" is assigned the value "flat" we just
        return lists of list of the jet fan chainages on that route, paired
        with the word "flat" instead of an elevation.

        If the optional entry "type" is assigned the value "stack", then
        when the jet fans are in the tunnel the angle of the fans is given by
        the stack gradients.  If the optional entry "type" is "elevation" or
        is absent, the elevations are given by the route elevations.

        Parameters:
            self            class       Literally everything in the class.
            where           str         A string defining where to plot in a
                                        form that this routine understands.
            line_number     int         The line number in the input
                                        file.  It is included in a comment
                                        on a line in the .plt file for
                                        traceability
            optionals_dict  {}          A dictionary of optional entries
                                        that set what kind of Y-values to
                                        use in the icons.
            result_time     float       The time in the pandas database to
                                        take the operation of the jet fans
                                        from.  This will be equal to or lower
                                        than the time the user requested.


        Returns:
            A list of sub-lists.  There is one sub-list for each jet fan
            at the timestep.  Each sub-list has four entries:
            ch              float       The chainage of the midpoint of
                                        the jetfan.
            elev            float       A list of elevations at each
                                        chainage.
            gradient        float       The gradient of the segment that
                                        the jet fan is at the back end of.
            direction       int         +1 if the jet fan is blowing
                                        towards the down direction, -1
                                        if it is blowing up, 0 if it is
                                        off.
            gnucomment      "str"       A descriptive comment to add to
                                        the gnuplot file.  Example:
                                        "  # Jet fan in segment 102"
        '''
        # We assume that "where" has already been checked for correctness
        # and whether the route number exists in this SES file (i.e. that
        # we've already called TransientAt().
        route_num = int(where[5:].split(sep = "@")[0])

        # Build a list of entries that the program calling us can use to
        # build a set of gnuplot "set object polygon" commands to draw
        # the jet fans.
        jf_defs = []
        route_dict = self.form8_dict[route_num]

        if "profile" in optionals_dict:
            # This optional entry could be "flat", "stack" or "route".
            profile = optionals_dict["profile"]
        else:
            # The default is to use the elevations in the route
            # definition.
            profile = "route"


        for index, seg_num in enumerate(route_dict["seg_list"]):
            abs_seg = abs(seg_num)
            seg_type = self.form3_dict[abs_seg]["seg_type"]
            if 9 <= seg_type <= 14:
                # This segment has a jet fan in it.  Figure out which way
                # round it is in the route and whether it is running.
                if seg_num > 0:
                    chs = route_dict["seg_chs"][index:index + 2]
                else:
                    # The segment is in the route reversed.
                    chs = route_dict["seg_chs"][index - 1:index + 1]
                    chs.reverse()
                # Get the appropriate elevations.
                elevs = self._GetHeights(chs, route_num, optionals_dict)

                jf_props = self.form7_JFs[seg_type - 8]
                T_static = str(int(jf_props["static_thrust"] + 0.5)) + " N"
                if jf_props["fan_start"] <= result_time <= jf_props["fan_stop"]:
                    jet_vel = jf_props["jet_speed"]
                    if seg_num < 0:
                        # The segment is in the route reversed.
                        jet_vel = -jf_props["jet_speed"]
                    if jet_vel > 0:
                        gnucomment = T_static + " jet fan blowing down route "
                    else:
                        gnucomment = T_static + " jet fan blowing up route "
                else:
                    gnucomment = T_static + " jet fan inactive on route "
                gnucomment = gnucomment + str(route_num) +  \
                                        " at " + str(result_time) + " s"

                jf_defs.append([chs, elevs, gnucomment])
        return(jf_defs)



    def FireIcons(self, where, optionals_dict, result_time):
        '''Take the route to show fires on, the dictionary of optional
        entries on the line and the time to plot them at.

        Figure out the list of the segments on the route, which subsegments
        have fires in them and what elevation the subsegment ends are at.

        If the optional entry "profile" is assigned the value "flat" we just
        return lists of list of the down end chainage and up end chainage of
        the fires on that route, paired with the word "flat" instead of
        an elevation.
        If the optional entry "type" is assigned the value "stack", then
        the tunnel the height profile is given by the stack heights.  If
        the optional entry "type" is "elevation" or is absent, the elevations
        are given by the route elevations.

        Parameters:
            self            class       Literally everything in the class.
            where           str         A string defining where to plot in a
                                        form that this routine understands.
            optionals_dict  {}          A dictionary of optional entries
                                        that set what kind of Y-values to
                                        use in the icons.
            result_time     float       The time in the pandas database to
                                        take the results from.  This will be
                                        equal to or lower than the time the
                                        user requested.

        Returns:
            A list of sub-lists.  There is one sub-list for each fire
            at the timestep.  Each sub-list has four entries:
            chs             []          A pair of chainages, starting at
                                        the back end of the subsegment
                                        and ending at the forward end.
            elevs           []          A pair of elevations at each
                                        chainage.
            gnucomment      "str"       A descriptive comment to add to
                                        the gnuplot file.  Example:
                                        "fire 2 at time 240, 130-2, +2.8 m/s in annulus, +1.6 m/s open"
            reverse         Bool        If False, the segment is in the
                                        route "forward end before back end".
                                        If True, the segment is in the
                                        route "back end before forward end.
            v_ann           float       The air velocity in the annulus
                                        at the midpoint of the subsegment.
            v_open          float       The air velocity in the open tunnel
                                        at the midpoint of the subsegment.
        '''
        # First check if we actually have any fires in this file.
        fire_count = self.settings_dict["fires"]
        fire_defs = []

        if fire_count != 0:
            # We assume that "where" has already been checked for correctness.
            route_num = int(where[5:].split(sep = "@")[0])

            # Get the segments in this route.
            seg_list = self.form8_dict[route_num]["seg_list"]
            # Check each fire in form 4 for a match on segment numbers.
            for fire_num in range(1, fire_count + 1):
                fire_seg = self.form4_dict[fire_num]["seg_num"]

                if fire_seg in seg_list or -fire_seg in seg_list:
                    fire_subseg = self.form4_dict[fire_num]["subseg_num"]
                    sub_chs2 = self.form8_dict[route_num]["sub_chs2"]
                    seg_chs = self.form8_dict[route_num]["seg_chs"]
                    seg_elevs = self.form8_dict[route_num]["seg_elevs"]

                    # Build the keys we need in the form 8 dictionary sub_chs2.
                    # and get the chainages and elevations at the up and down
                    # ends.
                    if fire_seg in seg_list:
                        # The back end of the segment is the up end.
                        up_key =   str(fire_seg) + "-" + str(fire_subseg) + "b"
                        down_key = str(fire_seg) + "-" + str(fire_subseg) + "f"
                        reverse = False
                    else:
                        # The back end of the segment is the down end.
                        up_key =   str(-fire_seg) + "-" + str(fire_subseg) + "f"
                        down_key = str(-fire_seg) + "-" + str(fire_subseg) + "b"
                        reverse = True
                    # Check whether the fire is burning or not.
                    start = self.form4_dict[fire_num]["fire_start"]
                    stop = self.form4_dict[fire_num]["fire_stop"]
                    if start <= result_time <= stop:
                        operating = True
                    else:
                        operating = False

                    up_ch = sub_chs2[up_key]
                    down_ch = sub_chs2[down_key]

                    up_elev = np.interp(up_ch, seg_chs, seg_elevs)
                    down_elev = np.interp(down_ch, seg_chs, seg_elevs)

                    chs = (up_ch, down_ch)
                    elevs = (up_elev, down_elev)

                    # Get the air velocities passing the fire (the air
                    # velocity in the open tunnel and the air velocity in
                    # the annulus around any trains crossing the midpoint of
                    # the subsegment.

                    v_open = self.seg_vels.loc[result_time, fire_seg]

                    mid_key = str(fire_seg) + "-" + str(fire_subseg) + "m"
                    v_ann = self.subpoint_coldvels.loc[result_time, mid_key]

                    # Check if we need to multiply the air velocity by -1 to
                    # account for the segment orientation in the route.
                    if up_key[0] == "-":
                        v_open = -v_open
                        v_ann = -v_ann

                    gnucomment = ("fire " + str(fire_num)
                                  + " at time " + str(result_time) + " in "
                                  + mid_key[:-1] + ".  " + "v_ann = "
                                  + str(round(v_ann, 3)) + " m/s, v_open = "
                                  + str(round(v_open, 3)) + " m/s.")
                    fire_defs.append((chs, elevs, gnucomment,
                                      reverse, v_ann, v_open, operating))
        return(fire_defs)


    def GetProfileTransient(self, distances, prop, orig_where, where,
                            units, keys, line_text, optionals_dict,
                            result_time, time):
        '''Take a list of chainages along a route, the name of the property
        to plot, the system of units to use, a set of keys to a pandas
        database, the time to plot at and the time the user wanted to plot
        at.  Get the profile data out of the database at the required time.
        Return a list of the X values, a list of the Y values, a list of
        where in the geometry each value came from and a list of QA text to
        go at the top of the text file of curve data.
        The routines assumes that the property has been checked and that the
        list of keys and the result time all exist in the relevant pandas
        database.

        Parameters:
            self            class       Literally everything in the class.
            distances       []          A list of distances, these are the
                                        X values for the plot.
            prop            str         The name of the property to plot.
            orig_where      str         A string defining where to plot in a
                                        a form that the user understands.
            where           str         A string defining where to plot in a
                                        form that this routine understands.
            units           str         The system of units the results are
                                        to be in: "si" or "us".
            keys            []          A list of keys to the pandas
                                        database for that property.
            line_text       str         Text of the line this came from.  It is
                                        put into the lines of QA data.
            optionals_dict  {}          Dictionary of the optional entries
                                        on the line.  This is for pressure
                                        profiles 'DP'.
            result_time     float       The time in the pandas database to
                                        take the results from.  This will be
                                        equal to or lower than the time the
                                        user requested.
            time            float       The time the user requested the plot
                                        be at.


        Returns:
            QAlist          []          A list giving some lines of QA data.
            distances       []          A list of distances in SI units
            x_USconv        str         The name of the conversion key to
                                        use to convert distances from metres
                                        to feet ("dist1")
            values_SI       []          A list of Y-values in SI units.
            y_USconv        str         The name of the conversion key to
                                        use to convert the Y values from SI
                                        units to US units.
            autolabel       str         A line of text that can be used as
                                        a graph key entry.
            col_headers [[str],[str]]   A list of two lists of strings
                                        used as headers.  They appear
                                        above each column if someone
                                        loads a curve data file into
                                        a spreadsheet.
            QAdetails       []          A list detailing where each location
                                        on the X axis was in the SES file
                                        (e.g. chainage 1600 on route 1 could
                                        be "124-2b", the back end of the 2nd
                                        subsegment of segment 124.
        '''

        # Get the properties of this type of curve and the database to use.
        these_props = self.properties[prop.lower()]
        db_to_use = these_props["var_name"]
        place =  these_props["place"]


        QAlist = ["# SES profile (transient data) QA"] + self._QAlines() + [\
                  '# Property plotted, ' + prop,
                  '# Property description, ' + these_props["descrip"],
                  '# Original locator, ' + orig_where,
                  '# Modified locator, ' + where,
                  '# Plot time wanted, ' + str(time),
                  '# Plot time used, ' + str(result_time),
                  '#',
                 ]
        if units == "us":
            # Give the conversion factors to US units.
            QAlist.extend(['# X conversion key, "dist1", '
                             + USc.ConversionDetails("dist1"),
                           '# Y conversion key, "'
                             + these_props["conversion"] + '", '
                             + USc.ConversionDetails(these_props["conversion"]),
                          ])
        else:
            # The plot is in SI units.  Put in two blank lines in place of the
            # details of the conversion from SI to US units.
            QAlist.extend(['#', '#'])



        # Some values are vectors.  If a point is in the route backwards
        # and the property is a vector we want to multiply the value there
        # by -1.  We know which points are in the route backwards because
        # the key will start with a minus sign before the segment number.
        # We run through each key in the list of keys and pull out the
        # multiplier and the key to use.
        signed = these_props["signed"]
        values_SI = []
        for key in keys:
            if str(key)[0] != "-":
                # The location is in the route unreversed, use the two
                # base keys of time and location directly.
                try:
                    values_SI.append(db_to_use.at[result_time, key])
                except:
                    print("Fouled up with the keys of a profile:")
                    for name in ("place", "descrip", "conversion",
                                 "signed", "transient", "curve_types"):
                        print(name, ":", these_props[name])
                    print(db_to_use, result_time, key)
                    gen.OopsIDidItAgain(log)
                    sys.exit()
            else:
                # The location is in the route reversed.

                # Build a suitable type of key to the pandas database.
                # Sections, subsegs and subpoints are strings (or numpy
                # strings).  Segments are integers.
                if type(key) in (str, np.str_):
                    new_key = key[1:]
                else:
                    # Our route is of a segment-based property, or should be.
                    new_key = abs(key)
                if signed:
                    # It is a vector property (e.g. velocity), reverse the sign.
                    values_SI.append(-db_to_use.at[result_time, new_key])
                else:
                    # It is a scalar property (e.g. temperature) don't reverse
                    # the sign.
                    values_SI.append(db_to_use.at[result_time, new_key])
        # Define the conversion keys for the calling routine.
        x_USconv = "dist1"
        y_USconv = these_props["conversion"]

        # Define the QA data for each line.  This is the location preceded
        # by "#" so that gnuplot ignores it (for example, if a value plotted
        # at distance 15000 along the route happens to be at the back end
        # of subsegment 12 of segment 276 then the X value will be 15000,
        # the Y value will be whatever the value is and the QA details will
        # be "# 276-12b".  This is to let checkers trace where stuff came
        # from: with a bit of work the contents of the curve text file can
        # be used to check against the value in the SES .PRN, .TMP or .OUT
        # file at that point.
        QAdetails = ["# " + str(key) for key in keys]

        # Get the column headers for a route plot.
        col_headers = self._ColHeaders("Distance", prop, units)

        # Get the autolabel.
        autolabel = self._BuildAutoLabel("profile", prop, units,
                                         orig_where, where, result_time)

        # Set a flag that this plot can only be plotted against distance,
        # not against time
        TX_axes = False

        if prop[-3:] == "pul":
            # This is a profile that is to be plotted as a value per metre
            # (or per foot) profile ("pul" is from "per unit length).
            # We divide the value by the subsegment length in metres.
            # The conversion factor handles the conversion to feet.
            replacements = []
            for index, key in enumerate(keys):
                # Get the segment number and the subsegment length.  By
                # splitting on "-" and using the index "-2" we can avoid
                # having to distinguish between "-121-4m" and "157-3m".
                parts = key.split(sep = "-")
                seg_num = int(key.split(sep = "-")[-2])
                # Get the subsegment length.
                try:
                    # First check if it is in a line segment.
                    sublength = self.form3_dict[seg_num]["sublength"]
                except KeyError:
                    # It is in a vent segment.  This can't happen in
                    # standard SES routes (they can only contain line
                    # segments).  But it can happen in custom routes,
                    # where we have vent segments as pressure taps to
                    # atmosphere in smoke ducts - it lets us get the
                    # correct absolute air pressure in the duct.
                    sublength = self.form5_dict[seg_num]["sublength"]
                replacements.append(values_SI[index] / sublength)
            values_SI = replacements


        if prop == "dp":
            # This is a pressure profile.  The numbers in values_SI are
            # the individual pressure rises across each section.  We want
            # to daisychain these together into a pressure profile that
            # starts at zero at the up end.
            #
            # First we check if the user has set an optional argument
            # that gives a section number; we use the pressure drop
            # drop across this section as the first value.
            # This means we can put a pressure tap to atmosphere at
            # the start of the route inside a vent duct and plot a
            # profile starting at the true gauge pressure inside the
            # vent duct instead of zero Pa.
            # Note that if we do have an optional argument, we already
            # checked that the section number exists in PROC RouteAt
            # and raised an error if it didn't exist.
            try:
                datumsec = optionals_dict["datum"]
            except KeyError:
                datum = 0.0
            else:
                datum = self.sec_DPs["sec" + str(datumsec)]




            x_profile = [distances[0]]
            DP_profile = [0.0]
            QAdetails2 = [QAdetails[0]]
            # Add the other pressure drops.  We ignore the first entry
            # in "values_SI" (because we set it to zero) and we take the
            # even indices in the list.  I freely admit that this is
            # confusing but it does give us a pressure profile that
            # starts at 0 at the entry portal and ends near 0 at the exit
            # portal (it will only end at exactly zero if you have no
            # pressure changes across nodes.  Unfortunately these may
            # not be included because they are not written to the
            # file).
            for (index, pressure) in enumerate(values_SI):
                if divmod(index,2)[1] == 1:
                    x_profile.append(distances[index])
                    DP_profile.append(DP_profile[-1] + pressure)
                    QAdetails2.append(QAdetails[index])
            # Now overwrite the original variables.  If you need to compare
            # them in a profile you suspect might be wrong, plot the property
            # "dp_indiv" alongside "dp": it shows the individual section
            # pressure rises in top-hat profile form like the other profiles.
            distances = x_profile
            values_SI = DP_profile
            QAdetails = QAdetails2

        # Check if we need to multiply by -1.
        if prop[0] == "-":
            values_SI = [-value for value in values_SI]
        return(QAlist, distances, x_USconv, values_SI, y_USconv,
               autolabel, col_headers, QAdetails, TX_axes)


    def GetProfileFixed(self, prop, orig_where, where, optionals_dict,
                        units, line_text):
        '''Take the name of the property to plot, where to plot, the
        optionals dictionary and the system of units to use.  Get the
        data out of the appropriate dictionary: route data from form 8,
        areas/perimeters from forms 3 and/or 5.

        Return a list of the X values, a list of the Y values, a list of
        where in the geometry each value came from and a list of QA text to
        go at the top of the text file of curve data.
        The routines assumes that the property has been checked and that the
        list of keys is valid for the property.

        Parameters:
            self            class       Literally everything in the class.
            prop            str         The name of the property to plot.
            orig_where      str         A string defining where to plot in a
                                        a form that the user understands.
            where           str         A string defining where to plot in a
                                        form that this routine understands.
            optionals_dict  {}          A dictionary of optional entries
                                        that can alter the numbers being
                                        returned.
            units           str         The system of units the results are
                                        to be in: "si" or "us".
            line_text       str         Text of the line this came from.  It is
                                        put into the lines of QA data.


        Returns:
            QAlist          []          A list giving some lines of QA data.
            distances       []          A list of distances in SI units.
            x_USconv        str         The name of the conversion key to
                                        use to convert distances from metres
                                        to feet ("dist1")
            values_SI       []          A list of Y-values in SI units.
            y_USconv        str         The name of the conversion key to
                                        use to convert the Y values from SI
                                        units to US units.
            autolabel       str         A line of text that can be used as
                                        a graph key entry.
            col_headers [[str],[str]]   A list of two lists of strings
                                        used as headers.  They appear
                                        above each column if someone
                                        loads a curve data file into
                                        a spreadsheet.
            QAdetails       []          A list detailing where each location
                                        on the X axis was in the SES file
                                        (e.g. chainage 1600 on route 1 could
                                        be "124-2b", the back end of the 2nd
                                        subsegment of segment 124.
        '''

        # Get the properties of this type of curve and the database to use.
        these_props = self.properties[prop.lower()]
        place =  these_props["place"]

        # Where is something like "route5@who_cares_about_the_time" and
        # we have already checked it.
        route_num = int(where[5:].split(sep = "@")[0])


        QAlist = ["# SES profile (fixed data) QA"] + self._QAlines() + [\
                  '# Property plotted, ' + prop,
                  '# Property description, ' + these_props["descrip"],
                  '# Original locator, ' + orig_where,
                  '# Modified locator, ' + str(where),
                  '#',  # Not used (plot time wanted)
                  '#',  # Not used (plot time used)
                  '#',
                 ]
        if units == "us":
            # Give the conversion factors to US units.
            QAlist.extend(['# X conversion key, "dist1", '
                             + USc.ConversionDetails("dist1"),
                           '# Y conversion key, "'
                             + these_props["conversion"] + '", '
                             + USc.ConversionDetails(these_props["conversion"]),
                          ])
        else:
            # The plot is in SI units.  Put in two blank lines in place of the
            # details of the conversion from SI to US units.
            QAlist.extend(['#', '#'])

        # Now we figure out where the data should come from.
        complexity = these_props["complexity"]

        # First do a test for a weird one - a stack profile with a modification
        # for local segment area.  Stack profile has a complexity of "simple"
        # but when we want to modify it by area it becomes complex and we
        # combine elevations with areas.
        if (prop.lower() == "stacks" and "areamult" in optionals_dict):
            dict_to_use = these_props["var_name"][route_num]
            single_chs = dict_to_use[these_props["x_list"]]
            single_values = dict_to_use[these_props["y_list"]]
            distances = np.repeat(single_chs, 2)[1:-1]
            elevs_SI = np.repeat(single_values, 2)[1:-1]

            discard, areas_SI = self._SpoofPairs(self.properties["area"],
                                                 route_num)
            factor = float(optionals_dict["areamult"])
            minarea = min(areas_SI) * factor
            myzip = zip(elevs_SI, areas_SI)
            values_SI = [elev + area * factor - minarea for elev, area in myzip]
        elif complexity == "simple":
            # We can get the X and Y values directly by accessing a dictionary
            # with a couple of named variables without having to do any post-
            # processing.
            dict_to_use = these_props["var_name"][route_num]
            distances = dict_to_use[these_props["x_list"]]
            values_SI = dict_to_use[these_props["y_list"]]
        elif complexity == "double_up1":
            # This is a route property that we want to plot against
            # section chainage or segment chainage as a top-hat profile.
            # We stored the values in a list of single entries in the
            # route definition that we need to expand out.
            #
            dict_to_use = these_props["var_name"][route_num]
            single_chs = dict_to_use[these_props["x_list"]]
            single_values = dict_to_use[these_props["y_list"]]
            distances = np.repeat(single_chs, 2)[1:-1]
            values_SI = np.repeat(single_values, 2)
        elif complexity == "double_up2":
            # This is a segment property (e.g. area) that we want to
            # plot against segment chainage as a top-hat profile.
            # We need to get the list of segments in the route and
            # get the property out of the form 3 dictionary by using
            # the segment numbers as the keys in the form 3 dictionary.
            # We use this in a few places, so we make it a subroutine.
            dict_to_use = these_props["var_name"][route_num]
            distances, values_SI = self._SpoofPairs(these_props, route_num)

        # Check for any multipliers in the curve properties.
        if "multiplier" in these_props:
            mult = these_props["multiplier"]
            values_SI = [mult * value for value in values_SI]

        # Define the conversion keys for the calling routine.
        x_USconv = "dist1"
        y_USconv = these_props["conversion"]

        # if prop == "stacks":
        #     # A special for segment-based properties.  The QA details
        #     # give the segment number that the value ends at.
        #     QAdetails = [""] + ["  # seg " + str(seg) for seg in dict_to_use["seg_list"]]
        if prop in ("sec_nums", "ptot", "pstat"):
            # A special for section-based properties.  The QA details
            # give the section numbers at each end of the section.
            intermediate = ["  # sec " + str(sec) for sec in dict_to_use["sec_list"]]
            QAdetails = np.repeat(intermediate,2)
        elif complexity in ("double_up1", "double_up2"):
            # A special for segment-based properties.  The QA details
            # give the section numbers at each end of the section.
            intermediate = ["  # seg " + str(seg) for seg in dict_to_use["seg_list"]]
            QAdetails = np.repeat(intermediate,2)
        else:
            QAdetails = None

        # Get the column headers for a route plot.
        col_headers = self._ColHeaders("Distance", prop, units)

        # Get the autolabel.
        autolabel = self._BuildAutoLabel("profile", prop, units,
                                         orig_where, where)

        # Set a flag that this plot can only be plotted against distance,
        # not against time
        TX_axes = False

        return(QAlist, distances, x_USconv, values_SI, y_USconv,
               autolabel, col_headers, QAdetails, TX_axes)


    def _SpoofPairs(self, these_props, route_num):
        '''Take a dictionary of things defining the property we want
        and a route number.  Return a list of paired chainages and
        paired values.  The values are from a dictionary other than
        the route dictionary (which is why it is in a routine on its
        own, this is needed in a few places).
        '''
        # First get the chainages.  This curve needs to show a stepped
        # profile, so we want the interior points to be doubled up.
        dict_to_use = these_props["var_name"][route_num]
        single_chs = dict_to_use[these_props["x_list"]]
        distances = list(np.repeat(single_chs, 2))[1:-1]

        # Now get the list of segments, removing any negative signs.
        seg_list = [abs(seg) for seg in dict_to_use["seg_list"]]

        # Get the dictionary that holds Y values we want and the
        # key to it.
        sub_dict = these_props["sub_dict"] # Typically form3_dict
        sub_key = these_props["sub_key"] # A key to form3_dict "area"

        # Build a list of values then double them up too.
        single_values = [sub_dict[seg][sub_key] for seg in seg_list]
        values_SI = list(np.repeat(single_values, 2))
        return(distances, values_SI)


    def _ColHeaders(self, x_name, prop, units):
        '''Take a name for the X axis data (typically "Time" or "Distance"
        but could also be something like "Volume flow" on characteristics).
        Take the name of a property and the name of a system of units ("si"
        or "us").  Build a line that can be used as column headers in a text
        file holding curve data that can be plotted.

        Parameters:
            self            class       Literally everything in the class.
            distances       []          A list of distances, these are the
                                        X values for the plot.
            prop            str         The name of the property to plot.
            orig_where      str         A string defining where to plot in a
                                        a form that the user understands.
            where           str         A string defining where to plot in a
                                        form that this routine understands.
            optionals_dict  {}          A dictionary of optional entries
                                        that set what kind of Y-values to
                                        use in the icons.
            units           str         The system of units the results are
                                        to be in: "si" or "us".
            line_text       str         Text of the line this came from.  It is
                                        put into the lines of QA data.


        Returns:
            header_list     []
                                        on the X axis was in the SES file
                                        (e.g. chainage 1600 on route 1 could
                                        be "124-2b", the back end of the 2nd
                                        subsegment of segment 124.

        Errors:
            Raises 5201 if a new key to the X axis was added, without
            adding an entry for it to the dictionary named 'print_units'.

        '''
        # Build a set of units appropriate to each X axis name.
        print_units = {"time": ("s", "s"),
                       "distance": ("m", "ft"),
                       "timedist": ("m", "ft"),
                       "volume flow": ("m3/s", "cfm")
                      }
        try:
            (unit_SI, unit_US) = print_units[x_name.lower()]
        except KeyError:
            print('Ugh, need to add an entry for key "' + x_name.lower() + '" in\n'
                  'PROC _Colheaders in classSES.py.')
            err = ('> Tell the programmer that an entry for "' + x_name.lower() + '"\n'
                   '> needs to be added in classSES._Colheaders.'
                  )
            gen.WriteError(5201, err, self.log)
            gen.OopsIDidItAgain(self.log, file_name)
            # Use a sys.exit here.  This is lazy, but we should catch it in
            # development when any new print units on the X axis are added.
            # Yeah, I don't believe that either and I'm the one writing the
            # code.
            sys.exit()

        # Get the two units texts for the property on the Y axis.
        loc_prop = self.properties[prop.lower()]["conversion"]
        (discard, (SI_name_wide, US_name_wide)) = USc.ConvertToSI(loc_prop, 1.0, False, "")
        SI_name = SI_name_wide.rstrip()
        US_name = US_name_wide.rstrip()
        if x_name.lower() == "timedist":
            # This type of curve could be plotted against time or distance.
            # Both time and distance are given in the curve file, so we need
            # both of them in the list of headers.  We need five column headers
            header_list1 = ["Time", "Distance", "Value",    # SI data
                            "Distance", "Value",            # US data
                            "Plot distance", "Plot value"]
            header_list2 = [" (s) ", "  (m)   ","(" + SI_name + ")",
                            "  (ft)  ", "(" + US_name + ")"]
            # Assume that we are plotting against distance.  If we are not then
            # the routine that called this routine can change the entry from
            # distance to time.
            if units == "si":
                X_plot = "   (m)    "
            else:
                X_plot = "   (ft)   "
        elif x_name.lower() == "time":
            # This type of curve can only be plotted against time, so the
            # X axis values (times) in US units are the same as in SI units.
            # We only need three column headers.
            header_list1 = ["Time", "Value",    # SI data
                            "Value",            # US data
                            "Plot time", "Plot value"]
            header_list2 = [" (s) ", "(" + SI_name + ")",
                            "(" + US_name + ")"]
            X_plot = "   (s)   "
        else:
            # This type of curve is something where the X axis values in
            # SI units may differ from those in US units, such as pressure
            # versus volume flow on a fan characteristic.  We need four
            # column headers.
            header_list1 = [x_name, "Value",    # SI data
                            x_name, "Value",   # US data
                            "Plot " + x_name, "Plot value",
                          ]
            header_list2 = [" (" + unit_SI + ")",
                           " (" + SI_name + ")",
                           " (" + unit_US + ")",
                           " (" + US_name + ")",
                          ]
            # Set a relevant header for the column of X values being
            # plotted here.  The if clause below chooses between strings
            # like  "Plot volume flow (m^/s)" and "Plot volume flow (cfm)".
            if units == "si":
                X_plot = " (" + unit_SI + ")"
            else:
                X_plot = " (" + unit_US + ")"

        # Set a relevant header for the column of Y values that we plot.
        if units == "si":
            Y_plot = " (" + SI_name + ")"
        else:
            Y_plot = " (" + US_name + ")"

        header_list2.extend([X_plot, Y_plot])

        header_list = [header_list1, header_list2]
        return(header_list)


    def GetTrainData(self, prop, orig_where, where, line_text, units = "si"):
        '''Take the contents of an SES file, a location along a train and
        a property to plot against time.  We assume that the location and
        property have either already been checked or have been generated
        internally and are correct.

        Figure out if the property is a property associated with a train
        (e.g. train speed, drag coefficient) or a property associated with
        the SES geometry that is being seen by a passing train.
        Make two lists: print times on the X axis
        and the SI values of the property on the Y axis.  Also return the
        keys needed to convert the values to US units and some QA data
        suitable for putting at the top of the curve data file.

        Parameters:
            self            class       Literally everything in the class.
            prop            str         A string naming the property to plot
                                        that has been checked.
            orig_where      str         A string defining where to plot in
                                        the form that was given in the input
                                        file, e.g. route2@1200.5 (for QA
                                        purposes).
            where           str         A string defining where to plot in
                                        a form that matches a database key
                                        in the SES binary file, such as
                                        "101-2m".
            line_text       str         The text of the line being
                                        processed.  Used in error messages.
            units           str         "si" or "us".  Not used to convert
                                        the data, just to put the correct
                                        units in the autolabel.

        Returns:
            QAlist          []          A list of lines tracing the data.
            x_data          []          A list of X-values (time in
                                        seconds).
            x_USconv        str         "times", signifying that time in
                                        US units is the same as in SI units.
            y_data          []          A list of Y-values in SI units.
            y_USconv        float       The key to use in UScustomary.py to
                                        convert the Y values from SI to US
                                        units.
            autolabel       str         A line of text that can be used as
                                        a graph key entry.
            col_headers [[str],[str]]   A list of two lists of strings
                                        used as headers.  They appear
                                        above each column if someone
                                        loads a curve data file into
                                        a spreadsheet.
        '''
        these_props = self.properties[prop.lower()]
        db_to_use = these_props["var_name"]

        # Break out the train number from the locator.  It will be
        # something like "train25@-30".  We should have already checked
        # it was well-formed in _CheckAt so we don't need to test here.
        parts = where.split(sep = "@")
        tr_num = int(parts[0][5:])

        # First get the count of trains.  Note that this is wrong
        # if more than 100 trains were launched in SES but we'll
        # sort that out later.
        tr_count = len(self.train_locn.columns) - 1
        if tr_num > tr_count:
            # This train number did not enter the system during the run.
            # Spoof the data with two points so that gnuplot accepts it
            # as a valid curve.
            x_times = [0.0, 1.0]
            x_dists = [0.0, 1.0]
            y_data = [0.5, 0.5]
            # Get the column headers.
            col_names = self._ColHeaders("timedist", prop, units)

        elif these_props["place"] == "train":
            # The property being plotted is intrinsic to the train.
            # All we need is the train number.  We can ignore the
            # distance value after the "@".  We adjust the value of
            # "where" to make it clear to anyone looking into the
            # curve datafiles that the stuff after the "@" is ignored.
            where = where.split(sep = "@")[0]

            # We get the data from out of its DataFrame, ignoring the
            # NaN values.  This is a problem when two different trains
            # use the same train number, but we'll deal with that when
            # we have SES runs that go on long enough for SES to start
            # re-using train numbers.
            #
            # The Pandas "dropna" function is one that takes a series
            # and drops all the entries in which the value is a NaN.
            # When we built the database we put in NaN values at the
            # timesteps before the train entered and at the timesteps
            # after the train left.
            y_data = db_to_use[tr_num].dropna()

            if prop == "qtrains":
                # This is a special figure, volume flow of trains.  It's
                # completely useless except for QA and training graduates,
                # so it doesn't get its own set of arrays.  Instead, we
                # calculate it on the fly from train speed and train
                # area.

                # Convert train speeds from km/h to m/s.
                y_data = y_data / 3.6

                # Get the list of train types.
                tr_types = self.train_type[tr_num].dropna()

                # Train area can vary with time (if train numbers are
                # re-used) so we have to read it at each timestep.
                for time in y_data.index:
                    tr_type = int(tr_types[time])
                    tr_area = self.form9_dict[tr_type]["area"]
                    y_data[time] = y_data[time] * tr_area

            # Get the list of valid times for this train.  These are
            # (conveniently) the indices of y_data.  Get the chainage
            # as well, in case the user wants to plot against distance
            # instead of against time.
            x_times = y_data.index
            x_dists = list(self.train_locn[tr_num].dropna())
            if prop == "mode":
                # This is an integer corresponding to what the train is
                # doing (braking, accelerating, coasting, stationary etc.)
                # It is stored as one value at each print time, but we want
                # to make it a step-change curve.  There is a risk of
                # people who plot at long time intervals being thrown off
                # by the plots they get; but if you're looking that far
                # into SES train performance behaviour you should know
                # enough to plot at short time intervals (RTFM).
                x_times = np.repeat(x_times, 2)[1:-1]
                x_dists = np.repeat(x_dists, 2)[1:-1]
                y_data =  np.repeat(list(y_data), 2)[:-2]



        autolabel = self._BuildAutoLabel("transient", prop, units,
                                         orig_where, where)

        # Now build some QA data that lets people trace where the data
        # came from.
        #
        QAlist = ["# SES moving train data QA (time or distance on X axis)"]\
                  + self._QAlines() + \
                 ['# Property plotted, ' + prop,
                  '# Property description, ' + these_props["descrip"] + " train",
                  '# Original locator, ' + orig_where,
                  '# Modified locator, ' + where,
                  '#',  # Not used (plot time wanted)
                  '#',  # Not used (plot time used)
                  '#',
                 ]

        x_USconv = "dist1"
        y_USconv = these_props["conversion"]

        # Now handle the only two properties on moving trains that we
        # don't want the calling routine to be able to switch the axes of
        #
        if prop == "time":
            # This is a special property of trains.  It should only be
            # plotted against chainage (if you plot time against time all
            # you get is a straight line with equation y = x).  Spoof it
            # as a curve at one time that has distance on the X axis.
            QAlist[0] = "# SES moving train data QA (distance only on X axis)"
            QAlist.extend(['# X conversion key, "dist1", '
                             + USc.ConversionDetails("dist1"),
                           '# Y conversion key, "seconds", '
                             + USc.ConversionDetails("seconds")
                          ]
                         ),

            col_names = self._ColHeaders("distance", prop, units)
            TX_axes = False
            returnables = (QAlist, x_dists, x_USconv, x_times,
                           "seconds", autolabel, col_names, TX_axes)
        elif prop == "chainage":
            # This is also a special property of trains, like time was.
            # Spoof it as a transient curve.
            QAlist[0] = "# SES moving train data QA (time only on X axis)"
            QAlist.extend(['# X conversion key, "seconds", '
                             + USc.ConversionDetails("seconds"),
                           '# Y conversion key, "'
                             + these_props["conversion"] + '", '
                             + USc.ConversionDetails(these_props["conversion"])
                          ]
                         ),
            col_names = self._ColHeaders("time", prop, units)
            TX_axes = False
            returnables = (QAlist, x_times, "seconds", y_data,
                           y_USconv, autolabel, col_names, TX_axes)
        else:
            # This is a property that the user can choose to plot against
            # either time or chainage.  It is useful to see things like
            # train speed against time alongside train speed against distance.
            # The decision about which to plot is not made here, but in the
            # calling routine.

            QAlist.extend(['# X conversion key, "dist1", '
                             + USc.ConversionDetails("dist1"),
                           '# Y conversion key, "'
                             + these_props["conversion"] + '", '
                             + USc.ConversionDetails(these_props["conversion"])
                          ]
                         ),

            # Get the column headers for a transient plot of data attached
            # to a train (not data seen by a passing train)
            col_names = self._ColHeaders("timedist", prop, units)
            TX_axes = True
            returnables = (QAlist, x_times, x_dists, x_USconv, y_data,
                           y_USconv, autolabel, col_names, TX_axes)
        return(returnables)


    def IsTrafficProperty(self, prop):
        '''Return False.  This is a method used in classHobyah.py for
        road traffic.  It has no meaning in SES runs.
        '''
        return(False)


    def WriteInputFile(self, new_name, units, target):
        '''Generate an SES input file based on the contents of the class.
        This allows routines to generate multiple SES input files from the
        geometry in one .sbn file, which is useful when you want to create
        a score or so of input files that are mostly identical except for
        the location of a fire.

        This routine is not called by Hobyah or any other programs, it was
        written so that I can take the contents of a known-to-be-good SES
        run in a binary file, change the contents of the class instance,
        then write input files based on it for different versions of SES.


            Parameters:
                self          class     Literally everything in the class.
                new_name      str       The name of the ses file to write.
                units         str       If it is "US", writes the file in
                                        US units.  If it is SI, writes the
                                        file in SI units.
                target        str       The version of SES we want this file
                                        to be.  This could be:
                                         * "SES 4.1"
                                            The version released by the US
                                            Dept. of Transport in the early
                                            2000s
                                         * "OpenSES 4.2" or "OpenSES 4.3"
                                            OpenSES files as of May 2023
                                         * "Aurecon SES 10x.x"
                                            A code based on v4.1 & extended
                                            by Aurecon Australia Pty. Ltd.
                                         * "offline-SES 20x.x"
                                            A private development version.
                                         * "SVS 6.6.2", which WSP licence
                                           out.
                                        The text is not case-sensitive.

            Errors:
                Raises 5181 if the new name of the SES input file is not
                a string.
                Raises 5182 if the units string is not a string.
                Raises 5183 if the version string is not a string.
                Raises 5184 if we don't have permission to write to the
                new .ses input file.
                Raises 5185 if the argument for the units is not "SI"
                or "US".
                Raises 5186 if the argument for the version is not one
                of the strings in the tuple name "acceptables" below.

            Returns:
                True if we succeeded, the text of the error if it failed.

        '''
        # Make a list of suitable version strings first.
        acceptables = ("SES 4.10", "SES 4.1",         # Both v4.1 (2003)
                       "OPENSES 4.2", "OPENSES 4.3",  # As of April 2023
                       "AURECON SES 107.0",           # As of May 2020
                       "OFFLINE-SES 204.2",
                       "OFFLINE-SES 204.3",
                       "OFFLINE-SES 204.4",           # As of May 2023
                       "OFFLINE-SES 204.5",           # As of June 2023
                       "OFFLINE-SES 204.6",           # As of Jan 2025
                       "SVS 6.6.2",
                      )
        # Check that we have strings in the three arguments.  This routine
        # may be used by third-party scripts that I'll lash up, so we
        # want a good set of error checks.
        t1 = type(new_name)
        if t1 is not str:
            err =  ('> A call to WriteInputFile asked for an SES input\n'
                   "> file to be written but didn't give a string for\n"
                   '> the name, it gave a ' + str(t1) + ' ("'
                     + str(new_name) + '")\n'
                   '> instead.  Please set the first argument in the\n'
                   '> call to a valid string.'
                  )
            gen.WriteError(5181, err, self.log)
            # We don't return None for calls to this function because we'll
            # only ever call it from custom scripts or interactive sessions.
            # Return the text of the error instead.
            return(err)
        t2 = type(units)
        if t2 is not str:
            err =  ('> A call to WriteInputFile asked for an SES input\n'
                   "> file to be written but didn't give a string for\n"
                   '> the units text, it gave a ' + str(t2) + ' ("'
                     + str(units) + '")\n'
                   '> instead.  Please set the second argument in the\n'
                   '> call to a valid string ("US" or "SI").'
                  )
            gen.WriteError(5182, err, self.log)
            return(err)
        t3 = type(target)
        if t3 is not str:
            err =  ('> A call to WriteInputFile asked for an SES input\n'
                   "> file to be written but didn't give a string for\n"
                   '> the SES version, it gave a ' + str(t1) + ' ("'
                     + str(target) + '")\n'
                   '> instead.  Please set the third argument in the\n'
                   '> call to a valid string, one of\n'
                     + gen.FormatOnLines(acceptables)
                  )
            gen.WriteError(5183, err, self.log)
            return(err)



        try:
            ses = open(self.bin_path + new_name, 'w', encoding='utf-8')
        except PermissionError:
            err = ('> Skipping the recreation of "' + new_name + '", because\n'
                   "> you do not have permission to write to it.")
            gen.WriteError(5184, err, self.log)
            return(err)

        # Next check if we have a suitable set of units.
        if units.upper() not in ("SI", "US"):
            err = ('> A call to WriteInputFile asked for an SES input\n'
                   "> file to be written but didn't ask for it in US\n"
                   '> units or SI units, but in "' + units + '" instead.\n'
                   '> Please set the second argument in the call\n'
                   '> to either "SI" or "US".'
                  )
            gen.WriteError(5185, err, self.log)
            return(err)

        # Next check if we have a suitable SES program and version
        # number for the target.
        target = target.upper()
        if target not in acceptables:
            err = ('> A call to WriteInputFile asked for an SES input\n'
                   '> file to be written but gave an SES version number\n'
                   '> that was not recognised ("' + target + '") as the last\n'
                   '> argument in the call.  The only versions of SES\n'
                   '> that this script can write are:\n'
                   + gen.FormatOnLines(acceptables)
                  )
            gen.WriteError(5186, err, self.log)
            return(err)

        # If we get to here we can open the new SES input file.  Figure out
        # which units to use.
        if units.upper() == "SI":
            # We are using SI units.
            USunits = False
        elif units.upper() == "US":
            # We are using the unique value of the BTU that SES v4.1 uses.
            # This block of code will need to be edited if we ever add
            # support for SVS, which uses the International Tables BTU.
            prefix = "v41_"
            USunits = True

        # Write the lines of comment.  Check if the first line of comment
        # had anything on it describing what kind of SES run the original
        # binary file came from.
        try:
            firstline = self.comments[0]
        except IndexError:
            # There were no lines of comment at the top of the file.
            gen.WriteOut(target + "input file", ses)
        else:
            # Make a list of texts that I might put in the first line of
            # an SES input file stating which program it is intended to
            # be run in.
            replacers = ("SES v4.10", "SES v4.1", "SES 4.10", "SES 4.1",
              "OpenSES v4.3", "OpenSES 4.3", "OpenSES 4.3", "OpenSES 4.3",
              "openSES v4.3", "openSES 4.3", "openSES 4.3", "openSES 4.3",
              "Open-SES v4.3", "Open-SES 4.3", "Open-SES 4.3", "Open-SES 4.3",
              "open-SES v4.3", "open-SES 4.3", "open-SES 4.3", "open-SES 4.3",
              "Aurecon SES v107.0", "Aurecon SES 107.0",
              "Aurecon SES v107", "Aurecon SES 107",
              "SES v107", "SES 107",
              "offline-SES v204.2", "offline-SES 204.2",
              "offline-SES v204.3", "offline-SES 204.3",
              "offline-SES v204.4", "offline-SES 204.4",
              "offline-SES v204.5", "offline-SES 204.5",
              "offline-SES v204.6", "offline-SES 204.6",
              "SVS 6.6.2", "SVS v6.6.2"
              )
            # Check for versions on the first line, replace the first instance
            # then break and don't look for any others.
            for text in replacers:
                if text in firstline:
                    newline = firstline.replace(text, target, 1)
                    gen.WriteOut(newline, ses)
                    break

            for line in self.comments[1:]:
                gen.WriteOut(line, ses)

        # Check if we need to tell FormatImpLine to enclose text in
        # curly braces.
        if target[:7] == "AURECON":
            Aur = True
        else:
            Aur = False

        # Do form 1B.  Check if we need to add an entry with the OpenSES
        # version.  OpenSES has version 4.3 at the moment.
        if target.upper() == "SES 4.3":
            form1B = (self.settings_dict["hour"], self.settings_dict["month"],
                      self.settings_dict["year"], target.split[-1])
            line = gen.FormatInpLine(form1B, (1, 0, 0, 3), "1B", USunits, self.log, Aur)
        else:
            form1B = (self.settings_dict["hour"], self.settings_dict["month"],
                      self.settings_dict["year"])
            line = gen.FormatInpLine(form1B, (1, 0, 0), "1B", USunits, self.log, Aur)
        gen.WriteOut(line, ses)

        # Check if we need to write a new line with the offline-SES version.
        # offline-SES has versions 204.1, 204.2, 204.3 etc.
        if target.upper()[:6] == "SES 20":
            version_str = "  offline-SES   " + target.split()[1]
            gen.WriteOut(version_str, ses)
        # Do form 1C
        form1C = (self.settings_dict["trperfopt"], self.settings_dict["tempopt"],
                  self.settings_dict["humidopt"], self.settings_dict["ECZopt"],
                  self.settings_dict["hssopt"], self.settings_dict["supopt"],
                  self.settings_dict["simerrs"], self.settings_dict["inperrs"]
                 )
        comment_text = "tpopt  humid W/WB/RH ECZs therm supopt simerr inperr"
        line = gen.FormatInpLine(form1C, (0,)*8, "1C", USunits, self.log, Aur, comment_text)
        gen.WriteOut(line, ses)

        # Do form 1D.
        form1D = [self.settings_dict["linesegs"], self.settings_dict["sections"],
                  self.settings_dict["ventsegs"], self.settings_dict["nodes"],
                  self.settings_dict["branches"], 0,
                  self.settings_dict["fires"], self.settings_dict["fans"]
                 ]
        if target.upper()[:3] == "SVS":
            comment_text = "lsegs  sects  vsegs nodes use1  fires  fans"
            # Remove the counter of portals from the list of entries, as
            # SVS doesn't have it in the input file.
            form1D.pop(5)
        else:
            comment_text = "lsegs  sects  vsegs nodes use1  use0   fires  fans"
        line = gen.FormatInpLine(form1D, (0,)*8, "1D", USunits, self.log, Aur, comment_text)
        gen.WriteOut(line, ses)

        # Do form 1E
        form1E = (self.settings_dict["routes"], self.settings_dict["trtypes"],
                  self.settings_dict["eczones"], self.settings_dict["fanstall"],
                  self.settings_dict["trstart"], self.settings_dict["jftypes"],
                  self.settings_dict["writeopt"], self.settings_dict["readopt"]
                 )
        comment_text = "routes trtyp  zones fcark trns  JFs    write  read"
        line = gen.FormatInpLine(form1E, (0,)*8, "1E", USunits, self.log, Aur, comment_text)
        gen.WriteOut(line, ses)

        # Do form 1F.  SES has P_atm in Pascals or inches Hg, SVS has it
        # in kPa.
        comment_text = "DB1    WB1  P_atm  AMDB  AMWB  PMDB   PMWB   annamp"
        P_atm = self.settings_dict["ext_P"]
        form1F = [self.settings_dict["ext_DB"], self.settings_dict["ext_WB"],
                            P_atm,              self.settings_dict["morn_DB"],
                  self.settings_dict["morn_WB"], self.settings_dict["eve_DB"],
                  self.settings_dict["eve_WB"], self.settings_dict["ann_var"]
                 ]
        if USunits:
            # Convert the units to US and adjust the count of decimal places.
            decpls = (3, ) * 8
            keys =   ("temp", "temp", "press2", "temp", "temp", "temp", "temp", "tdiff")

            form1F = [USc.ConvertToUS(keys[i], form1F[i], False, self.log)[0]
                            for i in range(len(keys))]
        elif target.upper()[:3] == "SVS":
            decpls = (3, 3, 4, 3, 3, 3, 3, 3)
            form1F[2] = form1F[2] / 1000.
        else:
            decpls = (3, 3, 1, 3, 3, 3, 3, 3)
        line = gen.FormatInpLine(form1F, decpls, "1F", USunits, self.log, Aur, comment_text)
        gen.WriteOut(line, ses)

        # Do form 1G
        comment_text = "mass   cpBst  cpBmv cpAst cpAmv speed  firopt emiss"
        form1G = (self.settings_dict["pax_mass"], self.settings_dict["cap_B+T_sta"],
                  self.settings_dict["cap_B+T_mov"], self.settings_dict["cap_pax_sta"],
                  self.settings_dict["cap_pax_mov"], self.settings_dict["cap_speed"],
                  self.settings_dict["fire_sim"], self.settings_dict["emiss"]
                 )
        decpls = (3, 3, 3, 3, 3, 3, 0, 2)
        if USunits:
            # Convert the units to US and adjust the count of decimal places.
            keys =   ("mass1", "null", "null", "null", "null", "speed2", "null", "null")

            form1G = [USc.ConvertToUS(keys[i], form1G[i], False, self.log)[0]
                            for i in range(len(keys))]
            decpls = (3, 3, 3, 3, 3, 3, 0, 2)
        line = gen.FormatInpLine(form1G, decpls, "1G", USunits, self.log, Aur, comment_text)
        gen.WriteOut(line, ses)

        if target.upper()[:11] == "AURECON SES":
            # Write form 101H telling the program that there are no
            # Aurecon extensions active.
            comment_text = "Form 101H"

            # First number in form 101H is a counter of entries on the
            # rest of the line, followed by up to five other numbers:
            #  2nd number - counter of platform screen door templates (form 101J)
            #  3rd number - counter of Saccardo nozzle templates (form 101K)
            #  4th number - if not zero, read form 101L (thermo stuff)
            #  5th number - counter of portal doors (form 101M)
            #  6th number - if not zero, read form 101N (aero stuff)
            form101H = (5, 0, 0, 0, 0, 0)
            decpls = (0, 0, 0, 0, 0, 0)
            line = gen.FormatInpLine(form101H, decpls, "101H", USunits,
                                     self.log, Aur, comment_text)
            gen.WriteOut(line, ses)
        elif target[:3] == "SVS":
            # Write form 1H, turning off all the SVS extensions and
            # setting the thermal parameters to the defaults.
            comment_text = "Form 1H"
            form1H = (0, 30., 0.5, 0, 0)
            decpls = (0, 1, 1, 0, 0, 0)
            line = gen.FormatInpLine(form1H, decpls, "1H", USunits,
                                     self.log, Aur, comment_text)
            gen.WriteOut(line, ses)


        # Figure out the index at which we switch from form 2A to 2B.
        linesecs = self.settings_dict["sections"] - self.settings_dict["ventsegs"]
        for sec_index, sec_num in enumerate(self.form2_dict.keys()):
            this2A = self.form2_dict[sec_num]

            if sec_index < linesecs:
                form = "2A"
                form2 = (sec_num, this2A["LH_node"], this2A["RH_node"],
                         this2A["seg_count"], this2A["volflow"]
                        )
                decpls = (0, 0, 0, 0, 5)
            else:
                form = "2B"
                form2 = (sec_num, this2A["LH_node"], this2A["RH_node"],
                         this2A["volflow"]
                        )
                decpls = (0, 0, 0, 5)
            if USunits:
                # Convert the units to US and adjust the count of decimal places.
                if form == "2A":
                    keys = ["null", "null", "null", "null", "volflow"]
                    decpls = (0, 0, 0, 0, 3)
                else:
                    keys = ["null", "null", "null", "volflow"]
                    decpls = (0, 0, 0, 3)
                form2 = [USc.ConvertToUS(keys[i], form2[i], False, self.log)[0]
                                for i in range(len(keys))]
            if sec_index == 0:
                line = gen.FormatInpLine(form2, decpls, form, USunits, self.log, Aur, "Form 2A")
            elif sec_index == linesecs:
                line = gen.FormatInpLine(form2, decpls, form, USunits, self.log, Aur, "Form 2B")
            else:
                line = gen.FormatInpLine(form2, decpls, form, USunits, self.log, Aur)
            gen.WriteOut(line, ses)

        # Do form 3
        for seg_index, seg_num in enumerate(self.form3_dict.keys()):
            this3A = self.form3_dict[seg_num]
            if Aur:
                descrip = this3A["descrip"].ljust(80) + " Form 3A"
                form3A1 = (seg_num, this3A["seg_type"], descrip)
                comment = ""
            else:
                form3A1 = (seg_num, this3A["seg_type"], this3A["descrip"])
                comment = "Form 3A"

            if seg_index == 0:
                line = gen.FormatInpLine(form3A1, (0, 0), "3A1", USunits, self.log, Aur, comment)
            else:
                line = gen.FormatInpLine(form3A1, (0, 0), "3A1", USunits, self.log, Aur)
            gen.WriteOut(line, ses)

            form3A2 = [this3A["length"], this3A["area"], this3A["stack"],
                       this3A["fireseg"]
                      ]
            decpls = [2, 2, 5, 0]
            if USunits:
                # Convert the units to US and adjust the count of decimal places.
                keys = ["dist1", "area", "dist1", "null"]
                form3A2 = [USc.ConvertToUS(keys[i], form3A2[i], False, self.log)[0]
                                for i in range(len(keys))]
            if target[:3] == "SVS":
                # Add a zero for the fixed pressure rise in the segment.
                form3A2.append(0.)
                decpls.append(1)
            line = gen.FormatInpLine(form3A2, decpls, "3A2", USunits, self.log, Aur)
            gen.WriteOut(line, ses)

            # When building form 3B we need to figure out how many perimeters and
            # roughness heights were present.
            count_keys = len([key for key in this3A if key[:5] == "rough"])
            # Now build a suitable list to recreate that count of perimeters.
            form3B1 = [this3A["perim" + str(num+1) ] for num in range(count_keys)]
            decpl = (3,) * count_keys

            if USunits:
                # Convert the units to US.
                keys = ("dist1",) * count_keys
                form3B1 = [USc.ConvertToUS(keys[i], form3B1[i], False, self.log)[0]
                                for i in range(len(keys))]

            line = gen.FormatInpLine(form3B1, decpl, "3B1", USunits, self.log, Aur)
            gen.WriteOut(line, ses)

            # Now build a suitable list to recreate that count of roughnesses.
            form3B2 = [this3A["rough" + str(num+1) ] for num in range(count_keys)]
            decpl = (5,) * count_keys
            if USunits:
                # Convert the units to US and adjust the count of decimal places.
                keys = ("dist1",) * count_keys
                form3B2 = [USc.ConvertToUS(keys[i], form3B2[i], False, self.log)[0]
                                for i in range(len(keys))]
            elif target[:3] == "SVS":
                # Turn the roughness heights into mm for SVS.
                for index, entry in enumerate(form3B2):
                    form3B2[index] = 1000 * form3B2[index]
                decpl = (1,) * count_keys
            line = gen.FormatInpLine(form3B2, decpl, "3B2", USunits, self.log, Aur)
            gen.WriteOut(line, ses)

            # Do form 3C
            gains = this3A["heat_gains"]
            form3C = (this3A["RHS_zeta_+"], this3A["RHS_zeta_-"],
                      this3A["LHS_zeta_+"], this3A["LHS_zeta_-"],
                      this3A["wetted"], this3A["subsegs"], gains
                     )
            # No need to convert to US units as all the entries are dimensionless.
            line = gen.FormatInpLine(form3C, (3, 3, 3, 3, 2, 0, 0), "3C", USunits, self.log, Aur)
            gen.WriteOut(line, ses)

            if gains != 0:
                # Write all instances of form 3D.  Note that the original
                # input file may have had a text string identifying what
                # the heat gain is, like "third rail losses". Unfortunately
                # this text is not printed to the SES output file, so it
                # cannot be written to the new file.
                for index in range(1, gains + 1):
                    form3D = []
                    for suffix in ("start_sub", "end_sub", "gain_type",
                                   "sensible", "latent"):
                        key = "3D_" + str(index) + "_" + suffix
                        form3D.append(this3A[key])
                    decpls = (0, 0, 0, 3, 3)
                    if USunits:
                        decpls = (0, 0, 0, 1, 1)
                        # Convert the units to US and adjust the count of decimal places.
                        keys = ["null", "null", "null", prefix + "watt1", prefix + "watt1"]
                        form3D = [USc.ConvertToUS(keys[i], form3D[i], False, self.log)[0]
                                        for i in range(len(keys))]
                    form3D.append(this3A["3D_" + str(index) + "_descrip"])
                    line = gen.FormatInpLine(form3D, decpls, "3D", USunits, self.log, Aur)
                    gen.WriteOut(line, ses)

            # Figure out how many lines of input we have in form 3E.  We have
            # five entries for each line in 3E.
            count_3E = len([key for key in this3A if "3E" in key]) // 5
            for index in range(1, count_3E + 1):
                form3E = []
                for suffix in ("start_sub", "end_sub", "wall_temp",
                            "dry_bulb", "wet_bulb"):
                    # Build a suitable set of keys, which look like
                    # "3E_4_start_sub".
                    key = "3E_" + str(index) + "_" + suffix
                    form3E.append(this3A[key])
                if USunits:
                    # Convert the units to US and adjust the count of decimal places.
                    keys = ["null", "null", "temp", "temp", "temp"]
                    form3E = [USc.ConvertToUS(keys[i], form3E[i], False, self.log)[0]
                                    for i in range(len(keys))]
                line = gen.FormatInpLine(form3E, (0, 0, 3, 3, 3), "3E", USunits, self.log, Aur)
                gen.WriteOut(line, ses)


            # If ECZs are turned on, include form 3F.
            if self.settings_dict["ECZopt"] != 0:
                form3F = (this3A["wall_thck"], this3A["tun_sep"],
                          this3A["wall_thcon"], this3A["wall_diff"],
                          this3A["grnd_thcon"], this3A["grnd_diff"],
                          this3A["deep_sink"]
                         )
                decpl = (3, 2, 4, 12, 4, 12, 3)
                if USunits:
                    # Convert the units to US and adjust the count of decimal places.
                    keys = ["dist1", "dist1", prefix + "thcon", "diff", prefix + "thcon", "diff", "temp"]
                    decpl = (3, 2, 4, 4, 4, 4, 3)
                    form3F = [USc.ConvertToUS(keys[i], form3F[i], False, self.log)[0]
                                    for i in range(len(keys))]
                line = gen.FormatInpLine(form3F, decpl, "3F", USunits, self.log, Aur)
                gen.WriteOut(line, ses)


        # Do form 4
        fires = self.settings_dict["fires"]
        for fire_index in range(1, fires + 1):
            fire_dict = self.form4_dict[fire_index]
            form4_1 = (fire_dict["descrip"], fire_dict["seg_num"],
                       fire_dict["subseg_num"]
                      )
            line = gen.FormatInpLine(form4_1, (0, 0, 0), "4_1", USunits, self.log, Aur)
            gen.WriteOut(line, ses)

            # SI SES input files have heat gains in MW, to be consistent
            # with Aurecon SES.
            sens = fire_dict["sens_pwr"]
            lat = fire_dict["lat_pwr"]
            decpl = (6, 6, 1, 1, 3, 3)
            if target[:3] == "SVS":
                # SVS needs the fire sizes in watts.
                sens = sens * 1E6
                lat = lat * 1E6
                decpl = (0, 0, 1, 1, 3, 3)
            form4_2 = (sens, lat,
                       fire_dict["fire_start"], fire_dict["fire_stop"],
                       fire_dict["flame_temp"], fire_dict["flame_area"]
                      )

            if USunits:
                # Convert the units to US and adjust the count of decimal places.
                keys = [prefix + "Mwatt", prefix + "Mwatt", "null", "null", "temp", "area"]
                decpl = (0, 0, 1, 1, 3, 3)
                form4_2 = [USc.ConvertToUS(keys[i], form4_2[i], False, self.log)[0]
                                for i in range(len(keys))]
            if fire_index == 0:
                comment = "Form 4A"
            else:
                comment = ""
            line = gen.FormatInpLine(form4_2, decpl, "4_2", USunits, self.log, Aur, comment)
            gen.WriteOut(line, ses)


        # Do form 5 (if there are any)
        for seg_index, seg_num in enumerate(self.form5_dict.keys()):
            this_5 = self.form5_dict[seg_num]
            if Aur:
                descrip = this_5["descrip"].ljust(80) + " Form 5A"
                form5A1 = (seg_num, this_5["seg_type"], descrip)
                comment = ""
            else:
                form5A1 = (seg_num, this_5["seg_type"], this_5["descrip"])
                comment = "Form 5A"

            if seg_index == 0:
                line = gen.FormatInpLine(form5A1, (0, 0), "5A1", USunits, self.log, Aur, comment)
            else:
                line = gen.FormatInpLine(form5A1, (0, 0), "5A1", USunits, self.log, Aur)
            gen.WriteOut(line, ses)

            form5B = (this_5["subs_in"], this_5["subsegs"],
                      this_5["grate_area"], this_5["grate_vel"],
                      this_5["wall_temp"], this_5["dry_bulb"], this_5["wet_bulb"],
                      this_5["stack"]
                     )
            decpl = (0, 0, 3, 2, 3, 3, 3, 3)
            if USunits:
                # Convert the units to US and adjust the count of decimal places.
                keys = ["null", "null", "area", "speed1", "temp", "temp", "temp", "dist1"]
                decpl = (0, 0, 2, 2, 3, 3, 3, 4)
                form5B = [USc.ConvertToUS(keys[i], form5B[i], False, self.log)[0]
                                for i in range(len(keys))]
            line = gen.FormatInpLine(form5B, decpl, "5B", USunits, self.log, Aur)
            gen.WriteOut(line, ses)

            # Do form 5C
            if self.settings_dict["fans"] != 0:
                form5C = (this_5["fan_type"],
                          this_5["fan_start"], this_5["fan_stop"],
                          this_5["fan_dir"]
                         )
                line = gen.FormatInpLine(form5C, (0, 1, 1, 0), "5C", USunits, self.log, Aur)
                gen.WriteOut(line, ses)

            # Figure out how many lines of input we have in form 5D.  We have
            # seven entries for each line in 5D.
            forms_5D = this_5["forms_5D"]
            for index_5D in range(len(forms_5D)):
                form_5D = forms_5D[index_5D]
                decpl = (3, 3, 2, 2, 2, 2, 2)
                if USunits:
                    # Convert the units to US and adjust the count of decimal places.
                    keys = ["dist1", "area", "dist1", "null", "null", "null", "null"]
                    decpl = (3, 3, 3, 2, 2, 2, 2)
                    form_5D = [USc.ConvertToUS(keys[i], form_5D[i], False, self.log)[0]
                                    for i in range(len(keys))]
                line = gen.FormatInpLine(form_5D, decpl, "5D", USunits, self.log, Aur)
                gen.WriteOut(line, ses)

        # Do form 6
        for node_index, node_num in enumerate(self.form6_dict.keys()):
            this_6 = self.form6_dict[node_num]

            # Get the aero and thermo type
            aero_type = this_6["aero_type"]
            thermo_type = this_6["thermo_type"]
            form6A = (node_num, aero_type, thermo_type)
            if node_index == 0:
                line = gen.FormatInpLine(form6A, (0,)*3, "6A", USunits, self.log, Aur, "Form 6A")
            else:
                line = gen.FormatInpLine(form6A, (0,)*3, "6A", USunits, self.log, Aur)
            gen.WriteOut(line, ses)

            if thermo_type == 3:
                # Process form 6B.
                # Get the external conditions first, so we can check if we
                # should write zero values.
                externals = (self.settings_dict["ext_DB"], self.settings_dict["ext_WB"],
                             self.settings_dict["morn_DB"], self.settings_dict["morn_WB"],
                             self.settings_dict["eve_DB"], self.settings_dict["eve_WB"])

                if self.settings_dict["ECZopt"] != 0:
                    form_6B = (this_6["ext_DB"], this_6["ext_WB"],
                              this_6["morn_DB"], this_6["morn_WB"],
                              this_6["eve_DB"], this_6["eve_WB"])
                    decpl = (3,)*6
                    # Check if these six entries are the same as the outside air
                    # temperatures in form 1F.  If they are, use six zeroes
                    # instead.  We can't tell if the user had six zeroes or the
                    # temperatures in their input file but it's a pretty safe bet.
                    if form_6B == externals:
                        form_6B = (0.0,)*6
                else:
                    form_6B = (this_6["ext_DB"], this_6["ext_WB"])
                    decpl = (3,)*2
                    if form_6B == externals[:2]:
                        form_6B = (0.0,)*2
                if USunits:
                    # Convert the units to US.  The first two temperatures are
                    # kept as zero if they are 0.01 deg F or below.  The last four
                    # are kept as zero if they are 0.1 deg F or below.
                    keys = ("tempzero1",) * 2 + ("tempzero2", ) * 4
                    form_6B = [USc.ConvertToUS(keys[i], form_6B[i], False, self.log)[0]
                                    for i in range(len(form_6B))]
                line = gen.FormatInpLine(form_6B, decpl, "6B", USunits, self.log, Aur)
                gen.WriteOut(line, ses)

            if aero_type == 1:
                form6C = (this_6["sec_1"], this_6["sec_2"], this_6["sec_3"],
                          this_6["sec_4"], this_6["aspect"]
                         )
                decpl = (0, 0, 0, 0, 4)
                line = gen.FormatInpLine(form6C, decpl, "6C", USunits, self.log, Aur, "Form 6C")
                gen.WriteOut(line, ses)
            elif aero_type == 2:
                form6D = [this_6["sec_1"], this_6["sec_2"], this_6["sec_3"],
                         ]
                if target[:3] == "SVS":
                    decpl = (0, 0, 0, 3)
                    # SVS has an input for a k-factor for airflow from 1 to 3
                    # (or 3 to 1).  The default is zeta = 1.0 so that's what
                    # we'll set.
                    form6D.append(1.0)
                    line = gen.FormatInpLine(form6D, decpl, "6D", USunits,
                                             self.log, Aur, "Form 6D")
                else:
                    decpl = (0, 0, 0)
                    line = gen.FormatInpLine(form6D, decpl, "6D", USunits,
                                             self.log, Aur, "Form 6D")
                gen.WriteOut(line, ses)
            elif aero_type == 3:
                form6E = (this_6["sec_1"], this_6["sec_2"], this_6["sec_3"],
                          this_6["aspect"]
                         )
                decpl = (0, 0, 0, 4)
                line = gen.FormatInpLine(form6E, decpl, "6E", USunits, self.log, Aur, "Form 6E")
                gen.WriteOut(line, ses)
            elif aero_type == 4:
                form6F = (this_6["sec_1"], this_6["sec_2"], this_6["sec_3"],
                          this_6["aspect"], this_6["angle"]
                         )
                decpl = (0, 0, 0, 4, 1)
                line = gen.FormatInpLine(form6F, decpl, "6F", USunits, self.log, Aur, "Form 6F")
                gen.WriteOut(line, ses)
            elif aero_type == 5:
                form6G = (this_6["sec_1"], this_6["sec_2"], this_6["sec_3"],
                          this_6["aspect"], this_6["angle"]
                         )
                decpl = (0, 0, 0, 4, 1)
                line = gen.FormatInpLine(form6G, decpl, "6G", USunits, self.log, Aur, "Form 6G")
                gen.WriteOut(line, ses)

            if thermo_type == 2:
                # Process form 6H.
                form6H = (this_6["mix_sec_1"], this_6["mix_sec_2"], this_6["mix_sec_3"],
                          this_6["mix_sec_4"], this_6["mix_sec_5"], this_6["mix_sec_6"],
                          this_6["mix_sec_7"])
                line = gen.FormatInpLine(form6H, (0,)*7, "6H", USunits, self.log, Aur, "Form 6H")
                gen.WriteOut(line, ses)


        # Do form 7 fan characteristics if there are any
        for fan_num in self.form7_fans.keys():
            this_7 = self.form7_fans[fan_num]

            form7A = [this_7["density"], this_7["runup_time"],
                      this_7["minimum_flow"], this_7["maximum_flow"]
                     ]
            decpl = [3, 2, 2, 2]
            if USunits:
                # Convert the units to US and adjust the count of decimal places.
                keys = ["dens1", "null", "volflow", "volflow"]
                decpl = [4, 1, 0, 0]
                form7A = [USc.ConvertToUS(keys[i], form7A[i], False, self.log)[0]
                                for i in range(len(keys))]
            form7A = [this_7["descrip"]] + form7A
            decpl = [0] + decpl
            line = gen.FormatInpLine(form7A, decpl, "7A", USunits, self.log, Aur)
            gen.WriteOut(line, ses)

            form7B = []
            for point_index in range(4):
                form7B.extend([this_7["fwd_user_press"][point_index],
                               this_7["fwd_user_flow"][point_index] ])
            decpl = (1, 3) * 4
            if USunits:
                # Convert the units to US and adjust the count of decimal places.
                keys = ["press1", "volflow"] * 4
                decpl = (4, 0) * 4
                form7B = [USc.ConvertToUS(keys[i], form7B[i], False, self.log)[0]
                                for i in range(len(keys))]
            if fan_num == 1:
                line = gen.FormatInpLine(form7B, decpl, "7B", USunits, self.log, Aur, "Form 7A")
            else:
                line = gen.FormatInpLine(form7B, decpl, "7B", USunits, self.log, Aur)
            gen.WriteOut(line, ses)

            if this_7["one_char"]:
                # Write a copy of the current characteristic to the input file
                gen.WriteOut(line, ses)
            else:
                # Write the characteristic for reverse flow
                form7B = []
                for point_index in range(4):
                    form7B.extend([this_7["rev_user_press"][point_index],
                                   this_7["rev_user_flow"][point_index] ])
                if USunits:
                    # Convert the units to US and adjust the count of decimal places.
                    form7B = [USc.ConvertToUS(keys[i], form7B[i], False, self.log)[0]
                                    for i in range(len(keys))]
                line = gen.FormatInpLine(form7B, decpl, "7B", USunits, self.log, Aur)
                gen.WriteOut(line, ses)

        # Do form 7 jet fans if there are any
        for JFfan_num in self.form7_JFs.keys():
            this_7 = self.form7_JFs[JFfan_num]

            # SES uses the fan volume flow rather than static thrust.
            form7C = [this_7["volflow"], this_7["insteff"], this_7["jet_speed"],
                      this_7["fan_start"], this_7["fan_stop"]
                     ]
            decpl = (3, 5, 3, 1, 1)

            if USunits:
                # Convert the units to US and adjust the count of decimal places.
                keys = ("volflow", "null", "speed1", "null", "null")
                decpl = (1, 5, 3, 1, 1)
                form7C = [USc.ConvertToUS(keys[i], form7C[i], False, self.log)[0]
                                for i in range(len(keys))]
            elif target[:3] == "SVS":
                # Change the volume flow into a static thrust at 1.2 kg/m^3,
                # add air density 1.2 and turn off temperature derating.
                decpl = (1, 5, 3, 1, 1, 3, 0)
                form7C[0] = this_7["static_thrust"]
                form7C.extend([1.2, 0])
            if JFfan_num == 1:
                line = gen.FormatInpLine(form7C, decpl, "7C", USunits,
                                         self.log, Aur, "Form 7C")
            else:
                line = gen.FormatInpLine(form7C, decpl, "7C", USunits,
                                         self.log, Aur)
            gen.WriteOut(line, ses)

        # Do form 8 if there are any routes
        for route_num in self.form8_dict.keys():
            this_8 = self.form8_dict[route_num]

            trperfopt = self.settings_dict['trperfopt']

            # Print the description on a line of its own
            descrip = this_8["descrip"]
            if Aur:
                line = "{" + descrip.ljust(80) + " Form 8A}"
            else:
                line = descrip.ljust(80) + " Form 8A"
            gen.WriteOut(line, ses)

            train_grps = this_8["train_grps"]
            first_train_type = this_8["group_1"]["train_type"]
            if trperfopt == 1:
                track_sects = this_8["track_sects"]
                form8A = (this_8["origin"], train_grps, track_sects,
                          this_8["start_time"], first_train_type,
                          this_8["min_speed"], this_8["coast_opt"]
                         )
                decpl = (3, 0, 0, 1, 0, 3, 0)
            elif trperfopt == 2:
                # No minimum speed or coasting here
                track_sects = this_8["track_sects"]
                form8A = (this_8["origin"], train_grps, track_sects,
                          this_8["start_time"], first_train_type,
                         )
                decpl = (3, 0, 0, 1, 0)
            else:
                # No minimum speed, coasting or track sections here
                form8A = (this_8["origin"], train_grps, 0,
                          this_8["start_time"], first_train_type,
                         )
                decpl = (3, 0, 0, 1, 0)
            if USunits:
                # Convert the units to US and adjust the count of decimal places.
                keys = ("dist1", "null", "null", "null", "null", "speed2", "null")
                form8A = [USc.ConvertToUS(keys[i], form8A[i], False, self.log)[0]
                                for i in range(len(decpl))]
            line = gen.FormatInpLine(form8A, decpl, "8A", USunits, self.log, Aur)
            gen.WriteOut(line, ses)

            # Here we use train_grps, not train_grps + 1.  This is deliberate.
            for group in range(1, train_grps):
                group_dict = this_8["group_" + str(group+1)]
                form8B = (group_dict["train_count"], group_dict["train_type"],
                          group_dict["headway"]
                         )
                decpl = (0, 0, 1)
                line = gen.FormatInpLine(form8B, decpl, "8B", USunits, self.log, Aur)
                gen.WriteOut(line, ses)

            if trperfopt in (1, 2):
                # Read the track sections.  We only read this if we are calculating
                # implicit heat gains (train performance options 1 or 2).
                if USunits:
                    keys = ("dist1", "dist1", "null", "dist1", "speed2", "null", "null")
                    decpl = [3, 3, 4, 1, 2, 0, 0]
                else:
                    decpl = [3, 3, 4, 2, 2, 0, 0]
                for sect_index in range(track_sects):
                    # When we rebuild form 8C, we cannot tell from the output file
                    # whether form 8C in the original input file had inputs of gradient
                    # or stack height.  I generally use gradients, so we will rebuild
                    # the form with the gradients, not the heights.  Competent users
                    # who prefer stack height can change it if they wish.

                    form8C = [this_8["fwd_end"][sect_index],
                              this_8["radius"][sect_index],
                              this_8["gradient"][sect_index],
                              0., # Set a zero value for height at end of section
                              this_8["max_speed"][sect_index],
                              this_8["sector"][sect_index],
                              this_8["coasting"][sect_index]
                             ]
                    if USunits:
                        # Convert the units to US and adjust the count of decimal places.
                        form8C = [USc.ConvertToUS(keys[i], form8C[i], False, self.log)[0]
                                        for i in range(len(keys))]
                    elif target[:3] == "SVS":
                        # Each track section in form 8C in SVS has an extra
                        # number representing regen braking fraction in it.
                        # We set zero values.
                        form8C.append(0.0)
                        decpl.append(1)
                    if sect_index == 0:
                        line = gen.FormatInpLine(form8C, decpl, "8C", USunits, self.log, Aur, "Form 8C")
                    else:
                        line = gen.FormatInpLine(form8C, decpl, "8C", USunits, self.log, Aur)
                    gen.WriteOut(line, ses)

            # Check if we need to read form 8D (option 1 only)
            if trperfopt == 1:
                stops = this_8["stops"]
                form8D1 = (stops,
                          this_8["pax"]
                          )
                line = gen.FormatInpLine(form8D1, (0, 0), "8D1", USunits, self.log, Aur)
                gen.WriteOut(line, ses)

                for stop in range(stops):
                    form8D2 = (this_8["stop_ch"][stop],
                               this_8["dwell_time"][stop],
                               this_8["delta_pax"][stop],
                              )
                    decpl = (3, 1, 0)
                    if USunits:
                        # Convert the units to US and adjust the count of decimal places.
                        keys = ("dist1", "null", "null")
                        form8D2 = [USc.ConvertToUS(keys[i], form8D2[i], False, self.log)[0]
                                        for i in range(len(keys))]
                    line = gen.FormatInpLine(form8D2, (3, 1, 0), "8D2", USunits, self.log, Aur)
                    gen.WriteOut(line, ses)


            # Check if we need to read form 8E (options 2 and 3).  It takes
            # two different forms.
            if trperfopt in (2, 3):
                count = this_8["8E_count"]
                form8E1 = (count,)
                line = gen.FormatInpLine(form8E1, (0,), "8E_1", USunits, self.log, Aur, "Form 8E")
                gen.WriteOut(line, ses)

                if USunits:
                    keys = ("null", "speed2", "null", "null")
                decpl = (2, 3, 3, 3)
                for index_8E in range(this_8["8E_count"]):
                    if trperfopt == 2:
                        form8E2 = (this_8["time"][index_8E],
                                   this_8["speed"][index_8E]
                                  )
                    else:
                        form8E2 = [this_8["time"][index_8E],
                                   this_8["speed"][index_8E],
                                   this_8["trac_heat"][index_8E],
                                   this_8["brake_heat"][index_8E]
                                  ]
                    if USunits:
                        # Convert the units to US and adjust the count of decimal places.
                        form8E2 = [USc.ConvertToUS(keys[i], form8E2[i], False, self.log)[0]
                                        for i in range(len(form8E2))]
                    line = gen.FormatInpLine(form8E2, decpl, "8E_2", USunits, self.log, Aur)
                    gen.WriteOut(line, ses)

            # Rewrite form 8F
            sec_count = this_8["sec_count"]
            form8F1 = (sec_count, this_8["entry_ch"])
            decpl = (0, 3)
            if USunits:
                # Convert the units to US and adjust the count of decimal places.
                keys = ("null", "dist1")
                decpl = (0, 3)
                form8F1 = [USc.ConvertToUS(keys[i], form8F1[i], False, self.log)[0]
                                for i in range(len(form8F1))]
            line = gen.FormatInpLine(form8F1, decpl, "8F_1", USunits, self.log, Aur, "Form 8F")
            gen.WriteOut(line, ses)
            for sec_num in this_8["sec_list"]:
                gen.WriteOut(str(int(sec_num)), ses)

        # Do form 9
        trperfopt = self.settings_dict['trperfopt']

        for trtype_num in self.form9_dict.keys():
            this_9 = self.form9_dict[trtype_num]

            # Forms 9A to 9E are always present
            form9A =  [this_9["tot_cars"],
                       this_9["pwd_cars"],
                       this_9["length"],
                       this_9["area"]
                      ]
            decpl = (0, 0, 0, 2, 3)
            if USunits:
                keys = ("null", "null", "dist1", "area")
                decpl = (0, 0, 2, 2)
                # Convert the units to US and adjust the count of decimal places.
                form9A = [USc.ConvertToUS(keys[i], form9A[i], False, self.log)[0]
                                for i in range(len(keys))]
                # Redefine the decimal places to include a zero for the
                # string at the start.
                decpl = (0, 0, 0, 2, 2)
            if Aur:
                # We can't write two blocks of text in curly braces to
                # the same line of an Aurecon SES input file.  Delete the
                # comment and add 9A to the train description.
                comment = ""
                form9A = [this_9["descrip"] + ", 9A"] + form9A
            else:
                comment = "Form 9A totcars, pwdcars, length, area"
                form9A = [this_9["descrip"]] + form9A
            line = gen.FormatInpLine(form9A, decpl, "9A", USunits,
                                     self.log, Aur, comment)
            gen.WriteOut(line, ses)

            form9B =  [this_9["perimeter"],
                       this_9["skin_Darcy"],
                       this_9["bogie_loss"],
                       this_9["nose_loss"]
                      ]
            decpl = [2, 5, 3, 3]
            comment = "perim, Darcy_fricfac, bogies, noseloss"
            if USunits:
                keys = ("dist1", "null", "null", "null")
                # Convert the units to US and adjust the count of decimal places.
                form9B = [USc.ConvertToUS(keys[i], form9B[i], False, self.log)[0]
                                for i in range(len(keys))]
            elif target[:3] == "SVS":
                # Form 9B in SVS has an entry for tail loss.  If it is set
                # to zero the program will calculate it using the expression
                # from Hoerner's book.
                form9B.append(0.0)
                decpl.append(1)
                comment = comment + ", tailloss"
            line = gen.FormatInpLine(form9B, decpl, "9B", USunits, self.log, Aur, comment)
            gen.WriteOut(line, ses)

            form9C =  (this_9["aux_sens"],
                       this_9["aux_lat"],
                       this_9["pax_sens"],
                       this_9["pax_lat"],
                       this_9["car_kW"],
                       this_9["pax_kW"],
                      )
            decpl = (3,)*6
            if USunits:
                keys = (prefix + "watt1", prefix + "watt1", prefix + "watt1",
                        prefix + "watt1", "null", "null")
                decpl = (2, 2, 2, 2, 3, 3)
                # Convert the units to US and adjust the count of decimal places.
                form9C = [USc.ConvertToUS(keys[i], form9C[i], False, self.log)[0]
                                for i in range(len(keys))]
            line = gen.FormatInpLine(form9C, decpl, "9C", USunits, self.log,
                            Aur, "sens & lat/car, sens & lat/pax, kW/car & pax")
            gen.WriteOut(line, ses)

            form9D1 = [this_9["accel_mass"],
                       this_9["decel_mass"],
                       this_9["accel_diam"],
                       this_9["decel_diam"],
                       this_9["accel_area1"],
                       this_9["decel_area1"],
                       this_9["accel_area2"],
                       this_9["decel_area2"],
                      ]
            decpl = (2, 2, 2, 2, 3, 3, 3, 3)
            comment = "accel & decel: mass, diam, areas (conv & rad)"
            if USunits:
                keys = ("mass1", "mass1", "dist4", "dist4",
                        "area", "area", "area", "area")
                decpl = (2, 2, 2, 2, 2, 2, 2, 2)
                # Convert the units to US and adjust the count of decimal places.
                form9D1 = [USc.ConvertToUS(keys[i], form9D1[i], False, self.log)[0]
                                for i in range(len(keys))]
            elif target[:3] == "SVS":
                # SVS sets the diameters in mm, not metres.
                form9D1[2] = form9D1[2] * 1000.
                form9D1[3] = form9D1[3] * 1000.
            line = gen.FormatInpLine(form9D1, decpl, "9D_1", USunits, self.log, Aur, comment)
            gen.WriteOut(line, ses)

            form9D2 = [this_9["accel_emiss"],
                       this_9["decel_emiss"],
                       this_9["accel_spcht"],
                       this_9["decel_spcht"],
                       this_9["accel_temp"],
                       this_9["decel_temp"],
                      ]
            decpl = [3, 3, 4, 4, 3, 3]
            comment = "accel & decel: emissivity, specheat, temp"
            if USunits:
                keys = ("null", "null", prefix + "specheat", prefix + "specheat", "temp", "temp")
                decpl = (2, 2, 3, 3, 3, 3)
                # Convert the units to US and adjust the count of decimal places.
                form9D2 = [USc.ConvertToUS(keys[i], form9D2[i], False, self.log)[0]
                                for i in range(len(keys))]
            elif target[:3] == "SVS":
                # Form 9D in SVS has air velocities of forced blowers for the
                # resistor grids.  Set them to zero so that the annulus air
                # velocity is used instead.
                form9D2.extend([0.0, 0.0])
                decpl.extend([1, 1])
                comment = comment + ", blower speeds"
            line = gen.FormatInpLine(form9D2, decpl, "9D_2", USunits, self.log, Aur, comment)
            gen.WriteOut(line, ses)

            A_term1 = this_9["A_termN/kg"]
            B_term = this_9["B_term"]
            rot_term = this_9["rot_mass%"]
            decpl = (3, 0, 5, 2, 7, 3)
            comment = "mass (t), motors/car, N/kg, N, N-s/kg-m, [0 or %tare]"

            form9E =  [this_9["car_weight"],
                       this_9["motor_count"],
                       A_term1,
                       this_9["A_termN"],
                       B_term,
                       rot_term,
                      ]
            if USunits:
                keys = ("mass3", "null", "Aterm1a", "Force1", "Bterm1a", "rotmass")
                decpl = (3, 0, 3, 2, 5, 3)
                # Convert the units to US and adjust the count of decimal places.
                form9E = [USc.ConvertToUS(keys[i], form9E[i], False, self.log)[0]
                                for i in range(len(keys))]
                comment = "mass (tons), motors/car, lb/ton, lb, lb/ton-mph, "  \
                          "[0 or (lb/ton)/(mph/sec)]"
            elif target[:3] == "SVS":
                # SVS sets the gyroscopic mass in kg rather than as a percentage of
                # tare mass.  SVS also needs two Davis coefficients in terms of
                # N/tonne and N/tonne-kph.
                # Hobyah uses the same units as Aurecon SES does; % tare mass,
                # N/kg and N-s/kg-m.
                form9E[2] = form9E[2] * 1000.  # N per kg to N per tonne
                form9E[4] = form9E[4] * 3600.  # N per kg-m/s to N per tonne-kph
                tare = form9E[0] * 1000 # tare mass in kg
                form9E[-1] = tare * form9E[-1] / 100.
                decpl = (3, 0, 3, 2, 4, 2)
                comment = "mass (t), motors/car, N/tonne, N, N/tonne-kph, [0 or kg]"
            line = gen.FormatInpLine(form9E, decpl, "9E", USunits, self.log, Aur, comment)
            gen.WriteOut(line, ses)

            if trperfopt != 3:
                manfdiam = this_9["diam_manf"]
                actdiam = this_9["diam_act"]
                m_descrip = this_9["motor_descrip"].strip()
                form9F1 = [m_descrip, manfdiam, actdiam]
                decpl = (0, 3, 3)
                if USunits:
                    # Convert the diameters to inches and adjust the count
                    # of decimal places.
                    form9F1[1] = form9F1[1] / 0.0254
                    form9F1[2] = form9F1[2] / 0.0254
                    decpl = (0, 2,  2)
                elif target[:3] == "SVS":
                    # Form 9D in SVS has wheel diameters in mm rather than
                    # inches (SES) or metres (offline-SES and Aurecon SES).
                    form9F1[1] = form9F1[1] * 1000.
                    form9F1[2] = form9F1[2] * 1000.
                    decpl = (0, 0, 0)
                line = gen.FormatInpLine(form9F1, decpl, "9F1", USunits, self.log,
                                    Aur, "motor descrip, 2 wheel diameters")
                gen.WriteOut(line, ses)

                form9F2 = (this_9["ratio_manf"],
                           this_9["ratio_act"],
                           this_9["volts_manf"],
                           this_9["volts_act"],
                           this_9["volts_motor"],
                          )
                decpl = (3, 3, 1, 1, 1)
                line = gen.FormatInpLine(form9F2, decpl, "9F2", USunits, self.log,
                                    Aur, "2 gear ratios, 3 voltages (3rd is discarded)")
                gen.WriteOut(line, ses)

                # Three lines in form 9G, holding train speeds, motor TEs and
                # motor amps.  Fourth line is the train control type.
                form9G1 =  this_9["motor_speeds"]
                decpl = (3,)*4
                if USunits:
                    keys = ("speed2",) * 4
                    decpl = (3, 3, 3, 3)
                    # Convert the units to US and adjust the count of decimal places.
                    form9G1 = [USc.ConvertToUS(keys[i], form9G1[i], False, self.log)[0]
                                    for i in range(len(keys))]
                line = gen.FormatInpLine(form9G1, decpl, "9G1", USunits, self.log,
                                         Aur, "Train speeds")
                gen.WriteOut(line, ses)
                form9G2 =  this_9["motor_TEs"]
                decpl = (3,)*4
                if USunits:
                    keys = ("Force1",) * 4 # tractive effort in Newtons
                    decpl = (3, 3, 3, 3)
                    # Convert the units to US and adjust the count of decimal places.
                    form9G2 = [USc.ConvertToUS(keys[i], form9G2[i], False, self.log)[0]
                                    for i in range(len(keys))]
                line = gen.FormatInpLine(form9G2, decpl, "9G2", USunits, self.log,
                                         Aur, "Motor tractive efforts")
                gen.WriteOut(line, ses)
                form9G3 =  this_9["motor_amps"]
                decpl = (3,)*4
                line = gen.FormatInpLine(form9G3, decpl, "9G2", USunits, self.log,
                                    Aur, "Motor amps")
                gen.WriteOut(line, ses)

                cams_or_choppers = this_9["train_control"]
                form9G4 =  (cams_or_choppers, )
                decpl = (0,)
                if target.upper()[:3] == "SVS":
                    comment = "1 = cams (no forms 9H, 9J-9L), 2 = choppers, "\
                              "3 = use form 9H-A"
                else:
                    comment = "1 = cams (no forms 9H, 9J-9L), 2 = choppers"
                line = gen.FormatInpLine(form9G4, decpl, "9G4", USunits, self.log,
                             Aur, comment)
                gen.WriteOut(line, ses)

                # Check if we need to write form 9H
                if cams_or_choppers >= 2:
                    form9H1 =  this_9["line_amps"]
                    decpl = (3,)*5
                    line = gen.FormatInpLine(form9H1, decpl, "9H1", USunits, self.log,
                                        Aur, "Form 9H Line amps")
                    gen.WriteOut(line, ses)

                    form9H2 = (this_9["effic1"],
                               this_9["speed1"],
                               this_9["effic2"],
                               this_9["regen_fac"],
                               this_9["flywheels"]
                              )
                    decpl = (3, 3, 3, 3, 0)
                    if USunits:
                        keys = ("null", "speed2", "null", "null", "null")
                        # Convert the units to US and adjust the count of decimal places.
                        form9H2 = [USc.ConvertToUS(keys[i], form9H2[i], False, self.log)[0]
                                        for i in range(len(keys))]
                    line = gen.FormatInpLine(form9H2, decpl, "9H2", USunits, self.log,
                                Aur, "effic1, speed, effic2, regen, 2=flywheels")
                    gen.WriteOut(line, ses)

                form9I = (this_9["cam_spd2"],
                          this_9["cam_spd3"],
                          this_9["mtr_ohms1"],
                          this_9["mtr_ohms2"],
                          this_9["mtr_ohms3"]
                           )
                decpl = (3, 3, 4, 4, 4)
                if cams_or_choppers >= 2:
                    # Set a description suitable for chopper control
                    descrip = "Choppers: 4 zeros & 1 motor ohms (0.001-0.3)"
                else:
                    # Set a description for cam control
                    descrip = "Cams: 2 speeds and 3 motor ohms (0.001-0.3)"
                    decpl = (3, 3, 3, 3, 3)
                if USunits:
                    keys = ("speed2", "speed2", "null", "null", "null")
                    # Convert the units to US and adjust the count of decimal places.
                    form9I = [USc.ConvertToUS(keys[i], form9I[i], False, self.log)[0]
                                    for i in range(len(keys))]
                line = gen.FormatInpLine(form9I, decpl, "9I", USunits, self.log, Aur, descrip)
                gen.WriteOut(line, ses)

                if trperfopt == 1:
                    form9J = (this_9["max_accel"],
                              this_9["low_spd_decel"],
                              this_9["decel_V1"],
                              this_9["high_spd_decel"],
                              this_9["decel_V2"],
                             )
                    decpl = (3,)*5
                    if USunits:
                        keys = ("accel", "accel", "speed2", "accel", "speed2")
                        # Convert the units to US and adjust the count of decimal places.
                        form9J = [USc.ConvertToUS(keys[i], form9J[i], False, self.log)[0]
                                        for i in range(len(keys))]
                    line = gen.FormatInpLine(form9J, decpl, "9J", USunits, self.log,
                                        Aur, "accel, decel<V1, V1, decel>V1, max V")
                    gen.WriteOut(line, ses)

                    # Check if we need flywheels with our chopper control
                    if cams_or_choppers >= 2 and this_9["flywheels"] >= 2:
                        form9K = (this_9["fw_momint"],
                                  this_9["fw_count"],
                                  this_9["fw_min_speed"],
                                  this_9["fw_max_speed"],
                                  this_9["fw_start_speed"],
                                 )
                        decpl = (3, 0, 1, 1, 1)
                        if USunits:
                            keys = ("momint", "null", "null", "null", "null")
                            # Convert the units to US and adjust the count of decimal places.
                            form9K = [USc.ConvertToUS(keys[i], form9K[i], False, self.log)[0]
                                            for i in range(len(keys))]
                        line = gen.FormatInpLine(form9K, decpl, "9K", USunits, self.log,
                                    Aur, "moment, wheels, minspd, maxspd, startspd")
                        gen.WriteOut(line, ses)

                        form9L = (this_9["fw_effic1"],
                                  this_9["fw_effic2"],
                                  this_9["fw_coeff1"],
                                  this_9["fw_coeff2"],
                                  this_9["fw_coeff3"],
                                  this_9["fw_exp1"],
                                  this_9["fw_exp2"]
                                 )
                        decpl = (3, 3, 12, 12, 12, 3, 3)
                        line = gen.FormatInpLine(form9L, decpl, "9L", USunits, self.log,
                                    Aur, "2 effics, 3 coeffs, 2 exponents")
                        gen.WriteOut(line, ses)

        # Print the description on a line of its own
        for train in self.form10_dict.keys():
            this_10 = self.form10_dict[train]
            # Form 10
            # First check if the grid temperatures are equal to the outside air
            # temperature.  If they are, replace them with zero values.
            # Unfortunately we can't tell from the output file what the input
            # file used.
            ext_temp = self.settings_dict["ext_DB"]
            if math.isclose(this_10["tr_accel_temp"], ext_temp):
                accel_temp = 0.0
            else:
                accel_temp = this_10["tr_accel_temp"]
            if math.isclose(this_10["tr_decel_temp"], ext_temp):
                decel_temp = 0.0
            else:
                decel_temp = this_10["tr_decel_temp"]
            form10 = [this_10["tr_chainage"],
                      this_10["tr_speed"],
                      this_10["tr_route"],
                      this_10["tr_type"],
                      accel_temp,
                      decel_temp,
                      this_10["tr_dwell"],
                      this_10["tr_coasting"]
                     ]
            decpl = (3, 3, 0, 0, 3, 3, 1, 0)
            if train == 1:
                descrip = "ch, spd, rte, typ, accel/decel temps, dwell, coast"
            else:
                descrip = ""
            if USunits:
                # Convert the units to US.  The grid temperatures are kept
                # as zero if they are below 0.1 deg F.
                keys = ("dist1", "speed2", "null", "null",
                        "tempzero3", "tempzero3", "null", "null")
                # Convert the units to US and adjust the count of decimal places.
                form10 = [USc.ConvertToUS(keys[i], form10[i], False, self.log)[0]
                                for i in range(len(keys))]
            line = gen.FormatInpLine(form10, decpl, "10", USunits, self.log, Aur, descrip)
            gen.WriteOut(line, ses)

        for zone in self.form11_dict.keys():
            this_11 = self.form11_dict[zone]
            # Form 11A
            zone_type = this_11["z_type"]
            seg_count = this_11["z_count"]
            decpl = (0, 0, 3, 3, 3, 3)
            if zone_type == 1:
                # Write the temperatures
                form11A = (zone_type, seg_count,
                           this_11["z_morn_DB"],
                           this_11["z_morn_WB"],
                           this_11["z_eve_DB"],
                           this_11["z_eve_WB"],
                          )
                decpl = (0, 0, 3, 3, 3, 3)
                if USunits:
                    keys = ("null", "null", "temp", "temp", "temp", "temp")
                    # Convert the units to US and adjust the count of decimal places.
                    form11A = [USc.ConvertToUS(keys[i], form11A[i], False, self.log)[0]
                                    for i in range(len(keys))]
            else:
                form11A = (zone_type, seg_count)
                decpl = (0, 0)
            line = gen.FormatInpLine(form11A, decpl, "11A", USunits, self.log, Aur, "Form 11A")
            gen.WriteOut(line, ses)

            if len(self.form11_dict) != 1:
                # Write form 11B if there is more than one zone.  First
                # figure out how many lines we need to write.
                quot, rem = divmod(seg_count, 8)
                if rem != 0:
                    quot += 1
                decpl = (0,)*8
                start = 0
                for index_11B in range(quot):
                    start = index_11B * 8
                    form11B = (this_11["z_seg_list"][start:start + 8])
                    line = gen.FormatInpLine(form11B, decpl, "11B", USunits, self.log, Aur)
                    gen.WriteOut(line, ses)

        form12_groups = self.form12_dict["group_count"]
        form12_1 = (self.form12_dict["temp_tab"], form12_groups)
        decpl = (3, 0)
        if USunits:
            keys = ("tdiff", "null")
            # Convert the units to US and adjust the count of decimal places.
            form12_1 = [USc.ConvertToUS(keys[i], form12_1[i], False, self.log)[0]
                            for i in range(len(keys))]
        line = gen.FormatInpLine(form12_1, decpl, "12_1", USunits, self.log, Aur, "Form 12A")
        gen.WriteOut(line, ses)

        # Build the groups of form 12 lines.
        form12_2s = list(zip(self.form12_dict["intervals"],
                             self.form12_dict["time_ints"],
                             self.form12_dict["abbreviated"],
                             self.form12_dict["summary"],
                             self.form12_dict["aero_cycles"],
                             self.form12_dict["thermo_cycles"])
                        )
        decpl = [0, 2, 0, 0, 0, 0]
        descrip = "count seconds abbrev ECZs aero & thermo cycles"

        # SVS has an extra input for the timestep in a binary file.  The code
        # below and at the top of the next 'for' loop processes it, but is
        # commented out, as it seems that SVS doesn't use it for anything.
        # if target.upper()[:3] == "SVS":
        #     decpl.append(2)
        #     for index in range(len(form12_2s)):
        #         form12_2s[index] = list(form12_2s[index]) + [0.]
        # Write the lines of form 12 entries.
        for form12_2 in form12_2s:

            line = gen.FormatInpLine(form12_2, decpl, "12_2", USunits, self.log, Aur, descrip)
            # Set the comments after the 80th character depending on the summary
            # option.
            if form12_2[3] == 0:
                descrip = ""
            elif form12_2[3] == 1:
                descrip = "Initialize"
            elif form12_2[3] == 2:
                descrip = "Summary"
            elif form12_2[3] == 3:
                descrip = "Summary and initialize"
            elif form12_2[3] == 4:
                descrip = "Summary, ECZ estimate, initialize"
            gen.WriteOut(line, ses)

        form13 = (self.form13_dict["aero_timestep"]*100,
                  self.form13_dict["run_time"],
                  self.form13_dict["train_cycles"],
                  self.form13_dict["wall_cycles"]
                 )
        decpl = (0, 1, 0, 0)
        descrip = "timestep, runtime, train cycles, wall cycles"
        line = gen.FormatInpLine(form13, decpl, "13", USunits, self.log, Aur, descrip)
        gen.WriteOut(line, ses)
        # Add a blank line at the end.
        gen.WriteOut("", ses)

        ses.close()
        return('Successfully wrote "' + new_name + '".')

    def _CheckProperty(self, prop):
        '''This is a QA routine.  It is used to check the contents
        of the curve types in the user manual against the contents
        of the curve types in the class.  The aim is to ensure that
        every property that can be plotted has an entry in the
        manual.

        It is intended to be used in a Python session.  The first
        time it is called during the session, it generates a list
        that contains all the keys to the curve properties, then
        removes the name that was passed in the call.  On each
        subsequent call, it removes the name of the property.

        If the name does not exist in the list of keys, it states
        that.

        The aim of it is to ensure that the each property in the
        class has an entry in the user manual.  The calls are best
        built by taking the contents of "Hobyah-User-Guide.toc"
        and wrangling them into calls to this routine.
        '''
        try:
            self.remaining
        except:
            print("Generating the list of remaining curve keywords")
            self.remaining = list(self.properties.keys())

        if prop.lower() in self.remaining:
            self.remaining.remove(prop.lower())
        else:
            print('Whoah, found a property with an entry in the user\n'
                  'manual that is not in the class, "' + prop + '.\n'
                  'Please check this and adjust one or the other if\n'
                  'there is not a typo in the call.')
        return()

# The text below is useful when developing in a terminal session.
# The last line is used after to reload everything after changing
# the source code above.
'''
import importlib
import classSES as clS
log = open("log_discard.txt", "w")

subf = "test-files"
fname = "S-file-valid-1.sbn"

subf = "files-SES/2021-08-files/SES41-tests"
fname = "SES-sample-project-1.sbn"

bfses = clS.SESdata(subf, "SES-sample-project-1.sbn", log)
importlib.reload(clS)
'''

